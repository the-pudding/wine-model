(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents = {};

  var event = null;

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = event; // Events can be reentrant (e.g., focus).
      event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function customEvent(event1, listener, that, args) {
    var event0 = event;
    event1.sourceEvent = event;
    event = event1;
    try {
      return listener.apply(that, args);
    } finally {
      event = event0;
    }
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function sourceEvent() {
    var current = event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : selector], root);
  }

  function touch(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return point(node, touch);
      }
    }

    return null;
  }

  var frame = 0, // is an animation frame pending?
      timeout = 0, // is a timeout pending?
      interval = 0, // are any timers active?
      pokeDelay = 1000, // how frequently we check for clock skew
      taskHead,
      taskTail,
      clockLast = 0,
      clockNow = 0,
      clockSkew = 0,
      clock = typeof performance === "object" && performance.now ? performance : Date,
      setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }

  function clearNow() {
    clockNow = 0;
  }

  function Timer() {
    this._call =
    this._time =
    this._next = null;
  }

  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };

  function timer(callback, delay, time) {
    var t = new Timer;
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush() {
    now(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
      t = t._next;
    }
    --frame;
  }

  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }

  function poke() {
    var now = clock.now(), delay = now - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
  }

  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }

  function sleep(time) {
    if (frame) return; // Soonest alarm already set, or will be.
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  function timeout$1(callback, delay, time) {
    var t = new Timer;
    delay = delay == null ? 0 : +delay;
    t.restart(function(elapsed) {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  var noop = {value: function() {}};

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames$1(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames$1(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
        else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({name: name, value: callback});
    return type;
  }

  var frame$1 = 0, // is an animation frame pending?
      timeout$2 = 0, // is a timeout pending?
      interval$1 = 0, // are any timers active?
      pokeDelay$1 = 1000, // how frequently we check for clock skew
      taskHead$1,
      taskTail$1,
      clockLast$1 = 0,
      clockNow$1 = 0,
      clockSkew$1 = 0,
      clock$1 = typeof performance === "object" && performance.now ? performance : Date,
      setFrame$1 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

  function now$1() {
    return clockNow$1 || (setFrame$1(clearNow$1), clockNow$1 = clock$1.now() + clockSkew$1);
  }

  function clearNow$1() {
    clockNow$1 = 0;
  }

  function Timer$1() {
    this._call =
    this._time =
    this._next = null;
  }

  Timer$1.prototype = timer$1.prototype = {
    constructor: Timer$1,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail$1 !== this) {
        if (taskTail$1) taskTail$1._next = this;
        else taskHead$1 = this;
        taskTail$1 = this;
      }
      this._call = callback;
      this._time = time;
      sleep$1();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep$1();
      }
    }
  };

  function timer$1(callback, delay, time) {
    var t = new Timer$1;
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush$1() {
    now$1(); // Get the current time, if not already set.
    ++frame$1; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead$1, e;
    while (t) {
      if ((e = clockNow$1 - t._time) >= 0) t._call.call(null, e);
      t = t._next;
    }
    --frame$1;
  }

  function wake$1() {
    clockNow$1 = (clockLast$1 = clock$1.now()) + clockSkew$1;
    frame$1 = timeout$2 = 0;
    try {
      timerFlush$1();
    } finally {
      frame$1 = 0;
      nap$1();
      clockNow$1 = 0;
    }
  }

  function poke$1() {
    var now = clock$1.now(), delay = now - clockLast$1;
    if (delay > pokeDelay$1) clockSkew$1 -= delay, clockLast$1 = now;
  }

  function nap$1() {
    var t0, t1 = taskHead$1, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead$1 = t2;
      }
    }
    taskTail$1 = t0;
    sleep$1(time);
  }

  function sleep$1(time) {
    if (frame$1) return; // Soonest alarm already set, or will be.
    if (timeout$2) timeout$2 = clearTimeout(timeout$2);
    var delay = time - clockNow$1; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
      if (time < Infinity) timeout$2 = setTimeout(wake$1, time - clock$1.now() - clockSkew$1);
      if (interval$1) interval$1 = clearInterval(interval$1);
    } else {
      if (!interval$1) clockLast$1 = clock$1.now(), interval$1 = setInterval(poke$1, pokeDelay$1);
      frame$1 = 1, setFrame$1(wake$1);
    }
  }

  function timeout$3(callback, delay, time) {
    var t = new Timer$1;
    delay = delay == null ? 0 : +delay;
    t.restart(function(elapsed) {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];

  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;

  function schedule(node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id in schedules) return;
    create(node, id, {
      name: name,
      index: index, // For context during callback.
      group: group, // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }

  function init(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }

  function set$1(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }

  function get$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
    return schedule;
  }

  function create(node, id, self) {
    var schedules = node.__transition,
        tween;

    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = timer$1(schedule, 0, self.time);

    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start, self.delay, self.time);

      // If the elapsed delay is less than our first sleep, start immediately.
      if (self.delay <= elapsed) start(elapsed - self.delay);
    }

    function start(elapsed) {
      var i, j, n, o;

      // If the state is not SCHEDULED, then we previously errored on start.
      if (self.state !== SCHEDULED) return stop();

      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name) continue;

        // While this element already has a starting transition during this frame,
        // defer starting an interrupting transition until that transition has a
        // chance to tick (and possibly end); see d3/d3-transition#54!
        if (o.state === STARTED) return timeout$3(start);

        // Interrupt the active transition, if any.
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }

        // Cancel any pre-empted transitions.
        else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }

      // Defer the first tick to end of the current frame; see d3/d3#1576.
      // Note the transition may be canceled after start and before the first tick!
      // Note this must be scheduled before the start event; see d3/d3-transition#16!
      // Assuming this is successful, subsequent callbacks go straight to tick.
      timeout$3(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });

      // Dispatch the start event.
      // Note this must be done before the tween are initialized.
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING) return; // interrupted
      self.state = STARTED;

      // Initialize the tween, deleting null tween.
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }

    function tick(elapsed) {
      var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
          i = -1,
          n = tween.length;

      while (++i < n) {
        tween[i].call(node, t);
      }

      // Dispatch the end event.
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }

    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id];
      for (var i in schedules) return; // eslint-disable-line no-unused-vars
      delete node.__transition;
    }
  }

  function interrupt(node, name) {
    var schedules = node.__transition,
        schedule,
        active,
        empty = true,
        i;

    if (!schedules) return;

    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }

    if (empty) delete node.__transition;
  }

  function selection_interrupt(name) {
    return this.each(function() {
      interrupt(this, name);
    });
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }

  function rgb_formatRgb() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
  }

  var interpolateRgb = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb$1(start, end) {
      var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb$1.gamma = rgbGamma;

    return rgb$1;
  })(1);

  function numberArray(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function genericArray(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function interpolateNumber(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function interpolateString(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolateValue(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant$1(b)
        : (t === "number" ? interpolateNumber
        : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
        : b instanceof color ? interpolateRgb
        : b instanceof Date ? date
        : isNumberArray(b) ? numberArray
        : Array.isArray(b) ? genericArray
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
        : interpolateNumber)(a, b);
  }

  function interpolateRound(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  var degrees = 180 / Math.PI;

  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };

  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var cssNode,
      cssRoot,
      cssView,
      svgNode;

  function parseCss(value) {
    if (value === "none") return identity;
    if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    value = value.slice(7, -1).split(",");
    return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
  }

  function parseSvg(value) {
    if (value == null) return identity;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  function interpolateTransform(parse, pxComma, pxParen, degParen) {

    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }

    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }

    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
        q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }

    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }

    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }

    return function(a, b) {
      var s = [], // string constants and placeholders
          q = []; // number interpolators
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null; // gc
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }

  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  function tweenRemove(id, name) {
    var tween0, tween1;
    return function() {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }

      schedule.tween = tween1;
    };
  }

  function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error;
    return function() {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) tween1.push(t);
      }

      schedule.tween = tween1;
    };
  }

  function transition_tween(name, value) {
    var id = this._id;

    name += "";

    if (arguments.length < 2) {
      var tween = get$1(this.node(), id).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }

    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
  }

  function tweenValue(transition, name, value) {
    var id = transition._id;

    transition.each(function() {
      var schedule = set$1(this, id);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });

    return function(node) {
      return get$1(node, id).value[name];
    };
  }

  function interpolate(a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber
        : b instanceof color ? interpolateRgb
        : (c = color(b)) ? (b = c, interpolateRgb)
        : interpolateString)(a, b);
  }

  function attrRemove$1(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrConstantNS$1(fullname, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function attrFunctionNS$1(fullname, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function transition_attr(name, value) {
    var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
    return this.attrTween(name, typeof value === "function"
        ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
        : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
        : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
  }

  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i.call(this, t));
    };
  }

  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }

  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function transition_attrTween(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  function delayFunction(id, value) {
    return function() {
      init(this, id).delay = +value.apply(this, arguments);
    };
  }

  function delayConstant(id, value) {
    return value = +value, function() {
      init(this, id).delay = value;
    };
  }

  function transition_delay(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? delayFunction
            : delayConstant)(id, value))
        : get$1(this.node(), id).delay;
  }

  function durationFunction(id, value) {
    return function() {
      set$1(this, id).duration = +value.apply(this, arguments);
    };
  }

  function durationConstant(id, value) {
    return value = +value, function() {
      set$1(this, id).duration = value;
    };
  }

  function transition_duration(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? durationFunction
            : durationConstant)(id, value))
        : get$1(this.node(), id).duration;
  }

  function easeConstant(id, value) {
    if (typeof value !== "function") throw new Error;
    return function() {
      set$1(this, id).ease = value;
    };
  }

  function transition_ease(value) {
    var id = this._id;

    return arguments.length
        ? this.each(easeConstant(id, value))
        : get$1(this.node(), id).ease;
  }

  function transition_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  function transition_merge(transition) {
    if (transition._id !== this._id) throw new Error;

    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Transition(merges, this._parents, this._name, this._id);
  }

  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0) t = t.slice(0, i);
      return !t || t === "start";
    });
  }

  function onFunction(id, name, listener) {
    var on0, on1, sit = start(name) ? init : set$1;
    return function() {
      var schedule = sit(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

      schedule.on = on1;
    };
  }

  function transition_on(name, listener) {
    var id = this._id;

    return arguments.length < 2
        ? get$1(this.node(), id).on.on(name)
        : this.each(onFunction(id, name, listener));
  }

  function removeFunction(id) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition) if (+i !== id) return;
      if (parent) parent.removeChild(this);
    };
  }

  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }

  function transition_select(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
        }
      }
    }

    return new Transition(subgroups, this._parents, name, id);
  }

  function transition_selectAll(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
            if (child = children[k]) {
              schedule(child, name, id, k, children, inherit);
            }
          }
          subgroups.push(children);
          parents.push(node);
        }
      }
    }

    return new Transition(subgroups, parents, name, id);
  }

  var Selection$1 = selection.prototype.constructor;

  function transition_selection() {
    return new Selection$1(this._groups, this._parents);
  }

  function styleNull(name, interpolate) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }

  function styleRemove$1(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function styleFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          value1 = value(this),
          string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function styleMaybeRemove(id, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
    return function() {
      var schedule = set$1(this, id),
          on = schedule.on,
          listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

      schedule.on = on1;
    };
  }

  function transition_style(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
    return value == null ? this
        .styleTween(name, styleNull(name, i))
        .on("end.style." + name, styleRemove$1(name))
      : typeof value === "function" ? this
        .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
        .each(styleMaybeRemove(this._id, name))
      : this
        .styleTween(name, styleConstant$1(name, i, value), priority)
        .on("end.style." + name, null);
  }

  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i.call(this, t), priority);
    };
  }

  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }

  function transition_styleTween(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction$1(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }

  function transition_text(value) {
    return this.tween("text", typeof value === "function"
        ? textFunction$1(tweenValue(this, "text", value))
        : textConstant$1(value == null ? "" : value + ""));
  }

  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }

  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error;
    return this.tween(key, textTween(value));
  }

  function transition_transition() {
    var name = this._name,
        id0 = this._id,
        id1 = newId();

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit = get$1(node, id0);
          schedule(node, name, id1, i, group, {
            time: inherit.time + inherit.delay + inherit.duration,
            delay: 0,
            duration: inherit.duration,
            ease: inherit.ease
          });
        }
      }
    }

    return new Transition(groups, this._parents, name, id1);
  }

  function transition_end() {
    var on0, on1, that = this, id = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = {value: reject},
          end = {value: function() { if (--size === 0) resolve(); }};

      that.each(function() {
        var schedule = set$1(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }

        schedule.on = on1;
      });
    });
  }

  var id = 0;

  function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
  }

  function transition(name) {
    return selection().transition(name);
  }

  function newId() {
    return ++id;
  }

  var selection_prototype = selection.prototype;

  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    end: transition_end
  };

  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  var defaultTiming = {
    time: null, // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };

  function inherit(node, id) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id])) {
      if (!(node = node.parentNode)) {
        return defaultTiming.time = now$1(), defaultTiming;
      }
    }
    return timing;
  }

  function selection_transition(name) {
    var id,
        timing;

    if (name instanceof Transition) {
      id = name._id, name = name._name;
    } else {
      id = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "";
    }

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule(node, name, id, i, group, timing || inherit(node, id));
        }
      }
    }

    return new Transition(groups, this._parents, name, id);
  }

  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;

  var EOL = {},
      EOF = {},
      QUOTE = 34,
      NEWLINE = 10,
      RETURN = 13;

  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + "] || \"\"";
    }).join(",") + "}");
  }

  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
      return f(object(row), i, columns);
    };
  }

  // Compute unique columns in order of discovery.
  function inferColumns(rows) {
    var columnSet = Object.create(null),
        columns = [];

    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });

    return columns;
  }

  function pad(value, width) {
    var s = value + "", length = s.length;
    return length < width ? new Array(width - length + 1).join(0) + s : s;
  }

  function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6)
      : year > 9999 ? "+" + pad(year, 6)
      : pad(year, 4);
  }

  function formatDate(date) {
    var hours = date.getUTCHours(),
        minutes = date.getUTCMinutes(),
        seconds = date.getUTCSeconds(),
        milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date"
        : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
        + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
        : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
        : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
        : "");
  }

  function dsvFormat(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
        DELIMITER = delimiter.charCodeAt(0);

    function parse(text, f) {
      var convert, columns, rows = parseRows(text, function(row, i) {
        if (convert) return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }

    function parseRows(text, f) {
      var rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // current line number
          t, // current token
          eof = N <= 0, // current token followed by EOF?
          eol = false; // current token followed by EOL?

      // Strip the trailing newline.
      if (text.charCodeAt(N - 1) === NEWLINE) --N;
      if (text.charCodeAt(N - 1) === RETURN) --N;

      function token() {
        if (eof) return EOF;
        if (eol) return eol = false, EOL;

        // Unescape quotes.
        var i, j = I, c;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
          if ((i = I) >= N) eof = true;
          else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
          return text.slice(j + 1, i - 1).replace(/""/g, "\"");
        }

        // Find next delimiter or newline.
        while (I < N) {
          if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
          else if (c !== DELIMITER) continue;
          return text.slice(j, i);
        }

        // Return last token before EOF.
        return eof = true, text.slice(j, N);
      }

      while ((t = token()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF) row.push(t), t = token();
        if (f && (row = f(row, n++)) == null) continue;
        rows.push(row);
      }

      return rows;
    }

    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      });
    }

    function format(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }

    function formatBody(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(value) {
      return value == null ? ""
          : value instanceof Date ? formatDate(value)
          : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
          : value;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatBody: formatBody,
      formatRows: formatRows,
      formatRow: formatRow,
      formatValue: formatValue
    };
  }

  var csv = dsvFormat(",");

  var csvParse = csv.parse;

  function autoType(object) {
    for (var key in object) {
      var value = object[key].trim(), number, m;
      if (!value) value = null;
      else if (value === "true") value = true;
      else if (value === "false") value = false;
      else if (value === "NaN") value = NaN;
      else if (!isNaN(number = +value)) value = number;
      else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
        value = new Date(value);
      }
      else continue;
      object[key] = value;
    }
    return object;
  }

  // https://github.com/d3/d3-dsv/issues/45
  var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

  function responseText(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    return response.text();
  }

  function text(input, init) {
    return fetch(input, init).then(responseText);
  }

  function dsvParse(parse) {
    return function(input, init, row) {
      if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
      return text(input, init).then(function(response) {
        return parse(response, row);
      });
    };
  }

  var csv$1 = dsvParse(csvParse);

  function image(input, init) {
    return new Promise(function(resolve, reject) {
      var image = new Image;
      for (var key in init) image[key] = init[key];
      image.onerror = reject;
      image.onload = function() { resolve(image); };
      image.src = input;
    });
  }

  function responseJson(response) {
    if (!response.ok) throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205) return;
    return response.json();
  }

  function json(input, init) {
    return fetch(input, init).then(responseJson);
  }

  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending$1(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending$1);
  var bisectRight = ascendingBisect.right;

  function number(x) {
    return x === null ? NaN : +x;
  }

  function extent(values, valueof) {
    var n = values.length,
        i = -1,
        value,
        min,
        max;

    if (valueof == null) {
      while (++i < n) { // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          min = max = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = values[i]) != null) {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
    }

    else {
      while (++i < n) { // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          min = max = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null) {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
    }

    return [min, max];
  }

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  var e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);

  function ticks(start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  }

  function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function threshold(values, p, valueof) {
    if (valueof == null) valueof = number;
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n,
        i = (n - 1) * p,
        i0 = Math.floor(i),
        value0 = +valueof(values[i0], i0, values),
        value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }

  function max(values, valueof) {
    var n = values.length,
        i = -1,
        value,
        max;

    if (valueof == null) {
      while (++i < n) { // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          max = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = values[i]) != null && value > max) {
              max = value;
            }
          }
        }
      }
    }

    else {
      while (++i < n) { // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          max = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null && value > max) {
              max = value;
            }
          }
        }
      }
    }

    return max;
  }

  function mean(values, valueof) {
    var n = values.length,
        m = n,
        i = -1,
        value,
        sum = 0;

    if (valueof == null) {
      while (++i < n) {
        if (!isNaN(value = number(values[i]))) sum += value;
        else --m;
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
        else --m;
      }
    }

    if (m) return sum / m;
  }

  function median(values, valueof) {
    var n = values.length,
        i = -1,
        value,
        numbers = [];

    if (valueof == null) {
      while (++i < n) {
        if (!isNaN(value = number(values[i]))) {
          numbers.push(value);
        }
      }
    }

    else {
      while (++i < n) {
        if (!isNaN(value = number(valueof(values[i], i, values)))) {
          numbers.push(value);
        }
      }
    }

    return threshold(numbers.sort(ascending$1), 0.5);
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function min(values, valueof) {
    var n = values.length,
        i = -1,
        value,
        min;

    if (valueof == null) {
      while (++i < n) { // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          min = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = values[i]) != null && min > value) {
              min = value;
            }
          }
        }
      }
    }

    else {
      while (++i < n) { // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          min = value;
          while (++i < n) { // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null && min > value) {
              min = value;
            }
          }
        }
      }
    }

    return min;
  }

  var prefix = "$";

  function Map() {}

  Map.prototype = map.prototype = {
    constructor: Map,
    has: function(key) {
      return (prefix + key) in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function() {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function() {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function(f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map(object, f) {
    var map = new Map;

    // Copy constructor.
    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) map.set(i, object[i]);
      else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  function nest() {
    var keys = [],
        sortKeys = [],
        sortValues,
        rollup,
        nest;

    function apply(array, depth, createResult, setResult) {
      if (depth >= keys.length) {
        if (sortValues != null) array.sort(sortValues);
        return rollup != null ? rollup(array) : array;
      }

      var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          value,
          valuesByKey = map(),
          values,
          result = createResult();

      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
          values.push(value);
        } else {
          valuesByKey.set(keyValue, [value]);
        }
      }

      valuesByKey.each(function(values, key) {
        setResult(result, key, apply(values, depth, createResult, setResult));
      });

      return result;
    }

    function entries(map, depth) {
      if (++depth > keys.length) return map;
      var array, sortKey = sortKeys[depth - 1];
      if (rollup != null && depth >= keys.length) array = map.entries();
      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
    }

    return nest = {
      object: function(array) { return apply(array, 0, createObject, setObject); },
      map: function(array) { return apply(array, 0, createMap, setMap); },
      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
      key: function(d) { keys.push(d); return nest; },
      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
      sortValues: function(order) { sortValues = order; return nest; },
      rollup: function(f) { rollup = f; return nest; }
    };
  }

  function createObject() {
    return {};
  }

  function setObject(object, key, value) {
    object[key] = value;
  }

  function createMap() {
    return map();
  }

  function setMap(map, key, value) {
    map.set(key, value);
  }

  function Set() {}

  var proto = map.prototype;

  Set.prototype = set$2.prototype = {
    constructor: Set,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  function set$2(object, f) {
    var set = new Set;

    // Copy constructor.
    if (object instanceof Set) object.each(function(value) { set.add(value); });

    // Otherwise, assume it’s an array.
    else if (object) {
      var i = -1, n = object.length;
      if (f == null) while (++i < n) set.add(object[i]);
      else while (++i < n) set.add(f(object[i], i, object));
    }

    return set;
  }

  function t(t,e,s){if(t&&t.length){const[n,o]=e,a=Math.PI/180*s,r=Math.cos(a),h=Math.sin(a);t.forEach(t=>{const[e,s]=t;t[0]=(e-n)*r-(s-o)*h+n,t[1]=(e-n)*h+(s-o)*r+o;});}}function e(t){const e=t[0],s=t[1];return Math.sqrt(Math.pow(e[0]-s[0],2)+Math.pow(e[1]-s[1],2))}function s(t,e,s,n){const o=e[1]-t[1],a=t[0]-e[0],r=o*t[0]+a*t[1],h=n[1]-s[1],i=s[0]-n[0],c=h*s[0]+i*s[1],l=o*i-h*a;return l?[(i*r-a*c)/l,(o*c-h*r)/l]:null}function n(t,e,s){const n=t.length;if(n<3)return !1;const h=[Number.MAX_SAFE_INTEGER,s],i=[e,s];let c=0;for(let e=0;e<n;e++){const s=t[e],l=t[(e+1)%n];if(r(s,l,i,h)){if(0===a(s,i,l))return o(s,i,l);c++;}}return c%2==1}function o(t,e,s){return e[0]<=Math.max(t[0],s[0])&&e[0]>=Math.min(t[0],s[0])&&e[1]<=Math.max(t[1],s[1])&&e[1]>=Math.min(t[1],s[1])}function a(t,e,s){const n=(e[1]-t[1])*(s[0]-e[0])-(e[0]-t[0])*(s[1]-e[1]);return 0===n?0:n>0?1:2}function r(t,e,s,n){const r=a(t,e,s),h=a(t,e,n),i=a(s,n,t),c=a(s,n,e);return r!==h&&i!==c||(!(0!==r||!o(t,s,e))||(!(0!==h||!o(t,n,e))||(!(0!==i||!o(s,t,n))||!(0!==c||!o(s,e,n)))))}function h(e,s){const n=[0,0],o=Math.round(s.hachureAngle+90);o&&t(e,n,o);const a=function(t,e){const s=[...t];s[0].join(",")!==s[s.length-1].join(",")&&s.push([s[0][0],s[0][1]]);const n=[];if(s&&s.length>2){let t=e.hachureGap;t<0&&(t=4*e.strokeWidth),t=Math.max(t,.1);const o=[];for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e[1]!==n[1]){const t=Math.min(e[1],n[1]);o.push({ymin:t,ymax:Math.max(e[1],n[1]),x:t===e[1]?e[0]:n[0],islope:(n[0]-e[0])/(n[1]-e[1])});}}if(o.sort((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)),!o.length)return n;let a=[],r=o[0].ymin;for(;a.length||o.length;){if(o.length){let t=-1;for(let e=0;e<o.length&&!(o[e].ymin>r);e++)t=e;o.splice(0,t+1).forEach(t=>{a.push({s:r,edge:t});});}if(a=a.filter(t=>!(t.edge.ymax<=r)),a.sort((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)),a.length>1)for(let t=0;t<a.length;t+=2){const e=t+1;if(e>=a.length)break;const s=a[t].edge,o=a[e].edge;n.push([[Math.round(s.x),r],[Math.round(o.x),r]]);}r+=t,a.forEach(e=>{e.edge.x=e.edge.x+t*e.edge.islope;});}}return n}(e,s);return o&&(t(e,n,-o),function(e,s,n){const o=[];e.forEach(t=>o.push(...t)),t(o,s,n);}(a,n,-o)),a}class i{constructor(t){this.helper=t;}fillPolygon(t,e){return this._fillPolygon(t,e)}_fillPolygon(t,e,s=!1){let n=h(t,e);if(s){const e=this.connectingLines(t,n);n=n.concat(e);}return {type:"fillSketch",ops:this.renderLines(n,e)}}renderLines(t,e){const s=[];for(const n of t)s.push(...this.helper.doubleLineOps(n[0][0],n[0][1],n[1][0],n[1][1],e));return s}connectingLines(t,s){const n=[];if(s.length>1)for(let o=1;o<s.length;o++){const a=s[o-1];if(e(a)<3)continue;const r=[s[o][0],a[1]];if(e(r)>3){const e=this.splitOnIntersections(t,r);n.push(...e);}}return n}midPointInPolygon(t,e){return n(t,(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2)}splitOnIntersections(t,o){const a=Math.max(5,.1*e(o)),h=[];for(let n=0;n<t.length;n++){const i=t[n],c=t[(n+1)%t.length];if(r(i,c,...o)){const t=s(i,c,o[0],o[1]);if(t){const s=e([t,o[0]]),n=e([t,o[1]]);s>a&&n>a&&h.push({point:t,distance:s});}}}if(h.length>1){const e=h.sort((t,e)=>t.distance-e.distance).map(t=>t.point);if(n(t,...o[0])||e.shift(),n(t,...o[1])||e.pop(),e.length<=1)return this.midPointInPolygon(t,o)?[o]:[];const s=[o[0],...e,o[1]],a=[];for(let e=0;e<s.length-1;e+=2){const n=[s[e],s[e+1]];this.midPointInPolygon(t,n)&&a.push(n);}return a}return this.midPointInPolygon(t,o)?[o]:[]}}class c extends i{fillPolygon(t,e){return this._fillPolygon(t,e,!0)}}class l extends i{fillPolygon(t,e){const s=this._fillPolygon(t,e),n=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),o=this._fillPolygon(t,n);return s.ops=s.ops.concat(o.ops),s}}class u{constructor(t){this.helper=t;}fillPolygon(t,e){const s=h(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(s,e)}dotsOnLines(t,s){const n=[];let o=s.hachureGap;o<0&&(o=4*s.strokeWidth),o=Math.max(o,.1);let a=s.fillWeight;a<0&&(a=s.strokeWidth/2);const r=o/4;for(const h of t){const t=e(h),i=t/o,c=Math.ceil(i)-1,l=t-c*o,u=(h[0][0]+h[1][0])/2-o/4,f=Math.min(h[0][1],h[1][1]);for(let t=0;t<c;t++){const e=f+l+t*o,h=this.helper.randOffsetWithRange(u-r,u+r,s),i=this.helper.randOffsetWithRange(e-r,e+r,s),c=this.helper.ellipse(h,i,a,a,s);n.push(...c.ops);}}return {type:"fillSketch",ops:n}}}class f{constructor(t){this.helper=t;}fillPolygon(t,e){const s=h(t,e);return {type:"fillSketch",ops:this.dashedLine(s,e)}}dashedLine(t,s){const n=s.dashOffset<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashOffset,o=s.dashGap<0?s.hachureGap<0?4*s.strokeWidth:s.hachureGap:s.dashGap,a=[];return t.forEach(t=>{const r=e(t),h=Math.floor(r/(n+o)),i=(r+o-h*(n+o))/2;let c=t[0],l=t[1];c[0]>l[0]&&(c=t[1],l=t[0]);const u=Math.atan((l[1]-c[1])/(l[0]-c[0]));for(let t=0;t<h;t++){const e=t*(n+o),r=e+n,h=[c[0]+e*Math.cos(u)+i*Math.cos(u),c[1]+e*Math.sin(u)+i*Math.sin(u)],l=[c[0]+r*Math.cos(u)+i*Math.cos(u),c[1]+r*Math.sin(u)+i*Math.sin(u)];a.push(...this.helper.doubleLineOps(h[0],h[1],l[0],l[1],s));}}),a}}class p{constructor(t){this.helper=t;}fillPolygon(t,e){const s=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,n=e.zigzagOffset<0?s:e.zigzagOffset,o=h(t,e=Object.assign({},e,{hachureGap:s+n}));return {type:"fillSketch",ops:this.zigzagLines(o,n,e)}}zigzagLines(t,s,n){const o=[];return t.forEach(t=>{const a=e(t),r=Math.round(a/(2*s));let h=t[0],i=t[1];h[0]>i[0]&&(h=t[1],i=t[0]);const c=Math.atan((i[1]-h[1])/(i[0]-h[0]));for(let t=0;t<r;t++){const e=2*t*s,a=2*(t+1)*s,r=Math.sqrt(2*Math.pow(s,2)),i=[h[0]+e*Math.cos(c),h[1]+e*Math.sin(c)],l=[h[0]+a*Math.cos(c),h[1]+a*Math.sin(c)],u=[i[0]+r*Math.cos(c+Math.PI/4),i[1]+r*Math.sin(c+Math.PI/4)];o.push(...this.helper.doubleLineOps(i[0],i[1],u[0],u[1],n),...this.helper.doubleLineOps(u[0],u[1],l[0],l[1],n));}}),o}}const d={};class g{constructor(t){this.seed=t;}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const M={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function k(t,e){return t.type===e}function b(t){const e=[],s=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else {if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return [];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length);}return e[e.length]={type:2,text:""},e}(t);let n="BOD",o=0,a=s[o];for(;!k(a,2);){let r=0;const h=[];if("BOD"===n){if("M"!==a.text&&"m"!==a.text)return b("M0,0"+t);o++,r=M[a.text],n=a.text;}else k(a,1)?r=M[n]:(o++,r=M[a.text],n=a.text);if(!(o+r<s.length))throw new Error("Path data ended short");for(let t=o;t<o+r;t++){const e=s[t];if(!k(e,1))throw new Error("Param not a number: "+n+","+e.text);h[h.length]=+e.text;}if("number"!=typeof M[n])throw new Error("Bad segment: "+n);{const t={key:n,data:h};e.push(t),o+=r,a=s[o],"M"===n&&(n="L"),"m"===n&&(n="l");}}return e}function y(t){let e=0,s=0,n=0,o=0;const a=[];for(const{key:r,data:h}of t)switch(r){case"M":a.push({key:"M",data:[...h]}),[e,s]=h,[n,o]=h;break;case"m":e+=h[0],s+=h[1],a.push({key:"M",data:[e,s]}),n=e,o=s;break;case"L":a.push({key:"L",data:[...h]}),[e,s]=h;break;case"l":e+=h[0],s+=h[1],a.push({key:"L",data:[e,s]});break;case"C":a.push({key:"C",data:[...h]}),e=h[4],s=h[5];break;case"c":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"C",data:t}),e=t[4],s=t[5];break}case"Q":a.push({key:"Q",data:[...h]}),e=h[2],s=h[3];break;case"q":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"Q",data:t}),e=t[2],s=t[3];break}case"A":a.push({key:"A",data:[...h]}),e=h[5],s=h[6];break;case"a":e+=h[5],s+=h[6],a.push({key:"A",data:[h[0],h[1],h[2],h[3],h[4],e,s]});break;case"H":a.push({key:"H",data:[...h]}),e=h[0];break;case"h":e+=h[0],a.push({key:"H",data:[e]});break;case"V":a.push({key:"V",data:[...h]}),s=h[0];break;case"v":s+=h[0],a.push({key:"V",data:[s]});break;case"S":a.push({key:"S",data:[...h]}),e=h[2],s=h[3];break;case"s":{const t=h.map((t,n)=>n%2?t+s:t+e);a.push({key:"S",data:t}),e=t[2],s=t[3];break}case"T":a.push({key:"T",data:[...h]}),e=h[0],s=h[1];break;case"t":e+=h[0],s+=h[1],a.push({key:"T",data:[e,s]});break;case"Z":case"z":a.push({key:"Z",data:[]}),e=n,s=o;}return a}function m(t){const e=[];let s="",n=0,o=0,a=0,r=0,h=0,i=0;for(const{key:c,data:l}of t){switch(c){case"M":e.push({key:"M",data:[...l]}),[n,o]=l,[a,r]=l;break;case"C":e.push({key:"C",data:[...l]}),n=l[4],o=l[5],h=l[2],i=l[3];break;case"L":e.push({key:"L",data:[...l]}),[n,o]=l;break;case"H":n=l[0],e.push({key:"L",data:[n,o]});break;case"V":o=l[0],e.push({key:"L",data:[n,o]});break;case"S":{let t=0,a=0;"C"===s||"S"===s?(t=n+(n-h),a=o+(o-i)):(t=n,a=o),e.push({key:"C",data:[t,a,...l]}),h=l[0],i=l[1],n=l[2],o=l[3];break}case"T":{const[t,a]=l;let r=0,c=0;"Q"===s||"T"===s?(r=n+(n-h),c=o+(o-i)):(r=n,c=o);const u=n+2*(r-n)/3,f=o+2*(c-o)/3,p=t+2*(r-t)/3,d=a+2*(c-a)/3;e.push({key:"C",data:[u,f,p,d,t,a]}),h=r,i=c,n=t,o=a;break}case"Q":{const[t,s,a,r]=l,c=n+2*(t-n)/3,u=o+2*(s-o)/3,f=a+2*(t-a)/3,p=r+2*(s-r)/3;e.push({key:"C",data:[c,u,f,p,a,r]}),h=t,i=s,n=a,o=r;break}case"A":{const t=Math.abs(l[0]),s=Math.abs(l[1]),a=l[2],r=l[3],h=l[4],i=l[5],c=l[6];if(0===t||0===s)e.push({key:"C",data:[n,o,i,c,i,c]}),n=i,o=c;else if(n!==i||o!==c){P(n,o,i,c,t,s,a,r,h).forEach((function(t){e.push({key:"C",data:t});})),n=i,o=c;}break}case"Z":e.push({key:"Z",data:[]}),n=a,o=r;}s=c;}return e}function w(t,e,s){return [t*Math.cos(s)-e*Math.sin(s),t*Math.sin(s)+e*Math.cos(s)]}function P(t,e,s,n,o,a,r,h,i,c){const l=(u=r,Math.PI*u/180);var u;let f=[],p=0,d=0,g=0,M=0;if(c)[p,d,g,M]=c;else {[t,e]=w(t,e,-l),[s,n]=w(s,n,-l);const r=(t-s)/2,c=(e-n)/2;let u=r*r/(o*o)+c*c/(a*a);u>1&&(u=Math.sqrt(u),o*=u,a*=u);const f=o*o,k=a*a,b=f*k-f*c*c-k*r*r,y=f*c*c+k*r*r,m=(h===i?-1:1)*Math.sqrt(Math.abs(b/y));g=m*o*c/a+(t+s)/2,M=m*-a*r/o+(e+n)/2,p=Math.asin(parseFloat(((e-M)/a).toFixed(9))),d=Math.asin(parseFloat(((n-M)/a).toFixed(9))),t<g&&(p=Math.PI-p),s<g&&(d=Math.PI-d),p<0&&(p=2*Math.PI+p),d<0&&(d=2*Math.PI+d),i&&p>d&&(p-=2*Math.PI),!i&&d>p&&(d-=2*Math.PI);}let k=d-p;if(Math.abs(k)>120*Math.PI/180){const t=d,e=s,h=n;d=i&&d>p?p+120*Math.PI/180*1:p+120*Math.PI/180*-1,f=P(s=g+o*Math.cos(d),n=M+a*Math.sin(d),e,h,o,a,r,0,i,[d,t,g,M]);}k=d-p;const b=Math.cos(p),y=Math.sin(p),m=Math.cos(d),x=Math.sin(d),v=Math.tan(k/4),O=4/3*o*v,S=4/3*a*v,L=[t,e],T=[t+O*y,e-S*b],I=[s+O*x,n-S*m],A=[s,n];if(T[0]=2*L[0]-T[0],T[1]=2*L[1]-T[1],c)return [T,I,A].concat(f);{f=[T,I,A].concat(f);const t=[];for(let e=0;e<f.length;e+=3){const s=w(f[e][0],f[e][1],l),n=w(f[e+1][0],f[e+1][1],l),o=w(f[e+2][0],f[e+2][1],l);t.push([s[0],s[1],n[0],n[1],o[0],o[1]]);}return t}}const x={randOffset:function(t,e){return W(t,e)},randOffsetWithRange:function(t,e,s){return E(t,e,s)},ellipse:function(t,e,s,n,o){const a=T(s,n,o);return I(t,e,o,a).opset},doubleLineOps:function(t,e,s,n,o){return z(t,e,s,n,o,!0)}};function v(t,e,s,n,o){return {type:"path",ops:z(t,e,s,n,o)}}function O(t,e,s){const n=(t||[]).length;if(n>2){const o=[];for(let e=0;e<n-1;e++)o.push(...z(t[e][0],t[e][1],t[e+1][0],t[e+1][1],s));return e&&o.push(...z(t[n-1][0],t[n-1][1],t[0][0],t[0][1],s)),{type:"path",ops:o}}return 2===n?v(t[0][0],t[0][1],t[1][0],t[1][1],s):{type:"path",ops:[]}}function S(t,e,s,n,o){return function(t,e){return O(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function L(t,e){let s=$(t,1*(1+.2*e.roughness),e);if(!e.disableMultiStroke){const n=$(t,1.5*(1+.22*e.roughness),function(t){const e=Object.assign({},t);e.randomizer=void 0,t.seed&&(e.seed=t.seed+1);return e}(e));s=s.concat(n);}return {type:"path",ops:s}}function T(t,e,s){const n=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),o=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*n),a=2*Math.PI/o;let r=Math.abs(t/2),h=Math.abs(e/2);const i=1-s.curveFitting;return r+=W(r*i,s),h+=W(h*i,s),{increment:a,rx:r,ry:h}}function I(t,e,s,n){const[o,a]=q(n.increment,t,e,n.rx,n.ry,1,n.increment*E(.1,E(.4,1,s),s),s);let r=G(o,null,s);if(!s.disableMultiStroke){const[o]=q(n.increment,t,e,n.rx,n.ry,1.5,0,s),a=G(o,null,s);r=r.concat(a);}return {estimatedPoints:a,opset:{type:"path",ops:r}}}function A(t,e,s,n,o,a,r,h,i){const c=t,l=e;let u=Math.abs(s/2),f=Math.abs(n/2);u+=W(.01*u,i),f+=W(.01*f,i);let p=o,d=a;for(;p<0;)p+=2*Math.PI,d+=2*Math.PI;d-p>2*Math.PI&&(p=0,d=2*Math.PI);const g=2*Math.PI/i.curveStepCount,M=Math.min(g/2,(d-p)/2),k=F(M,c,l,u,f,p,d,1,i);if(!i.disableMultiStroke){const t=F(M,c,l,u,f,p,d,1.5,i);k.push(...t);}return r&&(h?k.push(...z(c,l,c+u*Math.cos(p),l+f*Math.sin(p),i),...z(c,l,c+u*Math.cos(d),l+f*Math.sin(d),i)):k.push({op:"lineTo",data:[c,l]},{op:"lineTo",data:[c+u*Math.cos(p),l+f*Math.sin(p)]})),{type:"path",ops:k}}function _(t,e){const s=[];if(t.length){const n=e.maxRandomnessOffset||0,o=t.length;if(o>2){s.push({op:"move",data:[t[0][0]+W(n,e),t[0][1]+W(n,e)]});for(let a=1;a<o;a++)s.push({op:"lineTo",data:[t[a][0]+W(n,e),t[a][1]+W(n,e)]});}}return {type:"fillPath",ops:s}}function C(t,e){return function(t,e){let s=t.fillStyle||"hachure";if(!d[s])switch(s){case"zigzag":d[s]||(d[s]=new c(e));break;case"cross-hatch":d[s]||(d[s]=new l(e));break;case"dots":d[s]||(d[s]=new u(e));break;case"dashed":d[s]||(d[s]=new f(e));break;case"zigzag-line":d[s]||(d[s]=new p(e));break;case"hachure":default:s="hachure",d[s]||(d[s]=new i(e));}return d[s]}(e,x).fillPolygon(t,e)}function D(t){return t.randomizer||(t.randomizer=new g(t.seed||0)),t.randomizer.next()}function E(t,e,s,n=1){return s.roughness*n*(D(s)*(e-t)+t)}function W(t,e,s=1){return E(-t,t,e,s)}function z(t,e,s,n,o,a=!1){const r=a?o.disableMultiStrokeFill:o.disableMultiStroke,h=R(t,e,s,n,o,!0,!1);if(r)return h;const i=R(t,e,s,n,o,!0,!0);return h.concat(i)}function R(t,e,s,n,o,a,r){const h=Math.pow(t-s,2)+Math.pow(e-n,2),i=Math.sqrt(h);let c=1;c=i<200?1:i>500?.4:-.0016668*i+1.233334;let l=o.maxRandomnessOffset||0;l*l*100>h&&(l=i/10);const u=l/2,f=.2+.2*D(o);let p=o.bowing*o.maxRandomnessOffset*(n-e)/200,d=o.bowing*o.maxRandomnessOffset*(t-s)/200;p=W(p,o,c),d=W(d,o,c);const g=[],M=()=>W(u,o,c),k=()=>W(l,o,c);return a&&(r?g.push({op:"move",data:[t+M(),e+M()]}):g.push({op:"move",data:[t+W(l,o,c),e+W(l,o,c)]})),r?g.push({op:"bcurveTo",data:[p+t+(s-t)*f+M(),d+e+(n-e)*f+M(),p+t+2*(s-t)*f+M(),d+e+2*(n-e)*f+M(),s+M(),n+M()]}):g.push({op:"bcurveTo",data:[p+t+(s-t)*f+k(),d+e+(n-e)*f+k(),p+t+2*(s-t)*f+k(),d+e+2*(n-e)*f+k(),s+k(),n+k()]}),g}function $(t,e,s){const n=[];n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]),n.push([t[0][0]+W(e,s),t[0][1]+W(e,s)]);for(let o=1;o<t.length;o++)n.push([t[o][0]+W(e,s),t[o][1]+W(e,s)]),o===t.length-1&&n.push([t[o][0]+W(e,s),t[o][1]+W(e,s)]);return G(n,null,s)}function G(t,e,s){const n=t.length,o=[];if(n>3){const a=[],r=1-s.curveTightness;o.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<n;e++){const s=t[e];a[0]=[s[0],s[1]],a[1]=[s[0]+(r*t[e+1][0]-r*t[e-1][0])/6,s[1]+(r*t[e+1][1]-r*t[e-1][1])/6],a[2]=[t[e+1][0]+(r*t[e][0]-r*t[e+2][0])/6,t[e+1][1]+(r*t[e][1]-r*t[e+2][1])/6],a[3]=[t[e+1][0],t[e+1][1]],o.push({op:"bcurveTo",data:[a[1][0],a[1][1],a[2][0],a[2][1],a[3][0],a[3][1]]});}if(e&&2===e.length){const t=s.maxRandomnessOffset;o.push({op:"lineTo",data:[e[0]+W(t,s),e[1]+W(t,s)]});}}else 3===n?(o.push({op:"move",data:[t[1][0],t[1][1]]}),o.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===n&&o.push(...z(t[0][0],t[0][1],t[1][0],t[1][1],s));return o}function q(t,e,s,n,o,a,r,h){const i=[],c=[],l=W(.5,h)-Math.PI/2;c.push([W(a,h)+e+.9*n*Math.cos(l-t),W(a,h)+s+.9*o*Math.sin(l-t)]);for(let r=l;r<2*Math.PI+l-.01;r+=t){const t=[W(a,h)+e+n*Math.cos(r),W(a,h)+s+o*Math.sin(r)];i.push(t),c.push(t);}return c.push([W(a,h)+e+n*Math.cos(l+2*Math.PI+.5*r),W(a,h)+s+o*Math.sin(l+2*Math.PI+.5*r)]),c.push([W(a,h)+e+.98*n*Math.cos(l+r),W(a,h)+s+.98*o*Math.sin(l+r)]),c.push([W(a,h)+e+.9*n*Math.cos(l+.5*r),W(a,h)+s+.9*o*Math.sin(l+.5*r)]),[c,i]}function F(t,e,s,n,o,a,r,h,i){const c=a+W(.1,i),l=[];l.push([W(h,i)+e+.9*n*Math.cos(c-t),W(h,i)+s+.9*o*Math.sin(c-t)]);for(let a=c;a<=r;a+=t)l.push([W(h,i)+e+n*Math.cos(a),W(h,i)+s+o*Math.sin(a)]);return l.push([e+n*Math.cos(r),s+o*Math.sin(r)]),l.push([e+n*Math.cos(r),s+o*Math.sin(r)]),G(l,null,i)}function j(t,e,s,n,o,a,r,h){const i=[],c=[h.maxRandomnessOffset||1,(h.maxRandomnessOffset||1)+.3];let l=[0,0];const u=h.disableMultiStroke?1:2;for(let f=0;f<u;f++)0===f?i.push({op:"move",data:[r[0],r[1]]}):i.push({op:"move",data:[r[0]+W(c[0],h),r[1]+W(c[0],h)]}),l=[o+W(c[f],h),a+W(c[f],h)],i.push({op:"bcurveTo",data:[t+W(c[f],h),e+W(c[f],h),s+W(c[f],h),n+W(c[f],h),l[0],l[1]]});return i}function N(t){return [...t]}function Z(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function Q(t,e,s){const n=Z(e,s);if(0===n)return Z(t,e);let o=((t[0]-e[0])*(s[0]-e[0])+(t[1]-e[1])*(s[1]-e[1]))/n;return o=Math.max(0,Math.min(1,o)),Z(t,H(e,s,o))}function H(t,e,s){return [t[0]+(e[0]-t[0])*s,t[1]+(e[1]-t[1])*s]}function V(t,e,s,n){const o=n||[];if(function(t,e){const s=t[e+0],n=t[e+1],o=t[e+2],a=t[e+3];let r=3*n[0]-2*s[0]-a[0];r*=r;let h=3*n[1]-2*s[1]-a[1];h*=h;let i=3*o[0]-2*a[0]-s[0];i*=i;let c=3*o[1]-2*a[1]-s[1];return c*=c,r<i&&(r=i),h<c&&(h=c),r+h}(t,e)<s){const s=t[e+0];if(o.length){(a=o[o.length-1],r=s,Math.sqrt(Z(a,r)))>1&&o.push(s);}else o.push(s);o.push(t[e+3]);}else {const n=.5,a=t[e+0],r=t[e+1],h=t[e+2],i=t[e+3],c=H(a,r,n),l=H(r,h,n),u=H(h,i,n),f=H(c,l,n),p=H(l,u,n),d=H(f,p,n);V([a,c,f,d],0,s,o),V([d,p,u,i],0,s,o);}var a,r;return o}function B(t,e){return X(t,0,t.length,e)}function X(t,e,s,n,o){const a=o||[],r=t[e],h=t[s-1];let i=0,c=1;for(let n=e+1;n<s-1;++n){const e=Q(t[n],r,h);e>i&&(i=e,c=n);}return Math.sqrt(i)>n?(X(t,e,c+1,n,a),X(t,c,s,n,a)):(a.length||a.push(r),a.push(h)),a}function J(t,e=.15,s){const n=[],o=(t.length-1)/3;for(let s=0;s<o;s++){V(t,3*s,e,n);}return s&&s>0?X(n,0,n.length,s):n}const K="none";class U{constructor(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1,disableMultiStroke:!1,disableMultiStrokeFill:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options));}static newSeed(){return Math.floor(Math.random()*2**31)}_o(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_d(t,e,s){return {shape:t,sets:e||[],options:s||this.defaultOptions}}line(t,e,s,n,o){const a=this._o(o);return this._d("line",[v(t,e,s,n,a)],a)}rectangle(t,e,s,n,o){const a=this._o(o),r=[],h=S(t,e,s,n,a);if(a.fill){const o=[[t,e],[t+s,e],[t+s,e+n],[t,e+n]];"solid"===a.fillStyle?r.push(_(o,a)):r.push(C(o,a));}return a.stroke!==K&&r.push(h),this._d("rectangle",r,a)}ellipse(t,e,s,n,o){const a=this._o(o),r=[],h=T(s,n,a),i=I(t,e,a,h);if(a.fill)if("solid"===a.fillStyle){const s=I(t,e,a,h).opset;s.type="fillPath",r.push(s);}else r.push(C(i.estimatedPoints,a));return a.stroke!==K&&r.push(i.opset),this._d("ellipse",r,a)}circle(t,e,s,n){const o=this.ellipse(t,e,s,s,n);return o.shape="circle",o}linearPath(t,e){const s=this._o(e);return this._d("linearPath",[O(t,!1,s)],s)}arc(t,e,s,n,o,a,r=!1,h){const i=this._o(h),c=[],l=A(t,e,s,n,o,a,r,!0,i);if(r&&i.fill)if("solid"===i.fillStyle){const r=A(t,e,s,n,o,a,!0,!1,i);r.type="fillPath",c.push(r);}else c.push(function(t,e,s,n,o,a,r){const h=t,i=e;let c=Math.abs(s/2),l=Math.abs(n/2);c+=W(.01*c,r),l+=W(.01*l,r);let u=o,f=a;for(;u<0;)u+=2*Math.PI,f+=2*Math.PI;f-u>2*Math.PI&&(u=0,f=2*Math.PI);const p=(f-u)/r.curveStepCount,d=[];for(let t=u;t<=f;t+=p)d.push([h+c*Math.cos(t),i+l*Math.sin(t)]);return d.push([h+c*Math.cos(f),i+l*Math.sin(f)]),d.push([h,i]),C(d,r)}(t,e,s,n,o,a,i));return i.stroke!==K&&c.push(l),this._d("arc",c,i)}curve(t,e){const s=this._o(e),n=[],o=L(t,s);if(s.fill&&s.fill!==K&&t.length>=3){const e=J(function(t,e=0){const s=t.length;if(s<3)throw new Error("A curve must have at least three points.");const n=[];if(3===s)n.push(N(t[0]),N(t[1]),N(t[2]),N(t[2]));else {const s=[];s.push(t[0],t[0]);for(let e=1;e<t.length;e++)s.push(t[e]),e===t.length-1&&s.push(t[e]);const o=[],a=1-e;n.push(N(s[0]));for(let t=1;t+2<s.length;t++){const e=s[t];o[0]=[e[0],e[1]],o[1]=[e[0]+(a*s[t+1][0]-a*s[t-1][0])/6,e[1]+(a*s[t+1][1]-a*s[t-1][1])/6],o[2]=[s[t+1][0]+(a*s[t][0]-a*s[t+2][0])/6,s[t+1][1]+(a*s[t][1]-a*s[t+2][1])/6],o[3]=[s[t+1][0],s[t+1][1]],n.push(o[1],o[2],o[3]);}}return n}(t),10,(1+s.roughness)/2);"solid"===s.fillStyle?n.push(_(e,s)):n.push(C(e,s));}return s.stroke!==K&&n.push(o),this._d("curve",n,s)}polygon(t,e){const s=this._o(e),n=[],o=O(t,!0,s);return s.fill&&("solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s))),s.stroke!==K&&n.push(o),this._d("polygon",n,s)}path(t,e){const s=this._o(e),n=[];if(!t)return this._d("path",n,s);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const o=s.fill&&"transparent"!==s.fill&&s.fill!==K,a=s.stroke!==K,r=!!(s.simplification&&s.simplification<1),h=function(t,e,s){const n=m(y(b(t))),o=[];let a=[],r=[0,0],h=[];const i=()=>{h.length>=4&&a.push(...J(h,e)),h=[];},c=()=>{i(),a.length&&(o.push(a),a=[]);};for(const{key:t,data:e}of n)switch(t){case"M":c(),r=[e[0],e[1]],a.push(r);break;case"L":i(),a.push([e[0],e[1]]);break;case"C":if(!h.length){const t=a.length?a[a.length-1]:r;h.push([t[0],t[1]]);}h.push([e[0],e[1]]),h.push([e[2],e[3]]),h.push([e[4],e[5]]);break;case"Z":i(),a.push([r[0],r[1]]);}if(c(),!s)return o;const l=[];for(const t of o){const e=B(t,s);e.length&&l.push(e);}return l}(t,1,r?4-4*s.simplification:(1+s.roughness)/2);if(o)if(s.combineNestedSvgPaths){const t=[];h.forEach(e=>t.push(...e)),"solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s));}else h.forEach(t=>{"solid"===s.fillStyle?n.push(_(t,s)):n.push(C(t,s));});return a&&(r?h.forEach(t=>{n.push(O(t,!1,s));}):n.push(function(t,e){const s=m(y(b(t))),n=[];let o=[0,0],a=[0,0];for(const{key:t,data:r}of s)switch(t){case"M":{const t=1*(e.maxRandomnessOffset||0);n.push({op:"move",data:r.map(s=>s+W(t,e))}),a=[r[0],r[1]],o=[r[0],r[1]];break}case"L":n.push(...z(a[0],a[1],r[0],r[1],e)),a=[r[0],r[1]];break;case"C":{const[t,s,o,h,i,c]=r;n.push(...j(t,s,o,h,i,c,a,e)),a=[i,c];break}case"Z":n.push(...z(a[0],a[1],o[0],o[1],e)),a=[o[0],o[1]];}return {type:"path",ops:n}}(t,s))),this._d("path",n,s)}opsToPath(t){let e="";for(const s of t.ops){const t=s.data;switch(s.op){case"move":e+=`M${t[0]} ${t[1]} `;break;case"bcurveTo":e+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case"lineTo":e+=`L${t[0]} ${t[1]} `;}}return e.trim()}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,n=[];for(const t of e){let e=null;switch(t.type){case"path":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:K};break;case"fillPath":e={d:this.opsToPath(t),stroke:K,strokeWidth:0,fill:s.fill||K};break;case"fillSketch":e=this.fillSketch(t,s);}e&&n.push(e);}return n}fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||K,strokeWidth:s,fill:K}}}class Y{constructor(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new U(e);}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.ctx;for(const o of e)switch(o.type){case"path":n.save(),n.strokeStyle="none"===s.stroke?"transparent":s.stroke,n.lineWidth=s.strokeWidth,s.strokeLineDash&&n.setLineDash(s.strokeLineDash),s.strokeLineDashOffset&&(n.lineDashOffset=s.strokeLineDashOffset),this._drawToContext(n,o),n.restore();break;case"fillPath":n.save(),n.fillStyle=s.fill||"";const e="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(n,o,e),n.restore();break;case"fillSketch":this.fillSketch(n,o,s);}}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2),t.save(),s.fillLineDash&&t.setLineDash(s.fillLineDash),s.fillLineDashOffset&&(t.lineDashOffset=s.fillLineDashOffset),t.strokeStyle=s.fill||"",t.lineWidth=n,this._drawToContext(t,e),t.restore();}_drawToContext(t,e,s="nonzero"){t.beginPath();for(const s of e.ops){const e=s.data;switch(s.op){case"move":t.moveTo(e[0],e[1]);break;case"bcurveTo":t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5]);break;case"lineTo":t.lineTo(e[0],e[1]);}}"fillPath"===e.type?t.fill(s):t.stroke();}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a),a}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a),a}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a),a}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o),o}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s),s}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s),s}arc(t,e,s,n,o,a,r=!1,h){const i=this.gen.arc(t,e,s,n,o,a,r,h);return this.draw(i),i}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s),s}path(t,e){const s=this.gen.path(t,e);return this.draw(s),s}}const tt="http://www.w3.org/2000/svg";class et{constructor(t,e){this.svg=t,this.gen=new U(e);}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.svg.ownerDocument||window.document,o=n.createElementNS(tt,"g");for(const a of e){let e=null;switch(a.type){case"path":e=n.createElementNS(tt,"path"),e.setAttribute("d",this.opsToPath(a)),e.setAttribute("stroke",s.stroke),e.setAttribute("stroke-width",s.strokeWidth+""),e.setAttribute("fill","none"),s.strokeLineDash&&e.setAttribute("stroke-dasharray",s.strokeLineDash.join(" ").trim()),s.strokeLineDashOffset&&e.setAttribute("stroke-dashoffset",""+s.strokeLineDashOffset);break;case"fillPath":e=n.createElementNS(tt,"path"),e.setAttribute("d",this.opsToPath(a)),e.setAttribute("stroke","none"),e.setAttribute("stroke-width","0"),e.setAttribute("fill",s.fill||""),"curve"!==t.shape&&"polygon"!==t.shape||e.setAttribute("fill-rule","evenodd");break;case"fillSketch":e=this.fillSketch(n,a,s);}e&&o.appendChild(e);}return o}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2);const o=t.createElementNS(tt,"path");return o.setAttribute("d",this.opsToPath(e)),o.setAttribute("stroke",s.fill||""),o.setAttribute("stroke-width",n+""),o.setAttribute("fill","none"),s.fillLineDash&&o.setAttribute("stroke-dasharray",s.fillLineDash.join(" ").trim()),s.fillLineDashOffset&&o.setAttribute("stroke-dashoffset",""+s.fillLineDashOffset),o}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}opsToPath(t){return this.gen.opsToPath(t)}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a)}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a)}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a)}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o)}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s)}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s)}arc(t,e,s,n,o,a,r=!1,h){const i=this.gen.arc(t,e,s,n,o,a,r,h);return this.draw(i)}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s)}path(t,e){const s=this.gen.path(t,e);return this.draw(s)}}var st={canvas:(t,e)=>new Y(t,e),svg:(t,e)=>new et(t,e),generator:t=>new U(t),newSeed:()=>U.newSeed()};

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var lodash_clonedeep = createCommonjsModule(function (module, exports) {
  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }

  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
  function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    return this.__data__['delete'](key);
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = (isArray(value) || isArguments(value))
      ? baseTimes(value.length, String)
      : [];

    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      object[key] = value;
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {boolean} [isFull] Specify a clone including symbols.
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    return objectToString.call(value);
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `map`.
   *
   * @private
   * @param {Object} map The map to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned map.
   */
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of `set`.
   *
   * @private
   * @param {Object} set The set to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned set.
   */
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  }

  /**
   * Copies own symbol properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11,
  // for data views in Edge < 14, and promises in Node.js.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return cloneSet(object, isDeep, cloneFunc);

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
      (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  module.exports = cloneDeep;
  });

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal || freeSelf || Function('return this')();

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$2 = function() {
    return root$1.Date.now();
  };

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;

      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now$2();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$2());
    }

    function debounced() {
      var time = now$2(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag);
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var lodash_debounce = debounce;

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  /*!
   * GSAP 3.4.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  },
      _defaults = {
    duration: .5,
    overwrite: false,
    delay: 0
  },
      _bigNum = 1e8,
      _tinyNum = 1 / _bigNum,
      _2PI = Math.PI * 2,
      _HALF_PI = _2PI / 4,
      _gsID = 0,
      _sqrt = Math.sqrt,
      _cos = Math.cos,
      _sin = Math.sin,
      _isString = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
      _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
      _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
      _isObject = function _isObject(value) {
    return typeof value === "object";
  },
      _isNotFalse = function _isNotFalse(value) {
    return value !== false;
  },
      _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
      _isFuncOrString = function _isFuncOrString(value) {
    return _isFunction(value) || _isString(value);
  },
      _isArray = Array.isArray,
      _strictNumExp = /(?:-?\.?\d|\.)+/gi,
      //only numbers (including negatives and decimals) but NOT relative values.
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
      //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      _complexStringNumExp = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
      //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
  _parenthesesExp = /\(([^()]+)\)/i,
      //finds the string between parentheses.
  _relExp = /[+-]=-?[\.\d]+/,
      _delimitedValueExp = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
      _globalTimeline,
      _win,
      _coreInitted,
      _doc,
      _globals = {},
      _installScope = {},
      _coreReady,
      _install = function _install(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  },
      _missingPlugin = function _missingPlugin(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  },
      _warn = function _warn(message, suppress) {
    return !suppress && console.warn(message);
  },
      _addGlobal = function _addGlobal(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  },
      _emptyFunc = function _emptyFunc() {
    return 0;
  },
      _reservedProps = {},
      _lazyTweens = [],
      _lazyLookup = {},
      _lastRenderedFrame,
      _plugins = {},
      _effects = {},
      _nextGCFrame = 30,
      _harnessPlugins = [],
      _callbackNames = "",
      _harness = function _harness(targets) {
    var target = targets[0],
        harnessPlugin,
        i;

    if (!_isObject(target) && !_isFunction(target)) {
      targets = [targets];
    }

    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i = _harnessPlugins.length;

      while (i-- && !_harnessPlugins[i].targetTest(target)) {}

      harnessPlugin = _harnessPlugins[i];
    }

    i = targets.length;

    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }

    return targets;
  },
      _getCache = function _getCache(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  },
      _getProperty = function _getProperty(target, property) {
    var currentValue = target[property];
    return _isFunction(currentValue) ? target[property]() : _isUndefined(currentValue) && target.getAttribute(property) || currentValue;
  },
      _forEachName = function _forEachName(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  },
      //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
  _round = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
      _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
    var l = toFind.length,
        i = 0;

    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

    return i < l;
  },
      _parseVars = function _parseVars(params, type, parent) {
    //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()
    var isLegacy = _isNumber(params[1]),
        varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
        vars = params[varsIndex],
        irVars;

    if (isLegacy) {
      vars.duration = params[1];
    }

    vars.parent = parent;

    if (type) {
      irVars = vars;

      while (parent && !("immediateRender" in irVars)) {
        // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }

      vars.immediateRender = _isNotFalse(irVars.immediateRender);

      if (type < 2) {
        vars.runBackwards = 1;
      } else {
        vars.startAt = params[varsIndex - 1]; // "from" vars
      }
    }

    return vars;
  },
      _lazyRender = function _lazyRender() {
    var l = _lazyTweens.length,
        a = _lazyTweens.slice(0),
        i,
        tween;

    _lazyLookup = {};
    _lazyTweens.length = 0;

    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  },
      _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
    _lazyTweens.length && _lazyRender();
    animation.render(time, suppressEvents, force);
    _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
  },
      _numericIfPossible = function _numericIfPossible(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : value;
  },
      _passThrough = function _passThrough(p) {
    return p;
  },
      _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }

    return obj;
  },
      _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
    for (var p in defaults) {
      if (!(p in obj) && p !== "duration" && p !== "ease") {
        obj[p] = defaults[p];
      }
    }
  },
      _merge = function _merge(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }

    return base;
  },
      _mergeDeep = function _mergeDeep(base, toMerge) {
    for (var p in toMerge) {
      base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p];
    }

    return base;
  },
      _copyExcluding = function _copyExcluding(obj, excluding) {
    var copy = {},
        p;

    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }

    return copy;
  },
      _inheritDefaults = function _inheritDefaults(vars) {
    var parent = vars.parent || _globalTimeline,
        func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }

    return vars;
  },
      _arraysMatch = function _arraysMatch(a1, a2) {
    var i = a1.length,
        match = i === a2.length;

    while (match && i-- && a1[i] === a2[i]) {}

    return i < 0;
  },
      _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = parent[lastProp],
        t;

    if (sortBy) {
      t = child[sortBy];

      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }

    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }

    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  },
      _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = child._prev,
        next = child._next;

    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }

    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }

    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
  },
      _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
    if (child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren)) {
      child.parent.remove(child);
    }

    child._act = 0;
  },
      _uncache = function _uncache(animation) {
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }

    return animation;
  },
      _recacheAncestors = function _recacheAncestors(animation) {
    var parent = animation.parent;

    while (parent && parent.parent) {
      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }

    return animation;
  },
      _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
  },
      _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  },
      // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
  _animationCycle = function _animationCycle(tTime, cycleDuration) {
    return (tTime /= cycleDuration) && ~~tTime === tTime ? ~~tTime - 1 : ~~tTime;
  },
      _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  },
      _setEnd = function _setEnd(animation) {
    return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  },
      _alignPlayhead = function _alignPlayhead(animation, totalTime) {
    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
    var parent = animation._dp;

    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _round(animation._dp._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

      _setEnd(animation);

      parent._dirty || _uncache(parent); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
    }

    return animation;
  },

  /*
  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
  	let cycleDuration = duration + repeatDelay,
  		time = _round(clampedTotalTime % cycleDuration);
  	if (time > duration) {
  		time = duration;
  	}
  	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
  },
  */
  _postAddChecks = function _postAddChecks(timeline, child) {
    var t;

    if (child._time || child._initted && !child._dur) {
      //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
      t = _parentToChildTotalTime(timeline.rawTime(), child);

      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


    if (_uncache(timeline)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
      //in case any of the ancestors had completed but should now be enabled...
      if (timeline._dur < timeline.duration()) {
        t = timeline;

        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

          t = t._dp;
        }
      }

      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
    }
  },
      _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _round(position + child._delay);
    child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

    timeline._recent = child;
    skipChecks || _postAddChecks(timeline, child);
    return timeline;
  },
      _scrollTrigger = function _scrollTrigger(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  },
      _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
    _initTween(tween, totalTime);

    if (!tween._initted) {
      return 1;
    }

    if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);

      tween._lazy = [totalTime, suppressEvents];
      return 1;
    }
  },
      _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio,
        ratio = totalTime < 0 || !totalTime && prevRatio && !tween._start && tween._zTime > _tinyNum && !tween._dp._lock || tween._ts < 0 || tween._dp._ts < 0 ? 0 : 1,
        // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0. Also, if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0.
    repeatDelay = tween._rDelay,
        tTime = 0,
        pt,
        iteration,
        prevIteration;

    if (repeatDelay && tween._repeat) {
      // in case there's a zero-duration tween that has a repeat with a repeatDelay
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      prevIteration = _animationCycle(tween._tTime, repeatDelay);

      if (iteration !== prevIteration) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }

    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      suppressEvents || _callback(tween, "onStart");
      pt = tween._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);

        if (!suppressEvents) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  },
      _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
    var child;

    if (time > prevTime) {
      child = animation._first;

      while (child && child._start <= time) {
        if (!child._dur && child.data === "isPause" && child._start > prevTime) {
          return child;
        }

        child = child._next;
      }
    } else {
      child = animation._last;

      while (child && child._start >= time) {
        if (!child._dur && child.data === "isPause" && child._start < prevTime) {
          return child;
        }

        child = child._prev;
      }
    }
  },
      _setDuration = function _setDuration(animation, duration, skipUncache) {
    var repeat = animation._repeat,
        dur = _round(duration) || 0;
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);

    if (animation._time > dur) {
      animation._time = dur;
      animation._tTime = Math.min(animation._tTime, animation._tDur);
    }

    !skipUncache && _uncache(animation.parent);
    animation.parent && _setEnd(animation);
    return animation;
  },
      _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  },
      _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc
  },
      _parsePosition = function _parsePosition(animation, position) {
    var labels = animation.labels,
        recent = animation._recent || _zeroPosition,
        clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
        //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
    i,
        offset;

    if (_isString(position) && (isNaN(position) || position in labels)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      i = position.charAt(0);

      if (i === "<" || i === ">") {
        return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);
      }

      i = position.indexOf("=");

      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }

      offset = +(position.charAt(i - 1) + position.substr(i + 1));
      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;
    }

    return position == null ? clippedDuration : +position;
  },
      _conditionalReturn = function _conditionalReturn(value, func) {
    return value || value === 0 ? func(value) : func;
  },
      _clamp = function _clamp(min, max, value) {
    return value < min ? min : value > max ? max : value;
  },
      getUnit = function getUnit(value) {
    return (value + "").substr((parseFloat(value) + "").length);
  },
      clamp = function clamp(min, max, value) {
    return _conditionalReturn(value, function (v) {
      return _clamp(min, max, v);
    });
  },
      _slice = [].slice,
      _isArrayLike = function _isArrayLike(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  },
      _flatten = function _flatten(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }

    return ar.forEach(function (value) {
      var _accumulator;

      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  },
      //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  toArray = function toArray(value, leaveStrings) {
    return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  },
      shuffle = function shuffle(a) {
    return a.sort(function () {
      return .5 - Math.random();
    });
  },
      // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
  //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
  distribute = function distribute(v) {
    if (_isFunction(v)) {
      return v;
    }

    var vars = _isObject(v) ? v : {
      each: v
    },
        //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
    ease = _parseEase(vars.ease),
        from = vars.from || 0,
        base = parseFloat(vars.base) || 0,
        cache = {},
        isDecimal = from > 0 && from < 1,
        ratios = isNaN(from) || isDecimal,
        axis = vars.axis,
        ratioX = from,
        ratioY = from;

    if (_isString(from)) {
      ratioX = ratioY = {
        center: .5,
        edges: .5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }

    return function (i, target, a) {
      var l = (a || vars).length,
          distances = cache[l],
          originX,
          originY,
          x,
          y,
          d,
          j,
          max,
          min,
          wrapAt;

      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

        if (!wrapAt) {
          max = -_bigNum;

          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

          wrapAt--;
        }

        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
        originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;

        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }

        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0; //unit

        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }

      l = (distances[i] - distances.min) / distances.max || 0;
      return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
    };
  },
      _roundModifier = function _roundModifier(v) {
    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
    var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

    return function (raw) {
      return Math.floor(Math.round(parseFloat(raw) / v) * v * p) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  },
      snap = function snap(snapTo, value) {
    var isArray = _isArray(snapTo),
        radius,
        is2D;

    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;

      if (snapTo.values) {
        snapTo = toArray(snapTo.values);

        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }

    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function (raw) {
      var x = parseFloat(is2D ? raw.x : raw),
          y = parseFloat(is2D ? raw.y : 0),
          min = _bigNum,
          closest = 0,
          i = snapTo.length,
          dx,
          dy;

      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }

        if (dx < min) {
          min = dx;
          closest = i;
        }
      }

      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  },
      random = function random(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min + Math.random() * (max - min)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  },
      pipe = function pipe() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }

    return function (value) {
      return functions.reduce(function (v, f) {
        return f(v);
      }, value);
    };
  },
      unitize = function unitize(func, unit) {
    return function (value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  },
      normalize = function normalize(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  },
      _wrapArray = function _wrapArray(a, wrapper, value) {
    return _conditionalReturn(value, function (index) {
      return a[~~wrapper(index)];
    });
  },
      wrap = function wrap(min, max, value) {
    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
      return (range + (value - min) % range) % range + min;
    });
  },
      wrapYoyo = function wrapYoyo(min, max, value) {
    var range = max - min,
        total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
      value = (total + (value - min) % total) % total || 0;
      return min + (value > range ? total - value : value);
    });
  },
      _replaceRandom = function _replaceRandom(value) {
    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
    var prev = 0,
        s = "",
        i,
        nums,
        end,
        isArray;

    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }

    return s + value.substr(prev, value.length - prev);
  },
      mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin,
        outRange = outMax - outMin;
    return _conditionalReturn(value, function (value) {
      return outMin + ((value - inMin) / inRange * outRange || 0);
    });
  },
      interpolate$1 = function interpolate(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function (p) {
      return (1 - p) * start + p * end;
    };

    if (!func) {
      var isString = _isString(start),
          master = {},
          p,
          i,
          interpolators,
          l,
          il;

      progress === true && (mutate = 1) && (progress = null);

      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;

        for (i = 1; i < l; i++) {
          interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
        }

        l--;

        func = function func(p) {
          p *= l;
          var i = Math.min(il, ~~p);
          return interpolators[i](p - i);
        };

        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }

      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }

        func = function func(p) {
          return _renderPropTweens(p, master) || (isString ? start.p : start);
        };
      }
    }

    return _conditionalReturn(progress, func);
  },
      _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
    //used for nextLabel() and previousLabel()
    var labels = timeline.labels,
        min = _bigNum,
        p,
        distance,
        label;

    for (p in labels) {
      distance = labels[p] - fromTime;

      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }

    return label;
  },
      _callback = function _callback(animation, type, executeLazyFirst) {
    var v = animation.vars,
        callback = v[type],
        params,
        scope;

    if (!callback) {
      return;
    }

    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

    return params ? callback.apply(scope, params) : callback.call(scope);
  },
      _interrupt = function _interrupt(animation) {
    _removeFromParent(animation);

    if (animation.progress() < 1) {
      _callback(animation, "onInterrupt");
    }

    return animation;
  },
      _quickTween,
      _createPlugin = function _createPlugin(config) {
    config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

    var name = config.name,
        isFunc = _isFunction(config),
        Plugin = name && !isFunc && config.init ? function () {
      this._props = [];
    } : config,
        //in case someone passes in an object that's not a plugin, like CustomEase
    instanceDefaults = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    },
        statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };

    _wake();

    if (config !== Plugin) {
      if (_plugins[name]) {
        return;
      }

      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


      _plugins[Plugin.prop = name] = Plugin;

      if (config.targetTest) {
        _harnessPlugins.push(Plugin);

        _reservedProps[name] = 1;
      }

      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
    }

    _addGlobal(name, Plugin);

    if (config.register) {
      config.register(gsap, Plugin, PropTween);
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * COLORS
   * --------------------------------------------------------------------------------------
   */
  _255 = 255,
      _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  },
      _hue = function _hue(h, m1, m2) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
  },
      splitColor = function splitColor(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
        r,
        g,
        b,
        h,
        s,
        l,
        max,
        min,
        d,
        wasHSL;

    if (!a) {
      if (v.substr(-1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }

      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length === 4) {
          //for shorthand like #9F0
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b;
        }

        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);

        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= .5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;

          if (a.length > 3) {
            a[3] *= 1; //cast as number
          }

          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }

      a = a.map(Number);
    }

    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }

      a[0] = ~~(h + .5);
      a[1] = ~~(s * 100 + .5);
      a[2] = ~~(l * 100 + .5);
    }

    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  },
      _colorOrderData = function _colorOrderData(v) {
    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
    var values = [],
        c = [],
        i = -1;
    v.split(_colorExp).forEach(function (v) {
      var a = v.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  },
      _formatColors = function _formatColors(s, toHSL, orderMatchData) {
    var result = "",
        colors = (s + result).match(_colorExp),
        type = toHSL ? "hsla(" : "rgba(",
        i = 0,
        c,
        shell,
        d,
        l;

    if (!colors) {
      return s;
    }

    colors = colors.map(function (color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });

    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;

      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;

        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }

    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }

    return result + shell[l];
  },
      _colorExp = function () {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
        //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
    p;

    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }

    return new RegExp(s + ")", "gi");
  }(),
      _hslExp = /hsl[a]?\(/,
      _colorStringFilter = function _colorStringFilter(a) {
    var combined = a.join(" "),
        toHSL;
    _colorExp.lastIndex = 0;

    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

      return true;
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * TICKER
   * --------------------------------------------------------------------------------------
   */
  _tickerActive,
      _ticker = function () {
    var _getTime = Date.now,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _startTime = _getTime(),
        _lastUpdate = _startTime,
        _gap = 1 / 240,
        _nextTime = _gap,
        _listeners = [],
        _id,
        _req,
        _raf,
        _self,
        _tick = function _tick(v) {
      var elapsed = _getTime() - _lastUpdate,
          manual = v === true,
          overlap,
          dispatch;

      if (elapsed > _lagThreshold) {
        _startTime += elapsed - _adjustedLag;
      }

      _lastUpdate += elapsed;
      _self.time = (_lastUpdate - _startTime) / 1000;
      overlap = _self.time - _nextTime;

      if (overlap > 0 || manual) {
        _self.frame++;
        _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
        dispatch = 1;
      }

      manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

      dispatch && _listeners.forEach(function (l) {
        return l(_self.time, elapsed, _self.frame, v);
      });
    };

    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

            _raf = _win.requestAnimationFrame;
          }

          _id && _self.sleep();

          _req = _raf || function (f) {
            return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
          };

          _tickerActive = 1;

          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
      },
      fps: function fps(_fps) {
        _gap = 1 / (_fps || 240);
        _nextTime = _self.time + _gap;
      },
      add: function add(callback) {
        _listeners.indexOf(callback) < 0 && _listeners.push(callback);

        _wake();
      },
      remove: function remove(callback) {
        var i;
        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1);
      },
      _listeners: _listeners
    };
    return _self;
  }(),
      _wake = function _wake() {
    return !_tickerActive && _ticker.wake();
  },
      //also ensures the core classes are initialized.

  /*
  * -------------------------------------------------
  * EASING
  * -------------------------------------------------
  */
  _easeMap = {},
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
      _quotesExp = /["']/g,
      _parseObjectInString = function _parseObjectInString(value) {
    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
    var obj = {},
        split = value.substr(1, value.length - 3).split(":"),
        key = split[0],
        i = 1,
        l = split.length,
        index,
        val,
        parsedVal;

    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }

    return obj;
  },
      _configEaseFromString = function _configEaseFromString(name) {
    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
    var split = (name + "").split("("),
        ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _parenthesesExp.exec(name)[1].split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  },
      _invertEase = function _invertEase(ease) {
    return function (p) {
      return 1 - ease(1 - p);
    };
  },
      // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
  _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
    var child = timeline._first,
        ease;

    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }

      child = child._next;
    }
  },
      _parseEase = function _parseEase(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  },
      _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut(p) {
        return 1 - easeIn(1 - p);
      };
    }

    if (easeInOut === void 0) {
      easeInOut = function easeInOut(p) {
        return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }

    var ease = {
      easeIn: easeIn,
      easeOut: easeOut,
      easeInOut: easeInOut
    },
        lowercaseName;

    _forEachName(names, function (name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });

    return ease;
  },
      _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
    return function (p) {
      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
    };
  },
      _configElastic = function _configElastic(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1,
        //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
        p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
        easeOut = function easeOut(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    p2 = _2PI / p2; //precalculate to optimize

    ease.config = function (amplitude, period) {
      return _configElastic(type, amplitude, period);
    };

    return ease;
  },
      _configBack = function _configBack(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }

    var easeOut = function easeOut(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    ease.config = function (overshoot) {
      return _configBack(type, overshoot);
    };

    return ease;
  }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEase = ratio => {
  // 	let y = 0.5 + ratio / 2;
  // 	return p => (2 * (1 - p) * p * y + p * p);
  // },
  // a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEaseStrong = ratio => {
  // 	ratio = .5 + ratio / 2;
  // 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
  // 		b = ratio - o,
  // 		c = ratio + o;
  // 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
  // };


  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
    var power = i < 5 ? i + 1 : i;

    _insertEase(name + ",Power" + (power - 1), i ? function (p) {
      return Math.pow(p, power);
    } : function (p) {
      return p;
    }, function (p) {
      return 1 - Math.pow(1 - p, power);
    }, function (p) {
      return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });

  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

  (function (n, c) {
    var n1 = 1 / c,
        n2 = 2 * n1,
        n3 = 2.5 * n1,
        easeOut = function easeOut(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
    };

    _insertEase("Bounce", function (p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);

  _insertEase("Expo", function (p) {
    return p ? Math.pow(2, 10 * (p - 1)) : 0;
  });

  _insertEase("Circ", function (p) {
    return -(_sqrt(1 - p * p) - 1);
  });

  _insertEase("Sine", function (p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });

  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }

      var p1 = 1 / steps,
          p2 = steps + (immediateStart ? 0 : 1),
          p3 = immediateStart ? 1 : 0,
          max = 1 - _tinyNum;
      return function (p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];

  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  /*
   * --------------------------------------------------------------------------------------
   * CACHE
   * --------------------------------------------------------------------------------------
   */


  var GSCache = function GSCache(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  /*
   * --------------------------------------------------------------------------------------
   * ANIMATION
   * --------------------------------------------------------------------------------------
   */

  var Animation = /*#__PURE__*/function () {
    function Animation(vars, time) {
      var parent = vars.parent || _globalTimeline;
      this.vars = vars;
      this._delay = +vars.delay || 0;

      if (this._repeat = vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }

      this._ts = 1;

      _setDuration(this, +vars.duration, 1);

      this.data = vars.data;
      _tickerActive || _ticker.wake();
      parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);
      vars.reversed && this.reverse();
      vars.paused && this.paused(true);
    }

    var _proto = Animation.prototype;

    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }

      return this._delay;
    };

    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };

    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }

      this._dirty = 0;
      var t = this._time / this._dur || 0;

      _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));

      return this._tTime ? _alignPlayhead(this, t * value + _elapsedCycleDuration(this)) : this; // in case the animation hasn't even started yet and it has a delay. Aligning the playhead in that case would make it appear to lose the delay.
    };

    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();

      if (!arguments.length) {
        return this._tTime;
      }

      var parent = this._dp;

      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime); //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.


        while (parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }

          parent = parent.parent;
        }

        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }

      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted) {
        this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause

        _lazySafeRender(this, _totalTime, suppressEvents);
      }

      return this;
    };

    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
    };

    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
    };

    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
    };

    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;

      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    } // potential future addition:
    // isPlayingBackwards() {
    // 	let animation = this,
    // 		orientation = 1; // 1 = forward, -1 = backward
    // 	while (animation) {
    // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
    // 		animation = animation.parent;
    // 	}
    // 	return orientation < 0;
    // }
    ;

    _proto.timeScale = function timeScale(value) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
      }

      if (this._rts === value) {
        return this;
      }

      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
      // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

      return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
    };

    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }

      if (this._ps !== value) {
        this._ps = value;

        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

          this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
        } else {
          _wake();

          this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
        }
      }

      return this;
    };

    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }

      return this._start;
    };

    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
    };

    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp; // _dp = detatched parent

      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };

    _proto.globalTime = function globalTime(rawTime) {
      var animation = this,
          time = arguments.length ? rawTime : animation.rawTime();

      while (animation) {
        time = animation._start + time / (animation._ts || 1);
        animation = animation._dp;
      }

      return time;
    };

    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value;
        return _onUpdateTotalDuration(this);
      }

      return this._repeat;
    };

    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        this._rDelay = value;
        return _onUpdateTotalDuration(this);
      }

      return this._rDelay;
    };

    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }

      return this._yoyo;
    };

    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };

    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };

    _proto.play = function play(from, suppressEvents) {
      if (from != null) {
        this.seek(from, suppressEvents);
      }

      return this.reversed(false).paused(false);
    };

    _proto.reverse = function reverse(from, suppressEvents) {
      if (from != null) {
        this.seek(from || this.totalDuration(), suppressEvents);
      }

      return this.reversed(true).paused(false);
    };

    _proto.pause = function pause(atTime, suppressEvents) {
      if (atTime != null) {
        this.seek(atTime, suppressEvents);
      }

      return this.paused(true);
    };

    _proto.resume = function resume() {
      return this.paused(false);
    };

    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        if (!!value !== this.reversed()) {
          this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.
        }

        return this;
      }

      return this._rts < 0;
    };

    _proto.invalidate = function invalidate() {
      this._initted = 0;
      this._zTime = -_tinyNum;
      return this;
    };

    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp,
          start = this._start,
          rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };

    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;

      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;

          if (params) {
            vars[type + "Params"] = params;
          }

          if (type === "onUpdate") {
            this._onUpdate = callback;
          }
        }

        return this;
      }

      return vars[type];
    };

    _proto.then = function then(onFulfilled) {
      var self = this;
      return new Promise(function (resolve) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
            _resolve = function _resolve() {
          var _then = self.then;
          self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

          _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
          resolve(f);
          self.then = _then;
        };

        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    };

    _proto.kill = function kill() {
      _interrupt(this);
    };

    return Animation;
  }();

  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  /*
   * -------------------------------------------------
   * TIMELINE
   * -------------------------------------------------
   */


  var Timeline = /*#__PURE__*/function (_Animation) {
    _inheritsLoose(Timeline, _Animation);

    function Timeline(vars, time) {
      var _this;

      if (vars === void 0) {
        vars = {};
      }

      _this = _Animation.call(this, vars, time) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _this.parent && _postAddChecks(_this.parent, _assertThisInitialized(_this));
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }

    var _proto2 = Timeline.prototype;

    _proto2.to = function to(targets, vars, position) {
      new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
      return this;
    };

    _proto2.from = function from(targets, vars, position) {
      new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
      return this;
    };

    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));
      return this;
    };

    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };

    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));
    } //ONLY for backward compatibility! Maybe delete?
    ;

    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };

    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._dirty ? this.totalDuration() : this._tDur,
          dur = this._dur,
          tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
          crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
          time,
          child,
          next,
          iteration,
          cycleDuration,
          prevPaused,
          pauseTween,
          timeScale,
          prevStart,
          prevIteration,
          yoyo,
          isYoyo;

      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }

        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;

        if (crossingStart) {
          dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (time > dur || tDur === tTime) {
            time = dur;
          }

          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          /*
          make sure children at the end/beginning of the timeline are rendered properly. If, for example,
          a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
          would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
          could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
          we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
          ensure that zero-duration tweens at the very beginning or end of the Timeline work.
          */


          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1,
                doesWrap = rewinding === (yoyo && iteration & 1);

            if (iteration < prevIteration) {
              rewinding = !rewinding;
            }

            prevTime = rewinding ? 0 : dur;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;

            if (!suppressEvents && this.parent) {
              _callback(this, "onRepeat");
            }

            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

            if (prevTime !== this._time || prevPaused !== !this._ts) {
              return this;
            }

            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur + 0.0001 : -0.0001;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }

            this._lock = 0;

            if (!this._ts && !prevPaused) {
              return this;
            } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


            _propagateYoyoEase(this, isYoyo);
          }
        }

        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));

          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }

        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
        }

        if (!prevTime && time && !suppressEvents) {
          _callback(this, "onStart");
        }

        if (time >= prevTime && totalTime >= 0) {
          child = this._first;

          while (child) {
            next = child._next;

            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

          while (child) {
            next = child._prev;

            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        }

        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

          if (this._ts) {
            //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
            this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

            _setEnd(this);

            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto2.add = function add(child, position) {
      var _this2 = this;

      if (!_isNumber(position)) {
        position = _parsePosition(this, position);
      }

      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function (obj) {
            return _this2.add(obj, position);
          });
          return _uncache(this);
        }

        if (_isString(child)) {
          return this.addLabel(child, position);
        }

        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }

      return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
    };

    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }

      if (tweens === void 0) {
        tweens = true;
      }

      if (timelines === void 0) {
        timelines = true;
      }

      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }

      var a = [],
          child = this._first;

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }

        child = child._next;
      }

      return a;
    };

    _proto2.getById = function getById(id) {
      var animations = this.getChildren(1, 1, 1),
          i = animations.length;

      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };

    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }

      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }

      _removeLinkedListItem(this, child);

      if (child === this._recent) {
        this._recent = this._last;
      }

      return _uncache(this);
    };

    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }

      this._forcing = 1;

      if (!this._dp && this._ts) {
        //special case for the global timeline (or any other that has no parent or detached parent).
        this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }

      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

      this._forcing = 0;
      return this;
    };

    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };

    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };

    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition(this, position));
    };

    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);

      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }

        child = child._next;
      }
    };

    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive),
          i = tweens.length;

      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }

      return this;
    };

    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
      var a = [],
          parsedTargets = toArray(targets),
          child = this._first,
          isGlobalTime = _isNumber(onlyActive),
          // a number is interpreted as a global time. If the animation spans
      children;

      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }

        child = child._next;
      }

      return a;
    };

    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};

      var tl = this,
          endTime = _parsePosition(tl, position),
          _vars = vars,
          startAt = _vars.startAt,
          _onStart = _vars.onStart,
          onStartParams = _vars.onStartParams,
          tween = Tween.to(tl, _setDefaults(vars, {
        ease: "none",
        lazy: false,
        time: endTime,
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          var duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration).render(tween._time, true, true);
          _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
        }
      }));

      return tween;
    };

    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };

    _proto2.recent = function recent() {
      return this._recent;
    };

    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };

    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };

    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };

    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }

      var child = this._first,
          labels = this.labels,
          p;

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
        }

        child = child._next;
      }

      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }

      return _uncache(this);
    };

    _proto2.invalidate = function invalidate() {
      var child = this._first;
      this._lock = 0;

      while (child) {
        child.invalidate();
        child = child._next;
      }

      return _Animation.prototype.invalidate.call(this);
    };

    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }

      var child = this._first,
          next;

      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }

      this._time = this._tTime = this._pTime = 0;

      if (includeLabels) {
        this.labels = {};
      }

      return _uncache(this);
    };

    _proto2.totalDuration = function totalDuration(value) {
      var max = 0,
          self = this,
          child = self._last,
          prevStart = _bigNum,
          prev,
          end,
          start,
          parent;

      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }

      if (self._dirty) {
        parent = self.parent;

        while (child) {
          prev = child._prev; //record it here in case the tween changes position in the sequence...

          child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

          start = child._start;

          if (start > prevStart && self._sort && child._ts && !self._lock) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }

          if (start < 0 && child._ts) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= start;

            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += start / self._ts;
              self._time -= start;
              self._tTime -= start;
            }

            self.shiftChildren(-start, false, -1e999);
            prevStart = 0;
          }

          end = _setEnd(child);

          if (end > max && child._ts) {
            max = end;
          }

          child = prev;
        }

        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1);

        self._dirty = 0;
      }

      return self._tDur;
    };

    Timeline.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

        _lastRenderedFrame = _ticker.frame;
      }

      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }

          child || _ticker.sleep();
        }
      }
    };

    return Timeline;
  }(Animation);

  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });

  var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
        index = 0,
        matchIndex = 0,
        result,
        startNums,
        color,
        endNum,
        chunk,
        startNum,
        hasRandom,
        a;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings

    end += "";

    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    startNums = start.match(_complexStringNumExp) || [];

    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }

      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

    pt.fp = funcParam;

    if (_relExp.test(end) || hasRandom) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop],
        parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
        setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
        pt;

    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }

      if (end.charAt(1) === "=") {
        end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
      }
    }

    if (parsedStart !== end) {
      if (!isNaN(parsedStart * end)) {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }

      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  },
      //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
  _processVars = function _processVars(vars, index, target, targets, tween) {
    if (_isFunction(vars)) {
      vars = _parseFuncOrString(vars, tween, index, target, targets);
    }

    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }

    var copy = {},
        p;

    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }

    return copy;
  },
      _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;

    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

        i = plugin._props.length;

        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }

    return plugin;
  },
      _overwritingTween,
      //store a reference temporarily so we can avoid overwriting itself.
  _initTween = function _initTween(tween, time) {
    var vars = tween.vars,
        ease = vars.ease,
        startAt = vars.startAt,
        immediateRender = vars.immediateRender,
        lazy = vars.lazy,
        onUpdate = vars.onUpdate,
        onUpdateParams = vars.onUpdateParams,
        callbackScope = vars.callbackScope,
        runBackwards = vars.runBackwards,
        yoyoEase = vars.yoyoEase,
        keyframes = vars.keyframes,
        autoRevert = vars.autoRevert,
        dur = tween._dur,
        prevStartAt = tween._startAt,
        targets = tween._targets,
        parent = tween.parent,
        fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
        autoOverwrite = tween._overwrite === "auto",
        tl = tween.timeline,
        cleanVars,
        i,
        p,
        pt,
        target,
        hasPriority,
        gsData,
        harness,
        plugin,
        ptLookup,
        index,
        harnessVars;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

    if (yoyoEase && tween._yoyo && !tween._repeat) {
      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }

    if (!tl) {
      //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

      cleanVars = _copyExcluding(vars, _reservedProps);
      prevStartAt && prevStartAt.render(-1, true).kill();

      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent,
          immediateRender: true,
          lazy: _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate,
          onUpdateParams: onUpdateParams,
          callbackScope: callbackScope,
          stagger: 0
        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


        if (immediateRender) {
          if (time > 0) {
            !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
          } else if (dur && !(time < 0 && prevStartAt)) {
            tween._zTime = time;
            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          }
        }
      } else if (runBackwards && dur) {
        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
        if (prevStartAt) {
          !autoRevert && (tween._startAt = 0);
        } else {
          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && _isNotFalse(lazy),
            immediateRender: immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

          _removeFromParent(tween._startAt = Tween.set(targets, p));

          if (!immediateRender) {
            _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

          } else if (!time) {
            return;
          }
        }
      }

      tween._pt = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;

      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

        index = fullTargets === targets ? i : fullTargets.indexOf(target);

        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

          plugin._props.forEach(function (name) {
            ptLookup[name] = pt;
          });

          plugin.priority && (hasPriority = 1);
        }

        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }

        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;

          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn't overwrite THIS tween!!!


          _overwritingTween = 0;
        }

        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }

      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
    }

    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

    tween._onUpdate = onUpdate;
    tween._initted = !!tween.parent; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
  },
      _addAliasesToVars = function _addAliasesToVars(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0,
        propertyAliases = harness && harness.aliases,
        copy,
        p,
        i,
        aliases;

    if (!propertyAliases) {
      return vars;
    }

    copy = _merge({}, vars);

    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;

        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }

    return copy;
  },
      _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  },
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
      _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
  /*
   * --------------------------------------------------------------------------------------
   * TWEEN
   * --------------------------------------------------------------------------------------
   */


  var Tween = /*#__PURE__*/function (_Animation2) {
    _inheritsLoose(Tween, _Animation2);

    function Tween(targets, vars, time, skipInherit) {
      var _this3;

      if (typeof vars === "number") {
        time.duration = vars;
        vars = time;
        time = null;
      }

      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars), time) || this;
      var _this3$vars = _this3.vars,
          duration = _this3$vars.duration,
          delay = _this3$vars.delay,
          immediateRender = _this3$vars.immediateRender,
          stagger = _this3$vars.stagger,
          overwrite = _this3$vars.overwrite,
          keyframes = _this3$vars.keyframes,
          defaults = _this3$vars.defaults,
          scrollTrigger = _this3$vars.scrollTrigger,
          yoyoEase = _this3$vars.yoyoEase,
          parent = _this3.parent,
          parsedTargets = (_isArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
          tl,
          i,
          copy,
          l,
          p,
          curTarget,
          staggerFunc,
          staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

      _this3._overwrite = overwrite;

      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults || {}
        });
        tl.kill();
        tl.parent = _assertThisInitialized(_this3);

        if (keyframes) {
          _setDefaults(tl.vars.defaults, {
            ease: "none"
          });

          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          l = parsedTargets.length;
          staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

          if (_isObject(stagger)) {
            //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }

          for (i = 0; i < l; i++) {
            copy = {};

            for (p in vars) {
              if (_staggerPropsToSkip.indexOf(p) < 0) {
                copy[p] = vars[p];
              }
            }

            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

            if (!stagger && l === 1 && copy.delay) {
              // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }

            tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
          }

          tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
        }

        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
      }

      if (overwrite === true) {
        _overwritingTween = _assertThisInitialized(_this3);

        _globalTimeline.killTweensOf(parsedTargets);

        _overwritingTween = 0;
      }

      parent && _postAddChecks(parent, _assertThisInitialized(_this3));

      if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

        _this3.render(Math.max(0, -delay)); //in case delay is negative

      }

      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }

    var _proto3 = Tween.prototype;

    _proto3.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._tDur,
          dur = this._dur,
          tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
          time,
          pt,
          iteration,
          cycleDuration,
          prevIteration,
          isYoyo,
          ratio,
          timeline,
          yoyoEase;

      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || this._startAt && this._zTime < 0 !== totalTime < 0) {
        //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
        time = tTime;
        timeline = this.timeline;

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          cycleDuration = dur + this._rDelay;
          time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (time > dur || tDur === tTime) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            time = dur;
          }

          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          isYoyo = this._yoyo && iteration & 1;

          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);

          if (time === prevTime && !force && this._initted) {
            //could be during the repeatDelay part. No need to render and fire callbacks.
            return this;
          }

          if (iteration !== prevIteration) {
            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
              this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

              this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }

        if (!this._initted) {
          if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
            this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

            return this;
          }

          if (dur !== this._dur) {
            // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._tTime = tTime;
        this._time = time;

        if (!this._act && this._ts) {
          this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

          this._lazy = 0;
        }

        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }

        time && !prevTime && !suppressEvents && _callback(this, "onStart");
        pt = this._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }

        timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

        if (this._onUpdate && !suppressEvents) {
          if (totalTime < 0 && this._startAt) {
            this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

          }

          _callback(this, "onUpdate");
        }

        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
            // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto3.targets = function targets() {
      return this._targets;
    };

    _proto3.invalidate = function invalidate() {
      this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate();
      return _Animation2.prototype.invalidate.call(this);
    };

    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }

      if (!targets && (!vars || vars === "all")) {
        this._lazy = 0;

        if (this.parent) {
          return _interrupt(this);
        }
      }

      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweenng, interrupt.

        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

        return this;
      }

      var parsedTargets = this._targets,
          killingTargets = targets ? toArray(targets) : parsedTargets,
          propTweenLookup = this._ptLookup,
          firstPT = this._pt,
          overwrittenProps,
          curLookup,
          curOverwriteProps,
          props,
          p,
          pt,
          i;

      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        return _interrupt(this);
      }

      overwrittenProps = this._op = this._op || [];

      if (vars !== "all") {
        //so people can pass in a comma-delimited list of property names
        if (_isString(vars)) {
          p = {};

          _forEachName(vars, function (name) {
            return p[name] = 1;
          });

          vars = p;
        }

        vars = _addAliasesToVars(parsedTargets, vars);
      }

      i = parsedTargets.length;

      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];

          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }

          for (p in props) {
            pt = curLookup && curLookup[p];

            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }

              delete curLookup[p];
            }

            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }

      this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

      return this;
    };

    Tween.to = function to(targets, vars) {
      return new Tween(targets, vars, arguments[2]);
    };

    Tween.from = function from(targets, vars) {
      return new Tween(targets, _parseVars(arguments, 1));
    };

    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };

    Tween.fromTo = function fromTo(targets, fromVars, toVars) {
      return new Tween(targets, _parseVars(arguments, 2));
    };

    Tween.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween(targets, vars);
    };

    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };

    return Tween;
  }(Animation);

  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
  // _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
  // 	Tween.prototype[name] = function() {
  // 		let tl = new Timeline();
  // 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
  // 	}
  // });
  //for backward compatibility. Leverage the timeline calls.


  _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
    Tween[name] = function () {
      var tl = new Timeline(),
          params = _slice.call(arguments, 0);

      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  /*
   * --------------------------------------------------------------------------------------
   * PROPTWEEN
   * --------------------------------------------------------------------------------------
   */


  var _setterPlain = function _setterPlain(target, property, value) {
    return target[property] = value;
  },
      _setterFunc = function _setterFunc(target, property, value) {
    return target[property](value);
  },
      _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
    return target[property](data.fp, value);
  },
      _setterAttribute = function _setterAttribute(target, property, value) {
    return target.setAttribute(property, value);
  },
      _getSetter = function _getSetter(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  },
      _renderPlain = function _renderPlain(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data);
  },
      _renderBoolean = function _renderBoolean(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  },
      _renderComplexString = function _renderComplexString(ratio, data) {
    var pt = data._pt,
        s = "";

    if (!ratio && data.b) {
      //b = beginning string
      s = data.b;
    } else if (ratio === 1 && data.e) {
      //e = ending string
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

        pt = pt._next;
      }

      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
    }

    data.set(data.t, data.p, s, data);
  },
      _renderPropTweens = function _renderPropTweens(ratio, data) {
    var pt = data._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  },
      _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
    var pt = this._pt,
        next;

    while (pt) {
      next = pt._next;

      if (pt.p === property) {
        pt.modifier(modifier, tween, target);
      }

      pt = next;
    }
  },
      _killPropTweensOf = function _killPropTweensOf(property) {
    var pt = this._pt,
        hasNonDependentRemaining,
        next;

    while (pt) {
      next = pt._next;

      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }

      pt = next;
    }

    return !hasNonDependentRemaining;
  },
      _setterWithModifier = function _setterWithModifier(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  },
      _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
    var pt = parent._pt,
        next,
        pt2,
        first,
        last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

    while (pt) {
      next = pt._next;
      pt2 = first;

      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }

      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }

      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }

      pt = next;
    }

    parent._pt = first;
  }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


  var PropTween = /*#__PURE__*/function () {
    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;

      if (next) {
        next._prev = this;
      }
    }

    var _proto4 = PropTween.prototype;

    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target; //modifier target

      this.tween = tween;
    };

    return PropTween;
  }(); //Initialization tasks

  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
    return _reservedProps[name] = 1;
  });

  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  /*
   * --------------------------------------------------------------------------------------
   * GSAP
   * --------------------------------------------------------------------------------------
   */

  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(function (config) {
        return _createPlugin(config);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      if (_isString(target)) {
        //in case selector text or an array is passed in
        target = toArray(target)[0];
      }

      var getter = _getCache(target || {}).get,
          format = unit ? _passThrough : _numericIfPossible;

      if (unit === "native") {
        unit = "";
      }

      return !target ? target : !property ? function (property, unit, uncache) {
        return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);

      if (target.length > 1) {
        var setters = target.map(function (t) {
          return gsap.quickSetter(t, property, unit);
        }),
            l = setters.length;
        return function (value) {
          var i = l;

          while (i--) {
            setters[i](value);
          }
        };
      }

      target = target[0] || {};

      var Plugin = _plugins[property],
          cache = _getCache(target),
          p = cache.harness && (cache.harness.aliases || {})[property] || property,
          // in case it's an alias, like "rotate" for "rotation".
      setter = Plugin ? function (value) {
        var p = new Plugin();
        _quickTween._pt = 0;
        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p.render(1, p);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);

      return Plugin ? setter : function (value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      if (value && value.ease) {
        value.ease = _parseEase(value.ease, _defaults.ease);
      }

      return _mergeDeep(_defaults, value || {});
    },
    config: function config(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref) {
      var name = _ref.name,
          effect = _ref.effect,
          plugins = _ref.plugins,
          defaults = _ref.defaults,
          extendTimeline = _ref.extendTimeline;
      (plugins || "").split(",").forEach(function (pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });

      _effects[name] = function (targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
      };

      if (extendTimeline) {
        Timeline.prototype[name] = function (targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }

      var tl = new Timeline(vars),
          child,
          next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

      _globalTimeline.remove(tl);

      tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;

      while (child) {
        next = child._next;

        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }

        child = next;
      }

      _addToTimeline(_globalTimeline, tl, 0);

      return tl;
    },
    utils: {
      wrap: wrap,
      wrapYoyo: wrapYoyo,
      distribute: distribute,
      random: random,
      snap: snap,
      normalize: normalize,
      getUnit: getUnit,
      clamp: clamp,
      splitColor: splitColor,
      toArray: toArray,
      mapRange: mapRange,
      pipe: pipe,
      unitize: unitize,
      interpolate: interpolate$1,
      shuffle: shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween: PropTween,
      globals: _addGlobal,
      Tween: Tween,
      Timeline: Timeline,
      Animation: Animation,
      getCache: _getCache,
      _removeLinkedListItem: _removeLinkedListItem
    }
  };

  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
    return _gsap[name] = Tween[name];
  });

  _ticker.add(Timeline.updateRoot);

  _quickTween = _gsap.to({}, {
    duration: 0
  }); // ---- EXTRA PLUGINS --------------------------------------------------------

  var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
    var pt = plugin._pt;

    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }

    return pt;
  },
      _addModifiers = function _addModifiers(tween, modifiers) {
    var targets = tween._targets,
        p,
        i,
        pt;

    for (p in modifiers) {
      i = targets.length;

      while (i--) {
        pt = tween._ptLookup[i][p];

        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            // is a plugin
            pt = _getPluginPropTween(pt, p);
          }

          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  },
      _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
    return {
      name: name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init(target, vars, tween) {
        tween._onInit = function (tween) {
          var temp, p;

          if (_isString(vars)) {
            temp = {};

            _forEachName(vars, function (name) {
              return temp[name] = 1;
            }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


            vars = temp;
          }

          if (modifier) {
            temp = {};

            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }

            vars = temp;
          }

          _addModifiers(tween, vars);
        };
      }
    };
  }; //register core plugins


  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt;

      for (p in vars) {
        pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
        pt && (pt.op = p); //this.add(target, "setAttribute", (target.getAttribute((p in target.dataset ? (p = "data-" + p) : p)) || 0) + "", vars[p], index, targets, 0, 0, p);

        this._props.push(p);
      }
    }
  }, {
    name: "endArray",
    init: function init(target, value) {
      var i = value.length;

      while (i--) {
        this.add(target, i, target[i] || 0, value[i]);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

  Tween.version = Timeline.version = gsap.version = "3.4.0";
  _coreReady = 1;

  if (_windowExists()) {
    _wake();
  }

  /*!
   * CSSPlugin 3.4.0
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  var _win$1,
      _doc$1,
      _docElement,
      _pluginInitted,
      _tempDiv,
      _tempDivStyler,
      _recentSetterPlugin,
      _windowExists$1 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _transformProps = {},
      _RAD2DEG = 180 / Math.PI,
      _DEG2RAD = Math.PI / 180,
      _atan2 = Math.atan2,
      _bigNum$1 = 1e8,
      _capsExp = /([A-Z])/g,
      _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
      _complexExp = /[\s,\(]\S/,
      _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  },
      _renderCSSProp = function _renderCSSProp(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
      //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
  },
      _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  },
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  },
      _setterCSSStyle = function _setterCSSStyle(target, property, value) {
    return target.style[property] = value;
  },
      _setterCSSProp = function _setterCSSProp(target, property, value) {
    return target.style.setProperty(property, value);
  },
      _setterTransform = function _setterTransform(target, property, value) {
    return target._gsap[property] = value;
  },
      _setterScale = function _setterScale(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  },
      _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  },
      _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  },
      _transformProp = "transform",
      _transformOriginProp = _transformProp + "Origin",
      _supports3D,
      _createElement = function _createElement(type, ns) {
    var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

    return e.style ? e : _doc$1.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  },
      _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
  },
      _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
      _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
    var e = element || _tempDiv,
        s = e.style,
        i = 5;

    if (property in s && !preferPrefix) {
      return property;
    }

    property = property.charAt(0).toUpperCase() + property.substr(1);

    while (i-- && !(_prefixes[i] + property in s)) {}

    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  },
      _initCore = function _initCore() {
    if (_windowExists$1() && window.document) {
      _win$1 = window;
      _doc$1 = _win$1.document;
      _docElement = _doc$1.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

      _supports3D = !!_checkPropPrefix("perspective");
      _pluginInitted = 1;
    }
  },
      _getBBoxHack = function _getBBoxHack(swapIfPossible) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        oldParent = this.parentNode,
        oldSibling = this.nextSibling,
        oldCSS = this.style.cssText,
        bbox;

    _docElement.appendChild(svg);

    svg.appendChild(this);
    this.style.display = "block";

    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox; //store the original

        this.getBBox = _getBBoxHack;
      } catch (e) {}
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }

    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }

    _docElement.removeChild(svg);

    this.style.cssText = oldCSS;
    return bbox;
  },
      _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
    var i = attributesArray.length;

    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  },
      _getBBox = function _getBBox(target) {
    var bounds;

    try {
      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }

    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  },
      _isSVG = function _isSVG(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
      //reports if the element is an SVG on which getBBox() actually works
  _removeProperty = function _removeProperty(target, property) {
    if (property) {
      var style = target.style;

      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }

      if (style.removeProperty) {
        if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          property = "-" + property;
        }

        style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        style.removeAttribute(property);
      }
    }
  },
      _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;

    plugin._props.push(property);

    return pt;
  },
      _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  },
      //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
  _convertToUnit = function _convertToUnit(target, property, value, unit) {
    var curValue = parseFloat(value) || 0,
        curUnit = (value + "").trim().substr((curValue + "").length) || "px",
        // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
    style = _tempDiv.style,
        horizontal = _horizontalExp.test(property),
        isRootSVG = target.tagName.toLowerCase() === "svg",
        measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
        amount = 100,
        toPixels = unit === "px",
        toPercent = unit === "%",
        px,
        parent,
        cache,
        isSVG;

    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }

    curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);

    if (toPercent && (_transformProps[property] || ~property.indexOf("adius"))) {
      //transforms and borderRadius are relative to the size of the element itself!
      return _round(curValue / (isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty]) * amount);
    }

    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }

    if (!parent || parent === _doc$1 || !parent.appendChild) {
      parent = _doc$1.body;
    }

    cache = parent._gsap;

    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
      return _round(curValue / cache.width * amount);
    } else {
      (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
      parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

      parent.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent.removeChild(_tempDiv);
      style.position = "absolute";

      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }

    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  },
      _get = function _get(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();

    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];

      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }

    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];

      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
      }
    }

    return unit && !~(value + "").indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  },
      _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
    //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    if (!start || start === "none") {
      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
      var p = _checkPropPrefix(prop, target, 1),
          s = p && _getComputedProperty(target, p, 1);

      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
      }
    }

    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
        index = 0,
        matchIndex = 0,
        a,
        result,
        startValues,
        startNum,
        color,
        startValue,
        endValue,
        endNum,
        chunk,
        endUnit,
        startUnit,
        relative,
        endValues;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings

    end += "";

    if (end === "auto") {
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      target.style[prop] = start;
    }

    a = [start, end];

    _colorStringFilter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];

    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);

        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }

        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

          if (relative) {
            endValue = endValue.substr(2);
          }

          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;

          if (!endUnit) {
            //if something like "perspective:300" is passed in and we must add a unit to the end
            endUnit = endUnit || _config.units[prop] || startUnit;

            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }

          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: relative ? relative * endNum : endNum - startNum,
            m: color && color < 4 ? Math.round : 0
          };
        }
      }

      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }

    if (_relExp.test(end)) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  },
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
    var split = value.split(" "),
        x = split[0],
        y = split[1] || "50%";

    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      //the user provided them in the wrong order, so flip them
      value = x;
      x = y;
      y = value;
    }

    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  },
      _renderClearProps = function _renderClearProps(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t,
          style = target.style,
          props = data.u,
          cache = target._gsap,
          prop,
          clearTransforms,
          i;

      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;

        while (--i > -1) {
          prop = props[i];

          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }

          _removeProperty(target, prop);
        }
      }

      if (clearTransforms) {
        _removeProperty(target, _transformProp);

        if (cache) {
          cache.svg && target.removeAttribute("transform");

          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


          cache.uncache = 1;
        }
      }
    }
  },
      // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
  _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;

        plugin._props.push(property);

        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */

  },

  /*
   * --------------------------------------------------------------------------------------
   * TRANSFORMS
   * --------------------------------------------------------------------------------------
   */
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _rotationalProperties = {},
      _isNullTransform = function _isNullTransform(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  },
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
    var matrixString = _getComputedProperty(target, _transformProp);

    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  },
      _getMatrix = function _getMatrix(target, force2D) {
    var cache = target._gsap || _getCache(target),
        style = target.style,
        matrix = _getComputedTransformMatrixAsArray(target),
        parent,
        nextSibling,
        temp,
        addedToDOM;

    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;

      if (!parent || !target.offsetParent) {
        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
        addedToDOM = 1; //flag

        nextSibling = target.nextSibling;

        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

      }

      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");

      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }

    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  },
      _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap,
        matrix = matrixArray || _getMatrix(target, true),
        xOriginOld = cache.xOrigin || 0,
        yOriginOld = cache.yOrigin || 0,
        xOffsetOld = cache.xOffset || 0,
        yOffsetOld = cache.yOffset || 0,
        a = matrix[0],
        b = matrix[1],
        c = matrix[2],
        d = matrix[3],
        tx = matrix[4],
        ty = matrix[5],
        originSplit = origin.split(" "),
        xOrigin = parseFloat(originSplit[0]) || 0,
        yOrigin = parseFloat(originSplit[1]) || 0,
        bounds,
        determinant,
        x,
        y;

    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }

    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }

    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }

    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  },
      _parseTransform = function _parseTransform(target, uncache) {
    var cache = target._gsap || new GSCache(target);

    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }

    var style = target.style,
        invertedScaleX = cache.scaleX < 0,
        px = "px",
        deg = "deg",
        origin = _getComputedProperty(target, _transformOriginProp) || "0",
        x,
        y,
        z,
        scaleX,
        scaleY,
        rotation,
        rotationX,
        rotationY,
        skewX,
        skewY,
        perspective,
        xOrigin,
        yOrigin,
        matrix,
        angle,
        cos,
        sin,
        a,
        b,
        c,
        d,
        a12,
        a22,
        t1,
        t2,
        t3,
        a13,
        a23,
        a33,
        a42,
        a43,
        a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    matrix = _getMatrix(target, cache.svg);

    if (cache.svg) {
      t1 = !cache.uncache && target.getAttribute("data-svg-origin");

      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }

    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;

    if (matrix !== _identity2DMatrix) {
      a = matrix[0]; //a11

      b = matrix[1]; //a21

      c = matrix[2]; //a31

      d = matrix[3]; //a41

      x = a12 = matrix[4];
      y = a22 = matrix[5]; //2D matrix

      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.cos(skewX * _DEG2RAD));

        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        } //3D matrix

      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG; //rotationX

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        } //rotationY


        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        } //rotationZ


        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }

        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }

        scaleX = _round(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }

      if (cache.svg) {
        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }

    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }

    cache.x = ((cache.xPercent = x && Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0) ? 0 : x) + px;
    cache.y = ((cache.yPercent = y && Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0) ? 0 : y) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;

    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }

    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  },
      _firstTwoOnly = function _firstTwoOnly(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  },
      //for handling transformOrigin values, stripping out the 3rd dimension
  _addPxTranslate = function _addPxTranslate(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  },
      _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;

    _renderCSSTransforms(ratio, cache);
  },
      _zeroDeg = "0deg",
      _zeroPx = "0px",
      _endParenthesis = ") ",
      _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
    var _ref = cache || this,
        xPercent = _ref.xPercent,
        yPercent = _ref.yPercent,
        x = _ref.x,
        y = _ref.y,
        z = _ref.z,
        rotation = _ref.rotation,
        rotationY = _ref.rotationY,
        rotationX = _ref.rotationX,
        skewX = _ref.skewX,
        skewY = _ref.skewY,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        transformPerspective = _ref.transformPerspective,
        force3D = _ref.force3D,
        target = _ref.target,
        zOrigin = _ref.zOrigin,
        transforms = "",
        use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD,
          a13 = Math.sin(angle),
          a33 = Math.cos(angle),
          cos;

      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }

    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }

    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }

    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }

    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }

    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }

    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }

    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }

    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }

    target.style[_transformProp] = transforms || "translate(0, 0)";
  },
      _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
    var _ref2 = cache || this,
        xPercent = _ref2.xPercent,
        yPercent = _ref2.yPercent,
        x = _ref2.x,
        y = _ref2.y,
        rotation = _ref2.rotation,
        skewX = _ref2.skewX,
        skewY = _ref2.skewY,
        scaleX = _ref2.scaleX,
        scaleY = _ref2.scaleY,
        target = _ref2.target,
        xOrigin = _ref2.xOrigin,
        yOrigin = _ref2.yOrigin,
        xOffset = _ref2.xOffset,
        yOffset = _ref2.yOffset,
        forceCSS = _ref2.forceCSS,
        tx = parseFloat(x),
        ty = parseFloat(y),
        a11,
        a21,
        a12,
        a22,
        temp;

    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);

    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }

    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;

      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;

        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }

      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }

    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }

    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }

    if (xPercent || yPercent) {
      //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }

    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);

    if (forceCSS) {
      //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
      target.style[_transformProp] = temp;
    }
  },
      _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
    var cap = 360,
        isString = _isString(endValue),
        endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
        change = relative ? endNum * relative : endNum - startNum,
        finalValue = startNum + change + "deg",
        direction,
        pt;

    if (isString) {
      direction = endValue.split("_")[1];

      if (direction === "short") {
        change %= cap;

        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }

      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;
      }
    }

    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";

    plugin._props.push(property);

    return pt;
  },
      _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
    var style = _tempDivStyler.style,
        startCache = target._gsap,
        exclude = "perspective,force3D,transformOrigin,svgOrigin",
        endCache,
        p,
        startValue,
        endValue,
        startNum,
        endNum,
        startUnit,
        endUnit;
    style.cssText = getComputedStyle(target).cssText + ";position:absolute;display:block;"; //%-based translations will fail unless we set the width/height to match the original target (and padding/borders can affect it)

    style[_transformProp] = transforms;

    _doc$1.body.appendChild(_tempDivStyler);

    endCache = _parseTransform(_tempDivStyler, 1);

    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];

      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, startCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;

        plugin._props.push(p);
      }
    }

    _doc$1.body.removeChild(_tempDivStyler);
  }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


  _forEachName("padding,margin,Width,Radius", function (name, index) {
    var t = "Top",
        r = "Right",
        b = "Bottom",
        l = "Left",
        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
      return index < 2 ? name + side : "border" + side + name;
    });

    _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
      var a, vars;

      if (arguments.length < 4) {
        // getter, passed target, property, and unit (from _get())
        a = props.map(function (prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }

      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function (prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });

  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init(target, vars, tween, index, targets) {
      var props = this._props,
          style = target.style,
          startValue,
          endValue,
          endNum,
          startNum,
          type,
          specialProp,
          p,
          startUnit,
          endUnit,
          relative,
          isTransformRelated,
          transformPropTween,
          cache,
          smooth,
          hasPriority;

      if (!_pluginInitted) {
        _initCore();
      }

      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }

        endValue = vars[p];

        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          //plugins
          continue;
        }

        type = typeof endValue;
        specialProp = _specialProps[p];

        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }

        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }

        if (specialProp) {
          if (specialProp(this, target, p, endValue, tween)) {
            hasPriority = 1;
          }
        } else if (p.substr(0, 2) === "--") {
          //CSS variable
          this.add(style, "setProperty", getComputedStyle(target).getPropertyValue(p) + "", endValue + "", index, targets, 0, 0, p);
        } else {
          startValue = _get(target, p);
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

          if (relative) {
            endValue = endValue.substr(2);
          }

          endNum = parseFloat(endValue);

          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                startNum = 0;
              }

              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }

            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];

              if (~p.indexOf(",")) {
                p = p.split(",")[0];
              }
            }
          }

          isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

          if (isTransformRelated) {
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform || _parseTransform(target); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

              transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
            }

            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

                if (endUnit !== cache.zOrigin) {
                  _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                }

                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }

              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);

              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);

              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }

          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0); // protect against NaN

            endUnit = (endValue + "").substr((endNum + "").length) || (p in _config.units ? _config.units[p] : startUnit);

            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, p, startValue, endUnit);
            }

            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, endUnit === "px" && vars.autoRound !== false && !isTransformRelated ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;

            if (startUnit !== endUnit) {
              //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
              this.add(target, p, target[p], endValue, index, targets);
            } else {
              _missingPlugin(p, endValue);

              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, endValue);
          }

          props.push(p);
        }
      }

      if (hasPriority) {
        _sortPropTweensByPriority(this);
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty: _removeProperty,
      _getMatrix: _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;

  (function (positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
      _transformProps[name] = 1;
    });

    _forEachName(rotation, function (name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });

    _propertyAliases[all[13]] = positionAndScale + "," + rotation;

    _forEachName(aliases, function (name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
    _config.units[name] = "px";
  });

  gsap.registerPlugin(CSSPlugin);

  /*!
   * paths 3.4.0
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
      _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
      _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
      _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i,
      _DEG2RAD$1 = Math.PI / 180,
      _sin$1 = Math.sin,
      _cos$1 = Math.cos,
      _abs = Math.abs,
      _sqrt$1 = Math.sqrt,
      _isString$1 = function _isString(value) {
    return typeof value === "string";
  },
      _isNumber$1 = function _isNumber(value) {
    return typeof value === "number";
  },
      _roundingNum = 1e5,
      //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.
  _round$1 = function _round(value) {
    return Math.round(value * _roundingNum) / _roundingNum || 0;
  };
  /* TERMINOLOGY
   - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
   - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
   - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
   - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
   */
  //accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).


  function getRawPath(value) {
    value = _isString$1(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
    var e = value.getAttribute ? value : 0,
        rawPath;

    if (e && (value = value.getAttribute("d"))) {
      //implements caching
      if (!e._gsPath) {
        e._gsPath = {};
      }

      rawPath = e._gsPath[value];
      return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
    }

    return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString$1(value) ? stringToRawPath(value) : _isNumber$1(value[0]) ? [value] : value;
  } //copies a RawPath WITHOUT the length meta data (for speed)
  function reverseSegment(segment) {
    var i = 0,
        y;
    segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.

    for (; i < segment.length; i += 2) {
      y = segment[i];
      segment[i] = segment[i + 1];
      segment[i + 1] = y;
    }

    segment.reversed = !segment.reversed;
  }

  var _createPath = function _createPath(e, ignore) {
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
        attr = [].slice.call(e.attributes),
        i = attr.length,
        name;
    ignore = "," + ignore + ",";

    while (--i > -1) {
      name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.

      if (ignore.indexOf("," + name + ",") < 0) {
        path.setAttributeNS(null, name, attr[i].nodeValue);
      }
    }

    return path;
  },
      _typeAttrs = {
    rect: "rx,ry,x,y,width,height",
    circle: "r,cx,cy",
    ellipse: "rx,ry,cx,cy",
    line: "x1,x2,y1,y2"
  },
      _attrToObj = function _attrToObj(e, attrs) {
    var props = attrs ? attrs.split(",") : [],
        obj = {},
        i = props.length;

    while (--i > -1) {
      obj[props[i]] = +e.getAttribute(props[i]) || 0;
    }

    return obj;
  }; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.


  function convertToPath(element, swap) {
    var type = element.tagName.toLowerCase(),
        circ = 0.552284749831,
        data,
        x,
        y,
        r,
        ry,
        path,
        rcirc,
        rycirc,
        points,
        w,
        h,
        x2,
        x3,
        x4,
        x5,
        x6,
        y2,
        y3,
        y4,
        y5,
        y6,
        attr;

    if (type === "path" || !element.getBBox) {
      return element;
    }

    path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
    attr = _attrToObj(element, _typeAttrs[type]);

    if (type === "rect") {
      r = attr.rx;
      ry = attr.ry || r;
      x = attr.x;
      y = attr.y;
      w = attr.width - r * 2;
      h = attr.height - ry * 2;

      if (r || ry) {
        //if there are rounded corners, render cubic beziers
        x2 = x + r * (1 - circ);
        x3 = x + r;
        x4 = x3 + w;
        x5 = x4 + r * circ;
        x6 = x4 + r;
        y2 = y + ry * (1 - circ);
        y3 = y + ry;
        y4 = y3 + h;
        y5 = y4 + ry * circ;
        y6 = y4 + ry;
        data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
      } else {
        data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
      }
    } else if (type === "circle" || type === "ellipse") {
      if (type === "circle") {
        r = ry = attr.r;
        rycirc = r * circ;
      } else {
        r = attr.rx;
        ry = attr.ry;
        rycirc = ry * circ;
      }

      x = attr.cx;
      y = attr.cy;
      rcirc = r * circ;
      data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
    } else if (type === "line") {
      data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
    } else if (type === "polyline" || type === "polygon") {
      points = (element.getAttribute("points") + "").match(_numbersExp) || [];
      x = points.shift();
      y = points.shift();
      data = "M" + x + "," + y + " L" + points.join(",");

      if (type === "polygon") {
        data += "," + x + "," + y + "z";
      }
    }

    path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));

    if (swap && element.parentNode) {
      element.parentNode.insertBefore(path, element);
      element.parentNode.removeChild(element);
    }

    return path;
  } //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)

  function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
    if (lastX === x && lastY === y) {
      return;
    }

    rx = _abs(rx);
    ry = _abs(ry);

    var angleRad = angle % 360 * _DEG2RAD$1,
        cosAngle = _cos$1(angleRad),
        sinAngle = _sin$1(angleRad),
        PI = Math.PI,
        TWOPI = PI * 2,
        dx2 = (lastX - x) / 2,
        dy2 = (lastY - y) / 2,
        x1 = cosAngle * dx2 + sinAngle * dy2,
        y1 = -sinAngle * dx2 + cosAngle * dy2,
        x1_sq = x1 * x1,
        y1_sq = y1 * y1,
        radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);

    if (radiiCheck > 1) {
      rx = _sqrt$1(radiiCheck) * rx;
      ry = _sqrt$1(radiiCheck) * ry;
    }

    var rx_sq = rx * rx,
        ry_sq = ry * ry,
        sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);

    if (sq < 0) {
      sq = 0;
    }

    var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt$1(sq),
        cx1 = coef * (rx * y1 / ry),
        cy1 = coef * -(ry * x1 / rx),
        sx2 = (lastX + x) / 2,
        sy2 = (lastY + y) / 2,
        cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
        cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
        ux = (x1 - cx1) / rx,
        uy = (y1 - cy1) / ry,
        vx = (-x1 - cx1) / rx,
        vy = (-y1 - cy1) / ry,
        temp = ux * ux + uy * uy,
        angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt$1(temp)),
        angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt$1(temp * (vx * vx + vy * vy)));

    isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.

    if (!sweepFlag && angleExtent > 0) {
      angleExtent -= TWOPI;
    } else if (sweepFlag && angleExtent < 0) {
      angleExtent += TWOPI;
    }

    angleStart %= TWOPI;
    angleExtent %= TWOPI;

    var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),
        rawPath = [],
        angleIncrement = angleExtent / segments,
        controlLength = 4 / 3 * _sin$1(angleIncrement / 2) / (1 + _cos$1(angleIncrement / 2)),
        ma = cosAngle * rx,
        mb = sinAngle * rx,
        mc = sinAngle * -ry,
        md = cosAngle * ry,
        i;

    for (i = 0; i < segments; i++) {
      angle = angleStart + i * angleIncrement;
      x1 = _cos$1(angle);
      y1 = _sin$1(angle);
      ux = _cos$1(angle += angleIncrement);
      uy = _sin$1(angle);
      rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
    } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).


    for (i = 0; i < rawPath.length; i += 2) {
      x1 = rawPath[i];
      y1 = rawPath[i + 1];
      rawPath[i] = x1 * ma + y1 * mc + cx;
      rawPath[i + 1] = x1 * mb + y1 * md + cy;
    }

    rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be

    rawPath[i - 1] = y;
    return rawPath;
  } //Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.


  function stringToRawPath(d) {
    var a = (d + "").replace(_scientific, function (m) {
      var n = +m;
      return n < 0.0001 && n > -0.0001 ? 0 : n;
    }).match(_svgPathExp) || [],
        //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
    path = [],
        relativeX = 0,
        relativeY = 0,
        twoThirds = 2 / 3,
        elements = a.length,
        points = 0,
        errorMessage = "ERROR: malformed path: " + d,
        i,
        j,
        x,
        y,
        command,
        isRelative,
        segment,
        startX,
        startY,
        difX,
        difY,
        beziers,
        prevCommand,
        flag1,
        flag2,
        line = function line(sx, sy, ex, ey) {
      difX = (ex - sx) / 3;
      difY = (ey - sy) / 3;
      segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
    };

    if (!d || !isNaN(a[0]) || isNaN(a[1])) {
      console.log(errorMessage);
      return path;
    }

    for (i = 0; i < elements; i++) {
      prevCommand = command;

      if (isNaN(a[i])) {
        command = a[i].toUpperCase();
        isRelative = command !== a[i]; //lower case means relative
      } else {
        //commands like "C" can be strung together without any new command characters between.
        i--;
      }

      x = +a[i + 1];
      y = +a[i + 2];

      if (isRelative) {
        x += relativeX;
        y += relativeY;
      }

      if (!i) {
        startX = x;
        startY = y;
      } // "M" (move)


      if (command === "M") {
        if (segment) {
          if (segment.length < 8) {
            //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
            path.length -= 1;
          } else {
            points += segment.length;
          }
        }

        relativeX = startX = x;
        relativeY = startY = y;
        segment = [x, y];
        path.push(segment);
        i += 2;
        command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").
        // "C" (cubic bezier)
      } else if (command === "C") {
        if (!segment) {
          segment = [0, 0];
        }

        if (!isRelative) {
          relativeX = relativeY = 0;
        } //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.


        segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
        i += 6; // "S" (continuation of cubic bezier)
      } else if (command === "S") {
        difX = relativeX;
        difY = relativeY;

        if (prevCommand === "C" || prevCommand === "S") {
          difX += relativeX - segment[segment.length - 4];
          difY += relativeY - segment[segment.length - 3];
        }

        if (!isRelative) {
          relativeX = relativeY = 0;
        }

        segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
        i += 4; // "Q" (quadratic bezier)
      } else if (command === "Q") {
        difX = relativeX + (x - relativeX) * twoThirds;
        difY = relativeY + (y - relativeY) * twoThirds;

        if (!isRelative) {
          relativeX = relativeY = 0;
        }

        relativeX += a[i + 3] * 1;
        relativeY += a[i + 4] * 1;
        segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
        i += 4; // "T" (continuation of quadratic bezier)
      } else if (command === "T") {
        difX = relativeX - segment[segment.length - 4];
        difY = relativeY - segment[segment.length - 3];
        segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
        i += 2; // "H" (horizontal line)
      } else if (command === "H") {
        line(relativeX, relativeY, relativeX = x, relativeY);
        i += 1; // "V" (vertical line)
      } else if (command === "V") {
        //adjust values because the first (and only one) isn't x in this case, it's y.
        line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
        i += 1; // "L" (line) or "Z" (close)
      } else if (command === "L" || command === "Z") {
        if (command === "Z") {
          x = startX;
          y = startY;
          segment.closed = true;
        }

        if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
          line(relativeX, relativeY, x, y);

          if (command === "L") {
            i += 2;
          }
        }

        relativeX = x;
        relativeY = y; // "A" (arc)
      } else if (command === "A") {
        flag1 = a[i + 4];
        flag2 = a[i + 5];
        difX = a[i + 6];
        difY = a[i + 7];
        j = 7;

        if (flag1.length > 1) {
          // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
          if (flag1.length < 3) {
            difY = difX;
            difX = flag2;
            j--;
          } else {
            difY = flag2;
            difX = flag1.substr(2);
            j -= 2;
          }

          flag2 = flag1.charAt(1);
          flag1 = flag1.charAt(0);
        }

        beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
        i += j;

        if (beziers) {
          for (j = 0; j < beziers.length; j++) {
            segment.push(beziers[j]);
          }
        }

        relativeX = segment[segment.length - 2];
        relativeY = segment[segment.length - 1];
      } else {
        console.log(errorMessage);
      }
    }

    i = segment.length;

    if (i < 6) {
      //in case there's odd SVG like a M0,0 command at the very end.
      path.pop();
      i = 0;
    } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
      segment.closed = true;
    }

    path.totalPoints = points + i;
    return path;
  } //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays
  /*
  Takes any of the following and converts it to an all Cubic Bezier SVG data string:
  - A <path> data string like "M0,0 L2,4 v20,15 H100"
  - A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
  - A Segment, like [x, y, x, y, x, y, x, y]

  Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
  */

  function rawPathToString(rawPath) {
    if (_isNumber$1(rawPath[0])) {
      //in case a segment is passed in instead
      rawPath = [rawPath];
    }

    var result = "",
        l = rawPath.length,
        sl,
        s,
        i,
        segment;

    for (s = 0; s < l; s++) {
      segment = rawPath[s];
      result += "M" + _round$1(segment[0]) + "," + _round$1(segment[1]) + " C";
      sl = segment.length;

      for (i = 2; i < sl; i++) {
        result += _round$1(segment[i++]) + "," + _round$1(segment[i++]) + " " + _round$1(segment[i++]) + "," + _round$1(segment[i++]) + " " + _round$1(segment[i++]) + "," + _round$1(segment[i]) + " ";
      }

      if (segment.closed) {
        result += "z";
      }
    }

    return result;
  }
  /*
  // takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
  export function cpCoordsToAngles(segment, copy) {
  	var result = copy ? segment.slice(0) : segment,
  		x, y, i;
  	for (i = 0; i < segment.length; i+=6) {
  		x = segment[i+2] - segment[i];
  		y = segment[i+3] - segment[i+1];
  		result[i+2] = Math.atan2(y, x);
  		result[i+3] = Math.sqrt(x * x + y * y);
  		x = segment[i+6] - segment[i+4];
  		y = segment[i+7] - segment[i+5];
  		result[i+4] = Math.atan2(y, x);
  		result[i+5] = Math.sqrt(x * x + y * y);
  	}
  	return result;
  }

  // takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
  export function cpAnglesToCoords(segment, copy) {
  	var result = copy ? segment.slice(0) : segment,
  		length = segment.length,
  		rnd = 1000,
  		angle, l, i, j;
  	for (i = 0; i < length; i+=6) {
  		angle = segment[i+2];
  		l = segment[i+3]; //length
  		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
  		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
  		angle = segment[i+4];
  		l = segment[i+5]; //length
  		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
  		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
  	}
  	return result;
  }

  //adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
  export function populateSmoothData(rawPath) {
  	let j = rawPath.length,
  		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
  	while (--j > -1) {
  		segment = rawPath[j];
  		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
  		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
  		isSmooth.length = 4;
  		l = segment.length - 2;
  		for (i = 6; i < l; i += 6) {
  			x = segment[i] - segment[i - 2];
  			y = segment[i + 1] - segment[i - 1];
  			x2 = segment[i + 2] - segment[i];
  			y2 = segment[i + 3] - segment[i + 1];
  			a = _atan2(y, x);
  			a2 = _atan2(y2, x2);
  			smooth = (Math.abs(a - a2) < 0.09);
  			if (smooth) {
  				smoothData[i - 2] = a;
  				smoothData[i + 2] = a2;
  				smoothData[i - 1] = _sqrt(x * x + y * y);
  				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
  			}
  			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
  		}
  		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
  		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
  			x = segment[0] - segment[l-2];
  			y = segment[1] - segment[l-1];
  			x2 = segment[2] - segment[0];
  			y2 = segment[3] - segment[1];
  			a = _atan2(y, x);
  			a2 = _atan2(y2, x2);
  			if (Math.abs(a - a2) < 0.09) {
  				smoothData[l-2] = a;
  				smoothData[2] = a2;
  				smoothData[l-1] = _sqrt(x * x + y * y);
  				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
  				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
  			}
  		}
  	}
  	return rawPath;
  }
  export function pointToScreen(svgElement, point) {
  	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
  		let rawPath = getRawPath(svgElement);
  		point = svgElement.ownerSVGElement.createSVGPoint();
  		point.x = rawPath[0][0];
  		point.y = rawPath[0][1];
  	}
  	return point.matrixTransform(svgElement.getScreenCTM());
  }

  */

  /*!
   * MorphSVGPlugin 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  var gsap$1,
      _toArray,
      _lastLinkedAnchor,
      _coreInitted$1,
      PluginClass,
      _getGSAP = function _getGSAP() {
    return gsap$1 || typeof window !== "undefined" && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
  },
      _isFunction$1 = function _isFunction(value) {
    return typeof value === "function";
  },
      _atan2$1 = Math.atan2,
      _cos$2 = Math.cos,
      _sin$2 = Math.sin,
      _sqrt$2 = Math.sqrt,
      _PI = Math.PI,
      _2PI$1 = _PI * 2,
      _angleMin = _PI * 0.3,
      _angleMax = _PI * 0.7,
      _bigNum$2 = 1e20,
      _numExp$1 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
      //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _selectorExp$1 = /(^[#\.][a-z]|[a-y][a-z])/gi,
      _commands = /[achlmqstvz]/ig,
      _log = function _log(message) {
    return console && console.warn(message);
  },
      _bonusValidated = 1,
      //<name>MorphSVGPlugin</name>
  _getAverageXY = function _getAverageXY(segment) {
    var l = segment.length,
        x = 0,
        y = 0,
        i;

    for (i = 0; i < l; i++) {
      x += segment[i++];
      y += segment[i];
    }

    return [x / (l / 2), y / (l / 2)];
  },
      _getSize = function _getSize(segment) {
    //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)
    var l = segment.length,
        xMax = segment[0],
        xMin = xMax,
        yMax = segment[1],
        yMin = yMax,
        x,
        y,
        i;

    for (i = 6; i < l; i += 6) {
      x = segment[i];
      y = segment[i + 1];

      if (x > xMax) {
        xMax = x;
      } else if (x < xMin) {
        xMin = x;
      }

      if (y > yMax) {
        yMax = y;
      } else if (y < yMin) {
        yMin = y;
      }
    }

    segment.centerX = (xMax + xMin) / 2;
    segment.centerY = (yMax + yMin) / 2;
    return segment.size = (xMax - xMin) * (yMax - yMin);
  },
      _getTotalSize = function _getTotalSize(rawPath, samplesPerBezier) {
    if (samplesPerBezier === void 0) {
      samplesPerBezier = 3;
    }

    //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)
    var j = rawPath.length,
        xMax = rawPath[0][0],
        xMin = xMax,
        yMax = rawPath[0][1],
        yMin = yMax,
        inc = 1 / samplesPerBezier,
        l,
        x,
        y,
        i,
        segment,
        k,
        t,
        inv,
        x1,
        y1,
        x2,
        x3,
        x4,
        y2,
        y3,
        y4;

    while (--j > -1) {
      segment = rawPath[j];
      l = segment.length;

      for (i = 6; i < l; i += 6) {
        x1 = segment[i];
        y1 = segment[i + 1];
        x2 = segment[i + 2] - x1;
        y2 = segment[i + 3] - y1;
        x3 = segment[i + 4] - x1;
        y3 = segment[i + 5] - y1;
        x4 = segment[i + 6] - x1;
        y4 = segment[i + 7] - y1;
        k = samplesPerBezier;

        while (--k > -1) {
          t = inc * k;
          inv = 1 - t;
          x = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;
          y = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;

          if (x > xMax) {
            xMax = x;
          } else if (x < xMin) {
            xMin = x;
          }

          if (y > yMax) {
            yMax = y;
          } else if (y < yMin) {
            yMin = y;
          }
        }
      }
    }

    rawPath.centerX = (xMax + xMin) / 2;
    rawPath.centerY = (yMax + yMin) / 2;
    rawPath.left = xMin;
    rawPath.width = xMax - xMin;
    rawPath.top = yMin;
    rawPath.height = yMax - yMin;
    return rawPath.size = (xMax - xMin) * (yMax - yMin);
  },
      _sortByComplexity = function _sortByComplexity(a, b) {
    return b.length - a.length;
  },
      _sortBySize = function _sortBySize(a, b) {
    var sizeA = a.size || _getSize(a),
        sizeB = b.size || _getSize(b);

    return Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.
  },
      _offsetSegment = function _offsetSegment(segment, shapeIndex) {
    var a = segment.slice(0),
        l = segment.length,
        wrap = l - 2,
        i,
        index;
    shapeIndex = shapeIndex | 0;

    for (i = 0; i < l; i++) {
      index = (i + shapeIndex) % wrap;
      segment[i++] = a[index];
      segment[i] = a[index + 1];
    }
  },
      _getTotalMovement = function _getTotalMovement(sb, eb, shapeIndex, offsetX, offsetY) {
    var l = sb.length,
        d = 0,
        wrap = l - 2,
        index,
        i,
        x,
        y;
    shapeIndex *= 6;

    for (i = 0; i < l; i += 6) {
      index = (i + shapeIndex) % wrap;
      y = sb[index] - (eb[i] - offsetX);
      x = sb[index + 1] - (eb[i + 1] - offsetY);
      d += _sqrt$2(x * x + y * y);
    }

    return d;
  },
      _getClosestShapeIndex = function _getClosestShapeIndex(sb, eb, checkReverse) {
    //finds the index in a closed cubic bezier array that's closest to the angle provided (angle measured from the center or average x/y).
    var l = sb.length,
        sCenter = _getAverageXY(sb),
        //when comparing distances, adjust the coordinates as if the shapes are centered with each other.
    eCenter = _getAverageXY(eb),
        offsetX = eCenter[0] - sCenter[0],
        offsetY = eCenter[1] - sCenter[1],
        min = _getTotalMovement(sb, eb, 0, offsetX, offsetY),
        minIndex = 0,
        copy,
        d,
        i;

    for (i = 6; i < l; i += 6) {
      d = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);

      if (d < min) {
        min = d;
        minIndex = i;
      }
    }

    if (checkReverse) {
      copy = sb.slice(0);
      reverseSegment(copy);

      for (i = 6; i < l; i += 6) {
        d = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);

        if (d < min) {
          min = d;
          minIndex = -i;
        }
      }
    }

    return minIndex / 6;
  },
      _getClosestAnchor = function _getClosestAnchor(rawPath, x, y) {
    //finds the x/y of the anchor that's closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.
    var j = rawPath.length,
        closestDistance = _bigNum$2,
        closestX = 0,
        closestY = 0,
        segment,
        dx,
        dy,
        d,
        i,
        l;

    while (--j > -1) {
      segment = rawPath[j];
      l = segment.length;

      for (i = 0; i < l; i += 6) {
        dx = segment[i] - x;
        dy = segment[i + 1] - y;
        d = _sqrt$2(dx * dx + dy * dy);

        if (d < closestDistance) {
          closestDistance = d;
          closestX = segment[i];
          closestY = segment[i + 1];
        }
      }
    }

    return [closestX, closestY];
  },
      _getClosestSegment = function _getClosestSegment(bezier, pool, startIndex, sortRatio, offsetX, offsetY) {
    //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn't drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.
    var l = pool.length,
        index = 0,
        minSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio,
        //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.
    min = _bigNum$2,
        cx = bezier.centerX + offsetX,
        cy = bezier.centerY + offsetY,
        size,
        i,
        dx,
        dy,
        d;

    for (i = startIndex; i < l; i++) {
      size = pool[i].size || _getSize(pool[i]);

      if (size < minSize) {
        break;
      }

      dx = pool[i].centerX - cx;
      dy = pool[i].centerY - cy;
      d = _sqrt$2(dx * dx + dy * dy);

      if (d < min) {
        index = i;
        min = d;
      }
    }

    d = pool[index];
    pool.splice(index, 1);
    return d;
  },
      _subdivideSegmentQty = function _subdivideSegmentQty(segment, quantity) {
    var tally = 0,
        max = 0.999999,
        l = segment.length,
        newPointsPerSegment = quantity / ((l - 2) / 6),
        ax,
        ay,
        cp1x,
        cp1y,
        cp2x,
        cp2y,
        bx,
        by,
        x1,
        y1,
        x2,
        y2,
        i,
        t;

    for (i = 2; i < l; i += 6) {
      tally += newPointsPerSegment;

      while (tally > max) {
        //compare with 0.99999 instead of 1 in order to prevent rounding errors
        ax = segment[i - 2];
        ay = segment[i - 1];
        cp1x = segment[i];
        cp1y = segment[i + 1];
        cp2x = segment[i + 2];
        cp2y = segment[i + 3];
        bx = segment[i + 4];
        by = segment[i + 5];
        t = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)

        x1 = ax + (cp1x - ax) * t;
        x2 = cp1x + (cp2x - cp1x) * t;
        x1 += (x2 - x1) * t;
        x2 += (cp2x + (bx - cp2x) * t - x2) * t;
        y1 = ay + (cp1y - ay) * t;
        y2 = cp1y + (cp2y - cp1y) * t;
        y1 += (y2 - y1) * t;
        y2 += (cp2y + (by - cp2y) * t - y2) * t;
        segment.splice(i, 4, ax + (cp1x - ax) * t, //first control point
        ay + (cp1y - ay) * t, x1, //second control point
        y1, x1 + (x2 - x1) * t, //new fabricated anchor on line
        y1 + (y2 - y1) * t, x2, //third control point
        y2, cp2x + (bx - cp2x) * t, //fourth control point
        cp2y + (by - cp2y) * t);
        i += 6;
        l += 6;
        tally--;
      }
    }

    return segment;
  },
      _equalizeSegmentQuantity = function _equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe) {
    //returns an array of shape indexes, 1 for each segment.
    var dif = end.length - start.length,
        longer = dif > 0 ? end : start,
        shorter = dif > 0 ? start : end,
        added = 0,
        sortMethod = map === "complexity" ? _sortByComplexity : _sortBySize,
        sortRatio = map === "position" ? 0 : typeof map === "number" ? map : 0.8,
        i = shorter.length,
        shapeIndices = typeof shapeIndex === "object" && shapeIndex.push ? shapeIndex.slice(0) : [shapeIndex],
        reverse = shapeIndices[0] === "reverse" || shapeIndices[0] < 0,
        log = shapeIndex === "log",
        eb,
        sb,
        b,
        x,
        y,
        offsetX,
        offsetY;

    if (!shorter[0]) {
      return;
    }

    if (longer.length > 1) {
      start.sort(sortMethod);
      end.sort(sortMethod);
      offsetX = longer.size || _getTotalSize(longer); //ensures centerX and centerY are defined (used below).

      offsetX = shorter.size || _getTotalSize(shorter);
      offsetX = longer.centerX - shorter.centerX;
      offsetY = longer.centerY - shorter.centerY;

      if (sortMethod === _sortBySize) {
        for (i = 0; i < shorter.length; i++) {
          longer.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));
        }
      }
    }

    if (dif) {
      if (dif < 0) {
        dif = -dif;
      }

      if (longer[0].length > shorter[0].length) {
        //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)
        _subdivideSegmentQty(shorter[0], (longer[0].length - shorter[0].length) / 6 | 0);
      }

      i = shorter.length;

      while (added < dif) {
        x = longer[i].size || _getSize(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.

        b = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);
        x = b[0];
        y = b[1];
        shorter[i++] = [x, y, x, y, x, y, x, y];
        shorter.totalPoints += 8;
        added++;
      }
    }

    for (i = 0; i < start.length; i++) {
      eb = end[i];
      sb = start[i];
      dif = eb.length - sb.length;

      if (dif < 0) {
        _subdivideSegmentQty(eb, -dif / 6 | 0);
      } else if (dif > 0) {
        _subdivideSegmentQty(sb, dif / 6 | 0);
      }

      if (reverse && fillSafe !== false && !sb.reversed) {
        reverseSegment(sb);
      }

      shapeIndex = shapeIndices[i] || shapeIndices[i] === 0 ? shapeIndices[i] : "auto";

      if (shapeIndex) {
        //if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.
        if (sb.closed || Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5) {
          if (shapeIndex === "auto" || shapeIndex === "log") {
            shapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, !i || fillSafe === false);

            if (shapeIndex < 0) {
              reverse = true;
              reverseSegment(sb);
              shapeIndex = -shapeIndex;
            }

            _offsetSegment(sb, shapeIndex * 6);
          } else if (shapeIndex !== "reverse") {
            if (i && shapeIndex < 0) {
              //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.
              reverseSegment(sb);
            }

            _offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);
          } //otherwise, if it's not a closed shape, consider reversing it if that would make the overall travel less

        } else if (!reverse && (shapeIndex === "auto" && Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1]) || shapeIndex % 2)) {
          reverseSegment(sb);
          shapeIndices[i] = -1;
          reverse = true;
        } else if (shapeIndex === "auto") {
          shapeIndices[i] = 0;
        } else if (shapeIndex === "reverse") {
          shapeIndices[i] = -1;
        }

        if (sb.closed !== eb.closed) {
          //if one is closed and one isn't, don't close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)
          sb.closed = eb.closed = false;
        }
      }
    }

    if (log) {
      _log("shapeIndex:[" + shapeIndices.join(",") + "]");
    }

    start.shapeIndex = shapeIndices;
    return shapeIndices;
  },
      _pathFilter = function _pathFilter(a, shapeIndex, map, precompile, fillSafe) {
    var start = stringToRawPath(a[0]),
        end = stringToRawPath(a[1]);

    if (!_equalizeSegmentQuantity(start, end, shapeIndex || shapeIndex === 0 ? shapeIndex : "auto", map, fillSafe)) {
      return; //malformed path data or null target
    }

    a[0] = rawPathToString(start);
    a[1] = rawPathToString(end);

    if (precompile === "log" || precompile === true) {
      _log('precompile:["' + a[0] + '","' + a[1] + '"]');
    }
  },
      _offsetPoints = function _offsetPoints(text, offset) {
    if (!offset) {
      return text;
    }

    var a = text.match(_numExp$1) || [],
        l = a.length,
        s = "",
        inc,
        i,
        j;

    if (offset === "reverse") {
      i = l - 1;
      inc = -2;
    } else {
      i = ((parseInt(offset, 10) || 0) * 2 + 1 + l * 100) % l;
      inc = 2;
    }

    for (j = 0; j < l; j += 2) {
      s += a[i - 1] + "," + a[i] + " ";
      i = (i + inc) % l;
    }

    return s;
  },
      //adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.
  _equalizePointQuantity = function _equalizePointQuantity(a, quantity) {
    var tally = 0,
        x = parseFloat(a[0]),
        y = parseFloat(a[1]),
        s = x + "," + y + " ",
        max = 0.999999,
        newPointsPerSegment,
        i,
        l,
        j,
        factor,
        nextX,
        nextY;
    l = a.length;
    newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);

    for (i = 0; i < l - 2; i += 2) {
      tally += newPointsPerSegment;
      nextX = parseFloat(a[i + 2]);
      nextY = parseFloat(a[i + 3]);

      if (tally > max) {
        //compare with 0.99999 instead of 1 in order to prevent rounding errors
        factor = 1 / (Math.floor(tally) + 1);
        j = 1;

        while (tally > max) {
          s += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";
          tally--;
          j++;
        }
      }

      s += nextX + "," + nextY + " ";
      x = nextX;
      y = nextY;
    }

    return s;
  },
      _pointsFilter = function _pointsFilter(a) {
    var startNums = a[0].match(_numExp$1) || [],
        endNums = a[1].match(_numExp$1) || [],
        dif = endNums.length - startNums.length;

    if (dif > 0) {
      a[0] = _equalizePointQuantity(startNums, dif);
    } else {
      a[1] = _equalizePointQuantity(endNums, -dif);
    }
  },
      _buildPointsFilter = function _buildPointsFilter(shapeIndex) {
    return !isNaN(shapeIndex) ? function (a) {
      _pointsFilter(a);

      a[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));
    } : _pointsFilter;
  },
      _parseShape = function _parseShape(shape, forcePath, target) {
    var isString = typeof shape === "string",
        e,
        type;

    if (!isString || _selectorExp$1.test(shape) || (shape.match(_numExp$1) || []).length < 3) {
      e = _toArray(shape)[0];

      if (e) {
        type = (e.nodeName + "").toUpperCase();

        if (forcePath && type !== "PATH") {
          //if we were passed an element (or selector text for an element) that isn't a path, convert it.
          e = convertToPath(e, false);
          type = "PATH";
        }

        shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";

        if (e === target) {
          //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute
          shape = e.getAttributeNS(null, "data-original") || shape;
        }
      } else {
        _log("WARNING: invalid morph to: " + shape);

        shape = false;
      }
    }

    return shape;
  },
      //adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
  _populateSmoothData = function _populateSmoothData(rawPath, tolerance) {
    var j = rawPath.length,
        limit = 0.2 * (tolerance || 1),
        smooth,
        segment,
        x,
        y,
        x2,
        y2,
        i,
        l,
        a,
        a2,
        isSmooth,
        smoothData;

    while (--j > -1) {
      segment = rawPath[j];
      isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
      smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
      isSmooth.length = 4;
      l = segment.length - 2;

      for (i = 6; i < l; i += 6) {
        x = segment[i] - segment[i - 2];
        y = segment[i + 1] - segment[i - 1];
        x2 = segment[i + 2] - segment[i];
        y2 = segment[i + 3] - segment[i + 1];
        a = _atan2$1(y, x);
        a2 = _atan2$1(y2, x2);
        smooth = Math.abs(a - a2) < limit;

        if (smooth) {
          smoothData[i - 2] = a;
          smoothData[i + 2] = a2;
          smoothData[i - 1] = _sqrt$2(x * x + y * y);
          smoothData[i + 3] = _sqrt$2(x2 * x2 + y2 * y2);
        }

        isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
      } //if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.


      if (segment[l] === segment[0] && segment[l + 1] === segment[1]) {
        x = segment[0] - segment[l - 2];
        y = segment[1] - segment[l - 1];
        x2 = segment[2] - segment[0];
        y2 = segment[3] - segment[1];
        a = _atan2$1(y, x);
        a2 = _atan2$1(y2, x2);

        if (Math.abs(a - a2) < limit) {
          smoothData[l - 2] = a;
          smoothData[2] = a2;
          smoothData[l - 1] = _sqrt$2(x * x + y * y);
          smoothData[3] = _sqrt$2(x2 * x2 + y2 * y2);
          isSmooth[l - 2] = isSmooth[l - 1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
        }
      }
    }

    return rawPath;
  },
      _parseOriginFactors = function _parseOriginFactors(v) {
    var a = v.trim().split(" "),
        x = ~v.indexOf("left") ? 0 : ~v.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),
        y = ~v.indexOf("top") ? 0 : ~v.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);
    return {
      x: x / 100,
      y: y / 100
    };
  },
      _shortAngle = function _shortAngle(dif) {
    return dif !== dif % _PI ? dif + (dif < 0 ? _2PI$1 : -_2PI$1) : dif;
  },
      _morphMessage = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
      _tweenRotation = function _tweenRotation(start, end, i, linkedPT) {
    var so = this._origin,
        //starting origin
    eo = this._eOrigin,
        //ending origin
    dx = start[i] - so.x,
        dy = start[i + 1] - so.y,
        d = _sqrt$2(dx * dx + dy * dy),
        //length from starting origin to starting point
    sa = _atan2$1(dy, dx),
        angleDif,
        _short;

    dx = end[i] - eo.x;
    dy = end[i + 1] - eo.y;
    angleDif = _atan2$1(dy, dx) - sa;
    _short = _shortAngle(angleDif); //in the case of control points, we ALWAYS link them to their anchor so that they don't get torn apart and rotate the opposite direction. If it's not a control point, we look at the most recently linked point as long as they're within a certain rotational range of each other.

    if (!linkedPT && _lastLinkedAnchor && Math.abs(_short + _lastLinkedAnchor.ca) < _angleMin) {
      linkedPT = _lastLinkedAnchor;
    }

    return this._anchorPT = _lastLinkedAnchor = {
      _next: this._anchorPT,
      t: start,
      sa: sa,
      //starting angle
      ca: linkedPT && _short * linkedPT.ca < 0 && Math.abs(_short) > _angleMax ? angleDif : _short,
      //change in angle
      sl: d,
      //starting length
      cl: _sqrt$2(dx * dx + dy * dy) - d,
      //change in length
      i: i
    };
  },
      _initCore$1 = function _initCore(required) {
    gsap$1 = _getGSAP();
    PluginClass = PluginClass || gsap$1 && gsap$1.plugins.morphSVG;

    if (gsap$1 && PluginClass) {
      _toArray = gsap$1.utils.toArray;
      PluginClass.prototype._tweenRotation = _tweenRotation;
      _coreInitted$1 = 1;
    } else if (required) {
      _log("Please gsap.registerPlugin(MorphSVGPlugin)");
    }
  };

  var MorphSVGPlugin = {
    version: "3.4.0",
    name: "morphSVG",
    rawVars: 1,
    // otherwise "render" would be interpreted as a function-based value.
    register: function register(core, Plugin) {
      gsap$1 = core;
      PluginClass = Plugin;

      _initCore$1();
    },
    init: function init(target, value, tween, index, targets) {
      _coreInitted$1 || _initCore$1(1);

      if (!value) {
        _log("invalid shape");

        return false;
      }

      _isFunction$1(value) && (value = value.call(tween, index, target, targets));
      var type, p, pt, shape, isPoly, shapeIndex, map, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;

      if (typeof value === "string" || value.getBBox || value[0]) {
        value = {
          shape: value
        };
      } else if (typeof value === "object") {
        // if there are any function-based values, parse them here (and make a copy of the object so we're not modifying the original)
        type = {};

        for (p in value) {
          type[p] = _isFunction$1(value[p]) && p !== "render" ? value[p].call(tween, index, target, targets) : value[p];
        }

        value = type;
      }

      var cs = target.nodeType ? window.getComputedStyle(target) : {},
          fill = cs.fill + "",
          fillSafe = !(fill === "none" || (fill.match(_numExp$1) || [])[3] === "0" || cs.fillRule === "evenodd"),
          origins = (value.origin || "50 50").split(",");
      type = (target.nodeName + "").toUpperCase();
      isPoly = type === "POLYLINE" || type === "POLYGON";

      if (type !== "PATH" && !isPoly && !value.prop) {
        _log("Cannot morph a <" + type + "> element. " + _morphMessage);

        return false;
      }

      p = type === "PATH" ? "d" : "points";

      if (!value.prop && !_isFunction$1(target.setAttribute)) {
        return false;
      }

      shape = _parseShape(value.shape || value.d || value.points || "", p === "d", target);

      if (isPoly && _commands.test(shape)) {
        _log("A <" + type + "> cannot accept path data. " + _morphMessage);

        return false;
      }

      shapeIndex = value.shapeIndex || value.shapeIndex === 0 ? value.shapeIndex : "auto";
      map = value.map || MorphSVGPlugin.defaultMap;
      this._prop = value.prop;
      this._render = value.render || MorphSVGPlugin.defaultRender;
      this._apply = "updateTarget" in value ? value.updateTarget : MorphSVGPlugin.defaultUpdateTarget;
      this._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);
      this._tween = tween;

      if (shape) {
        this._target = target;
        precompiled = typeof value.precompile === "object";
        start = this._prop ? target[this._prop] : target.getAttribute(p);

        if (!this._prop && !target.getAttributeNS(null, "data-original")) {
          target.setAttributeNS(null, "data-original", start); //record the original state in a data-original attribute so that we can revert to it later.
        }

        if (p === "d" || this._prop) {
          start = stringToRawPath(precompiled ? value.precompile[0] : start);
          end = stringToRawPath(precompiled ? value.precompile[1] : shape);

          if (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe)) {
            return false; //malformed path data or null target
          }

          if (value.precompile === "log" || value.precompile === true) {
            _log('precompile:["' + rawPathToString(start) + '","' + rawPathToString(end) + '"]');
          }

          useRotation = (value.type || MorphSVGPlugin.defaultType) !== "linear";

          if (useRotation) {
            start = _populateSmoothData(start, value.smoothTolerance);
            end = _populateSmoothData(end, value.smoothTolerance);

            if (!start.size) {
              _getTotalSize(start); //adds top/left/width/height values

            }

            if (!end.size) {
              _getTotalSize(end);
            }

            originFactors = _parseOriginFactors(origins[0]);
            this._origin = start.origin = {
              x: start.left + originFactors.x * start.width,
              y: start.top + originFactors.y * start.height
            };

            if (origins[1]) {
              originFactors = _parseOriginFactors(origins[1]);
            }

            this._eOrigin = {
              x: end.left + originFactors.x * end.width,
              y: end.top + originFactors.y * end.height
            };
          }

          this._rawPath = target._gsRawPath = start;
          j = start.length;

          while (--j > -1) {
            startSeg = start[j];
            endSeg = end[j];
            startSmooth = startSeg.isSmooth || [];
            endSmooth = endSeg.isSmooth || [];
            l = startSeg.length;
            _lastLinkedAnchor = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don't get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)

            for (i = 0; i < l; i += 2) {
              if (endSeg[i] !== startSeg[i] || endSeg[i + 1] !== startSeg[i + 1]) {
                if (useRotation) {
                  if (startSmooth[i] && endSmooth[i]) {
                    //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).
                    sData = startSeg.smoothData;
                    eData = endSeg.smoothData;
                    offset = i + (i === l - 4 ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).

                    this._controlPT = {
                      _next: this._controlPT,
                      i: i,
                      j: j,
                      l1s: sData[i + 1],
                      l1c: eData[i + 1] - sData[i + 1],
                      l2s: sData[offset],
                      l2c: eData[offset] - sData[offset]
                    };
                    pt = this._tweenRotation(startSeg, endSeg, i + 2);

                    this._tweenRotation(startSeg, endSeg, i, pt);

                    this._tweenRotation(startSeg, endSeg, offset - 1, pt);

                    i += 4;
                  } else {
                    this._tweenRotation(startSeg, endSeg, i);
                  }
                } else {
                  pt = this.add(startSeg, i, startSeg[i], endSeg[i]);
                  pt = this.add(startSeg, i + 1, startSeg[i + 1], endSeg[i + 1]) || pt;
                }
              }
            }
          }
        } else {
          pt = this.add(target, "setAttribute", target.getAttribute(p) + "", shape + "", index, targets, 0, _buildPointsFilter(shapeIndex), p);
        }

        if (useRotation) {
          this.add(this._origin, "x", this._origin.x, this._eOrigin.x);
          pt = this.add(this._origin, "y", this._origin.y, this._eOrigin.y);
        }

        if (pt) {
          this._props.push("morphSVG");

          pt.end = shape;
          pt.endProp = p;
        }
      }

      return _bonusValidated;
    },
    render: function render(ratio, data) {
      var rawPath = data._rawPath,
          controlPT = data._controlPT,
          anchorPT = data._anchorPT,
          rnd = data._rnd,
          target = data._target,
          pt = data._pt,
          s,
          space,
          easeInOut,
          segment,
          l,
          angle,
          i,
          j,
          x,
          y,
          sin,
          cos,
          offset;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      if (ratio === 1 && data._apply) {
        pt = data._pt;

        while (pt) {
          if (pt.end) {
            if (data._prop) {
              target[data._prop] = pt.end;
            } else {
              target.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)
            }
          }

          pt = pt._next;
        }
      } else if (rawPath) {
        //rotationally position the anchors
        while (anchorPT) {
          angle = anchorPT.sa + ratio * anchorPT.ca;
          l = anchorPT.sl + ratio * anchorPT.cl; //length

          anchorPT.t[anchorPT.i] = data._origin.x + _cos$2(angle) * l;
          anchorPT.t[anchorPT.i + 1] = data._origin.y + _sin$2(angle) * l;
          anchorPT = anchorPT._next;
        } //smooth out the control points


        easeInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;

        while (controlPT) {
          i = controlPT.i;
          segment = rawPath[controlPT.j];
          offset = i + (i === segment.length - 4 ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.

          angle = _atan2$1(segment[offset] - segment[i + 1], segment[offset - 1] - segment[i]); //average the angles

          sin = _sin$2(angle);
          cos = _cos$2(angle);
          x = segment[i + 2];
          y = segment[i + 3];
          l = controlPT.l1s + easeInOut * controlPT.l1c; //length

          segment[i] = x - cos * l;
          segment[i + 1] = y - sin * l;
          l = controlPT.l2s + easeInOut * controlPT.l2c;
          segment[offset - 1] = x + cos * l;
          segment[offset] = y + sin * l;
          controlPT = controlPT._next;
        }

        target._gsRawPath = rawPath;

        if (data._apply) {
          s = "";
          space = " ";

          for (j = 0; j < rawPath.length; j++) {
            segment = rawPath[j];
            l = segment.length;
            s += "M" + (segment[0] * rnd | 0) / rnd + space + (segment[1] * rnd | 0) / rnd + " C";

            for (i = 2; i < l; i++) {
              //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places
              s += (segment[i] * rnd | 0) / rnd + space;
            }
          }

          if (data._prop) {
            target[data._prop] = s;
          } else {
            target.setAttribute("d", s);
          }
        }
      }

      data._render && rawPath && data._render.call(data._tween, rawPath, target);
    },
    kill: function kill(property) {
      this._pt = this._rawPath = 0;
    },
    getRawPath: getRawPath,
    stringToRawPath: stringToRawPath,
    rawPathToString: rawPathToString,
    pathFilter: _pathFilter,
    pointsFilter: _pointsFilter,
    getTotalSize: _getTotalSize,
    equalizeSegmentQuantity: _equalizeSegmentQuantity,
    convertToPath: function convertToPath$1(targets, swap) {
      return _toArray(targets).map(function (target) {
        return convertToPath(target, swap !== false);
      });
    },
    defaultType: "linear",
    defaultUpdateTarget: true,
    defaultMap: "size"
  };
  _getGSAP() && gsap$1.registerPlugin(MorphSVGPlugin);

  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap, // to protect from tree shaking
  	TweenMaxWithCSS = gsapWithCSS.core.Tween;

  /*!
   * paths 3.4.0
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /* eslint-disable */

  let _svgPathExp$1 = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
  	_numbersExp$1 = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
  	_scientific$1 = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
  	_selectorExp$2 = /(^[#\.][a-z]|[a-y][a-z])/i,
  	_DEG2RAD$2 = Math.PI / 180,
  	_sin$3 = Math.sin,
  	_cos$3 = Math.cos,
  	_abs$1 = Math.abs,
  	_sqrt$3 = Math.sqrt,
  	_isString$2 = value => typeof(value) === "string",
  	_isNumber$2 = value => typeof(value) === "number",
  	_roundingNum$1 = 1e5,
  	_round$2 = value => (Math.round(value * _roundingNum$1) / _roundingNum$1) || 0;

  /* TERMINOLOGY
   - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
   - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
   - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
   - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
   */

  //accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).
  function getRawPath$1(value) {
  	value = (_isString$2(value) && _selectorExp$2.test(value)) ? document.querySelector(value) || value : value;
  	let e = value.getAttribute ? value : 0,
  		rawPath;
  	if (e && (value = value.getAttribute("d"))) {
  		//implements caching
  		if (!e._gsPath) {
  			e._gsPath = {};
  		}
  		rawPath = e._gsPath[value];
  		return (rawPath && !rawPath._dirty) ? rawPath : (e._gsPath[value] = stringToRawPath$1(value));
  	}
  	return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString$2(value) ? stringToRawPath$1(value) : (_isNumber$2(value[0])) ? [value] : value;
  }

  function reverseSegment$1(segment) {
  	let i = 0,
  		y;
  	segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.
  	for (; i < segment.length; i += 2) {
  		y = segment[i];
  		segment[i] = segment[i+1];
  		segment[i+1] = y;
  	}
  	segment.reversed = !segment.reversed;
  }



  let _createPath$1 = (e, ignore) => {
  		let path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
  			attr = [].slice.call(e.attributes),
  			i = attr.length,
  			name;
  		ignore = "," + ignore + ",";
  		while (--i > -1) {
  			name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.
  			if (ignore.indexOf("," + name + ",") < 0) {
  				path.setAttributeNS(null, name, attr[i].nodeValue);
  			}
  		}
  		return path;
  	},
  	_typeAttrs$1 = {
  		rect:"rx,ry,x,y,width,height",
  		circle:"r,cx,cy",
  		ellipse:"rx,ry,cx,cy",
  		line:"x1,x2,y1,y2"
  	},
  	_attrToObj$1 = (e, attrs) => {
  		let props = attrs ? attrs.split(",") : [],
  			obj = {},
  			i = props.length;
  		while (--i > -1) {
  			obj[props[i]] = +e.getAttribute(props[i]) || 0;
  		}
  		return obj;
  	};

  //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.
  function convertToPath$1(element, swap) {
  	let type = element.tagName.toLowerCase(),
  		circ = 0.552284749831,
  		data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;
  	if (type === "path" || !element.getBBox) {
  		return element;
  	}
  	path = _createPath$1(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
  	attr = _attrToObj$1(element, _typeAttrs$1[type]);
  	if (type === "rect") {
  		r = attr.rx;
  		ry = attr.ry || r;
  		x = attr.x;
  		y = attr.y;
  		w = attr.width - r * 2;
  		h = attr.height - ry * 2;
  		if (r || ry) { //if there are rounded corners, render cubic beziers
  			x2 = x + r * (1 - circ);
  			x3 = x + r;
  			x4 = x3 + w;
  			x5 = x4 + r * circ;
  			x6 = x4 + r;
  			y2 = y + ry * (1 - circ);
  			y3 = y + ry;
  			y4 = y3 + h;
  			y5 = y4 + ry * circ;
  			y6 = y4 + ry;
  			data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
  		} else {
  			data = "M" + (x + w) + "," + y + " v" + h + " h" + (-w) + " v" + (-h) + " h" + w + "z";
  		}

  	} else if (type === "circle" || type === "ellipse") {
  		if (type === "circle") {
  			r = ry = attr.r;
  			rycirc = r * circ;
  		} else {
  			r = attr.rx;
  			ry = attr.ry;
  			rycirc = ry * circ;
  		}
  		x = attr.cx;
  		y = attr.cy;
  		rcirc = r * circ;
  		data = "M" + (x+r) + "," + y + " C" + [x+r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
  	} else if (type === "line") {
  		data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
  	} else if (type === "polyline" || type === "polygon") {
  		points = (element.getAttribute("points") + "").match(_numbersExp$1) || [];
  		x = points.shift();
  		y = points.shift();
  		data = "M" + x + "," + y + " L" + points.join(",");
  		if (type === "polygon") {
  			data += "," + x + "," + y + "z";
  		}
  	}
  	path.setAttribute("d", rawPathToString$1(path._gsRawPath = stringToRawPath$1(data)));
  	if (swap && element.parentNode) {
  		element.parentNode.insertBefore(path, element);
  		element.parentNode.removeChild(element);
  	}
  	return path;
  }



  //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).
  function transformRawPath(rawPath, a, b, c, d, tx, ty) {
  	let j = rawPath.length,
  		segment, l, i, x, y;
  	while (--j > -1) {
  		segment = rawPath[j];
  		l = segment.length;
  		for (i = 0; i < l; i += 2) {
  			x = segment[i];
  			y = segment[i+1];
  			segment[i] = x * a + y * c + tx;
  			segment[i+1] = x * b + y * d + ty;
  		}
  	}
  	rawPath._dirty = 1;
  	return rawPath;
  }



  // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.
  function arcToSegment$1(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  	if (lastX === x && lastY === y) {
  		return;
  	}
  	rx = _abs$1(rx);
  	ry = _abs$1(ry);
  	let angleRad = (angle % 360) * _DEG2RAD$2,
  		cosAngle = _cos$3(angleRad),
  		sinAngle = _sin$3(angleRad),
  		PI = Math.PI,
  		TWOPI = PI * 2,
  		dx2 = (lastX - x) / 2,
  		dy2 = (lastY - y) / 2,
  		x1 = (cosAngle * dx2 + sinAngle * dy2),
  		y1 = (-sinAngle * dx2 + cosAngle * dy2),
  		x1_sq = x1 * x1,
  		y1_sq = y1 * y1,
  		radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
  	if (radiiCheck > 1) {
  		rx = _sqrt$3(radiiCheck) * rx;
  		ry = _sqrt$3(radiiCheck) * ry;
  	}
  	let rx_sq = rx * rx,
  		ry_sq = ry * ry,
  		sq = ((rx_sq * ry_sq) - (rx_sq * y1_sq) - (ry_sq * x1_sq)) / ((rx_sq * y1_sq) + (ry_sq * x1_sq));
  	if (sq < 0) {
  		sq = 0;
  	}
  	let coef = ((largeArcFlag === sweepFlag) ? -1 : 1) * _sqrt$3(sq),
  		cx1 = coef * ((rx * y1) / ry),
  		cy1 = coef * -((ry * x1) / rx),
  		sx2 = (lastX + x) / 2,
  		sy2 = (lastY + y) / 2,
  		cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
  		cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
  		ux = (x1 - cx1) / rx,
  		uy = (y1 - cy1) / ry,
  		vx = (-x1 - cx1) / rx,
  		vy = (-y1 - cy1) / ry,
  		temp = ux * ux + uy * uy,
  		angleStart = ((uy < 0) ? -1 : 1) * Math.acos(ux / _sqrt$3(temp)),
  		angleExtent = ((ux * vy - uy * vx < 0) ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt$3(temp * (vx * vx + vy * vy)));
  	isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.
  	if (!sweepFlag && angleExtent > 0) {
  		angleExtent -= TWOPI;
  	} else if (sweepFlag && angleExtent < 0) {
  		angleExtent += TWOPI;
  	}
  	angleStart %= TWOPI;
  	angleExtent %= TWOPI;
  	let segments = Math.ceil(_abs$1(angleExtent) / (TWOPI / 4)),
  		rawPath = [],
  		angleIncrement = angleExtent / segments,
  		controlLength = 4 / 3 * _sin$3(angleIncrement / 2) / (1 + _cos$3(angleIncrement / 2)),
  		ma = cosAngle * rx,
  		mb = sinAngle * rx,
  		mc = sinAngle * -ry,
  		md = cosAngle * ry,
  		i;
  	for (i = 0; i < segments; i++) {
  		angle = angleStart + i * angleIncrement;
  		x1 = _cos$3(angle);
  		y1 = _sin$3(angle);
  		ux = _cos$3(angle += angleIncrement);
  		uy = _sin$3(angle);
  		rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
  	}
  	//now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).
  	for (i = 0; i < rawPath.length; i+=2) {
  		x1 = rawPath[i];
  		y1 = rawPath[i+1];
  		rawPath[i] = x1 * ma + y1 * mc + cx;
  		rawPath[i+1] = x1 * mb + y1 * md + cy;
  	}
  	rawPath[i-2] = x; //always set the end to exactly where it's supposed to be
  	rawPath[i-1] = y;
  	return rawPath;
  }

  //Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.
  function stringToRawPath$1(d) {
  	let a = (d + "").replace(_scientific$1, m => { let n = +m; return (n < 0.0001 && n > -0.0001) ? 0 : n; }).match(_svgPathExp$1) || [], //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
  		path = [],
  		relativeX = 0,
  		relativeY = 0,
  		twoThirds = 2 / 3,
  		elements = a.length,
  		points = 0,
  		errorMessage = "ERROR: malformed path: " + d,
  		i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2,
  		line = function(sx, sy, ex, ey) {
  			difX = (ex - sx) / 3;
  			difY = (ey - sy) / 3;
  			segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
  		};
  	if (!d || !isNaN(a[0]) || isNaN(a[1])) {
  		console.log(errorMessage);
  		return path;
  	}
  	for (i = 0; i < elements; i++) {
  		prevCommand = command;
  		if (isNaN(a[i])) {
  			command = a[i].toUpperCase();
  			isRelative = (command !== a[i]); //lower case means relative
  		} else { //commands like "C" can be strung together without any new command characters between.
  			i--;
  		}
  		x = +a[i + 1];
  		y = +a[i + 2];
  		if (isRelative) {
  			x += relativeX;
  			y += relativeY;
  		}
  		if (!i) {
  			startX = x;
  			startY = y;
  		}

  		// "M" (move)
  		if (command === "M") {
  			if (segment) {
  				if (segment.length < 8) { //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
  					path.length -= 1;
  				} else {
  					points += segment.length;
  				}
  			}
  			relativeX = startX = x;
  			relativeY = startY = y;
  			segment = [x, y];
  			path.push(segment);
  			i += 2;
  			command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").

  		// "C" (cubic bezier)
  		} else if (command === "C") {
  			if (!segment) {
  				segment = [0, 0];
  			}
  			if (!isRelative) {
  				relativeX = relativeY = 0;
  			}
  			//note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.
  			segment.push(x,	y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, (relativeX += a[i + 5] * 1),	(relativeY += a[i + 6] * 1));
  			i += 6;

  		// "S" (continuation of cubic bezier)
  		} else if (command === "S") {
  			difX = relativeX;
  			difY = relativeY;
  			if (prevCommand === "C" || prevCommand === "S") {
  				difX += relativeX - segment[segment.length - 4];
  				difY += relativeY - segment[segment.length - 3];
  			}
  			if (!isRelative) {
  				relativeX = relativeY = 0;
  			}
  			segment.push(difX, difY, x,	y, (relativeX += a[i + 3] * 1), (relativeY += a[i + 4] * 1));
  			i += 4;

  		// "Q" (quadratic bezier)
  		} else if (command === "Q") {
  			difX = relativeX + (x - relativeX) * twoThirds;
  			difY = relativeY + (y - relativeY) * twoThirds;
  			if (!isRelative) {
  				relativeX = relativeY = 0;
  			}
  			relativeX += a[i + 3] * 1;
  			relativeY += a[i + 4] * 1;
  			segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
  			i += 4;

  		// "T" (continuation of quadratic bezier)
  		} else if (command === "T") {
  			difX = relativeX - segment[segment.length - 4];
  			difY = relativeY - segment[segment.length - 3];
  			segment.push(relativeX + difX, relativeY + difY, x + ((relativeX + difX * 1.5) - x) * twoThirds, y + ((relativeY + difY * 1.5) - y) * twoThirds, (relativeX = x), (relativeY = y));
  			i += 2;

  		// "H" (horizontal line)
  		} else if (command === "H") {
  			line(relativeX, relativeY, (relativeX = x), relativeY);
  			i += 1;

  		// "V" (vertical line)
  		} else if (command === "V") {
  			//adjust values because the first (and only one) isn't x in this case, it's y.
  			line(relativeX, relativeY, relativeX, (relativeY = x + (isRelative ? relativeY - relativeX : 0)));
  			i += 1;

  		// "L" (line) or "Z" (close)
  		} else if (command === "L" || command === "Z") {
  			if (command === "Z") {
  				x = startX;
  				y = startY;
  				segment.closed = true;
  			}
  			if (command === "L" || _abs$1(relativeX - x) > 0.5 || _abs$1(relativeY - y) > 0.5) {
  				line(relativeX, relativeY, x, y);
  				if (command === "L") {
  					i += 2;
  				}
  			}
  			relativeX = x;
  			relativeY = y;

  		// "A" (arc)
  		} else if (command === "A") {
  			flag1 = a[i+4];
  			flag2 = a[i+5];
  			difX = a[i+6];
  			difY = a[i+7];
  			j = 7;
  			if (flag1.length > 1) { // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
  				if (flag1.length < 3) {
  					difY = difX;
  					difX = flag2;
  					j--;
  				} else {
  					difY = flag2;
  					difX = flag1.substr(2);
  					j-=2;
  				}
  				flag2 = flag1.charAt(1);
  				flag1 = flag1.charAt(0);
  			}
  			beziers = arcToSegment$1(relativeX, relativeY, +a[i+1], +a[i+2], +a[i+3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX*1, (isRelative ? relativeY : 0) + difY*1);
  			i += j;
  			if (beziers) {
  				for (j = 0; j < beziers.length; j++) {
  					segment.push(beziers[j]);
  				}
  			}
  			relativeX = segment[segment.length-2];
  			relativeY = segment[segment.length-1];

  		} else {
  			console.log(errorMessage);
  		}
  	}
  	i = segment.length;
  	if (i < 6) { //in case there's odd SVG like a M0,0 command at the very end.
  		path.pop();
  		i = 0;
  	} else if (segment[0] === segment[i-2] && segment[1] === segment[i-1]) {
  		segment.closed = true;
  	}
  	path.totalPoints = points + i;
  	return path;
  }

  /*
  Takes any of the following and converts it to an all Cubic Bezier SVG data string:
  - A <path> data string like "M0,0 L2,4 v20,15 H100"
  - A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
  - A Segment, like [x, y, x, y, x, y, x, y]

  Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
  */
  function rawPathToString$1(rawPath) {
  	if (_isNumber$2(rawPath[0])) { //in case a segment is passed in instead
  		rawPath = [rawPath];
  	}
  	let result = "",
  		l = rawPath.length,
  		sl, s, i, segment;
  	for (s = 0; s < l; s++) {
  		segment = rawPath[s];
  		result += "M" + _round$2(segment[0]) + "," + _round$2(segment[1]) + " C";
  		sl = segment.length;
  		for (i = 2; i < sl; i++) {
  			result += _round$2(segment[i++]) + "," + _round$2(segment[i++]) + " " + _round$2(segment[i++]) + "," + _round$2(segment[i++]) + " " + _round$2(segment[i++]) + "," + _round$2(segment[i]) + " ";
  		}
  		if (segment.closed) {
  			result += "z";
  		}
  	}
  	return result;
  }

  /*
  // takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
  export function cpCoordsToAngles(segment, copy) {
  	var result = copy ? segment.slice(0) : segment,
  		x, y, i;
  	for (i = 0; i < segment.length; i+=6) {
  		x = segment[i+2] - segment[i];
  		y = segment[i+3] - segment[i+1];
  		result[i+2] = Math.atan2(y, x);
  		result[i+3] = Math.sqrt(x * x + y * y);
  		x = segment[i+6] - segment[i+4];
  		y = segment[i+7] - segment[i+5];
  		result[i+4] = Math.atan2(y, x);
  		result[i+5] = Math.sqrt(x * x + y * y);
  	}
  	return result;
  }

  // takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
  export function cpAnglesToCoords(segment, copy) {
  	var result = copy ? segment.slice(0) : segment,
  		length = segment.length,
  		rnd = 1000,
  		angle, l, i, j;
  	for (i = 0; i < length; i+=6) {
  		angle = segment[i+2];
  		l = segment[i+3]; //length
  		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
  		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
  		angle = segment[i+4];
  		l = segment[i+5]; //length
  		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
  		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
  	}
  	return result;
  }

  //adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
  export function populateSmoothData(rawPath) {
  	let j = rawPath.length,
  		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
  	while (--j > -1) {
  		segment = rawPath[j];
  		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
  		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
  		isSmooth.length = 4;
  		l = segment.length - 2;
  		for (i = 6; i < l; i += 6) {
  			x = segment[i] - segment[i - 2];
  			y = segment[i + 1] - segment[i - 1];
  			x2 = segment[i + 2] - segment[i];
  			y2 = segment[i + 3] - segment[i + 1];
  			a = _atan2(y, x);
  			a2 = _atan2(y2, x2);
  			smooth = (Math.abs(a - a2) < 0.09);
  			if (smooth) {
  				smoothData[i - 2] = a;
  				smoothData[i + 2] = a2;
  				smoothData[i - 1] = _sqrt(x * x + y * y);
  				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
  			}
  			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
  		}
  		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
  		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
  			x = segment[0] - segment[l-2];
  			y = segment[1] - segment[l-1];
  			x2 = segment[2] - segment[0];
  			y2 = segment[3] - segment[1];
  			a = _atan2(y, x);
  			a2 = _atan2(y2, x2);
  			if (Math.abs(a - a2) < 0.09) {
  				smoothData[l-2] = a;
  				smoothData[2] = a2;
  				smoothData[l-1] = _sqrt(x * x + y * y);
  				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
  				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
  			}
  		}
  	}
  	return rawPath;
  }
  export function pointToScreen(svgElement, point) {
  	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
  		let rawPath = getRawPath(svgElement);
  		point = svgElement.ownerSVGElement.createSVGPoint();
  		point.x = rawPath[0][0];
  		point.y = rawPath[0][1];
  	}
  	return point.matrixTransform(svgElement.getScreenCTM());
  }

  */

  /*!
   * MorphSVGPlugin 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  let gsap$2, _toArray$1, _lastLinkedAnchor$1, _coreInitted$2, PluginClass$1,
  	_getGSAP$1 = () => gsap$2 || (typeof(window) !== "undefined" && (gsap$2 = window.gsap) && gsap$2.registerPlugin && gsap$2),
  	_isFunction$2 = value => typeof(value) === "function",
  	_atan2$2 = Math.atan2,
  	_cos$4 = Math.cos,
  	_sin$4 = Math.sin,
  	_sqrt$4 = Math.sqrt,
  	_PI$1 = Math.PI,
  	_2PI$2 = _PI$1 * 2,
  	_angleMin$1 = _PI$1 * 0.3,
  	_angleMax$1 = _PI$1 * 0.7,
  	_bigNum$3 = 1e20,
  	_numExp$2 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  	_selectorExp$3 = /(^[#\.][a-z]|[a-y][a-z])/gi,
  	_commands$1 = /[achlmqstvz]/ig,
  	_log$1 = message => console && console.warn(message),
  	_bonusValidated$1 = 1, //<name>MorphSVGPlugin</name>
  	_getAverageXY$1 = segment => {
  		let l = segment.length,
  			x = 0,
  			y = 0,
  			i;
  		for (i = 0; i < l; i++) {
  			x += segment[i++];
  			y += segment[i];
  		}
  		return [x / (l / 2), y / (l / 2)];
  	},
  	_getSize$1 = segment => { //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)
  		let l = segment.length,
  			xMax = segment[0],
  			xMin = xMax,
  			yMax = segment[1],
  			yMin = yMax,
  			x, y, i;
  		for (i = 6; i < l; i+=6) {
  			x = segment[i];
  			y = segment[i+1];
  			if (x > xMax) {
  				xMax = x;
  			} else if (x < xMin) {
  				xMin = x;
  			}
  			if (y > yMax) {
  				yMax = y;
  			} else if (y < yMin) {
  				yMin = y;
  			}
  		}
  		segment.centerX = (xMax + xMin) / 2;
  		segment.centerY = (yMax + yMin) / 2;
  		return (segment.size = (xMax - xMin) * (yMax - yMin));
  	},
  	_getTotalSize$1 = (rawPath, samplesPerBezier = 3) => { //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)
  		let j = rawPath.length,
  			xMax = rawPath[0][0],
  			xMin = xMax,
  			yMax = rawPath[0][1],
  			yMin = yMax,
  			inc = 1 / samplesPerBezier,
  			l, x, y, i, segment, k, t, inv, x1, y1, x2, x3, x4, y2, y3, y4;
  		while (--j > -1) {
  			segment = rawPath[j];
  			l = segment.length;
  			for (i = 6; i < l; i+=6) {
  				x1 = segment[i];
  				y1 = segment[i+1];
  				x2 = segment[i+2] - x1;
  				y2 = segment[i+3] - y1;
  				x3 = segment[i+4] - x1;
  				y3 = segment[i+5] - y1;
  				x4 = segment[i+6] - x1;
  				y4 = segment[i+7] - y1;
  				k = samplesPerBezier;
  				while (--k > -1) {
  					t = inc * k;
  					inv = 1 - t;
  					x = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;
  					y = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;
  					if (x > xMax) {
  						xMax = x;
  					} else if (x < xMin) {
  						xMin = x;
  					}
  					if (y > yMax) {
  						yMax = y;
  					} else if (y < yMin) {
  						yMin = y;
  					}
  				}
  			}
  		}
  		rawPath.centerX = (xMax + xMin) / 2;
  		rawPath.centerY = (yMax + yMin) / 2;
  		rawPath.left = xMin;
  		rawPath.width = (xMax - xMin);
  		rawPath.top = yMin;
  		rawPath.height = (yMax - yMin);
  		return (rawPath.size = (xMax - xMin) * (yMax - yMin));
  	},
  	_sortByComplexity$1 = (a, b) => b.length - a.length,
  	_sortBySize$1 = (a, b) => {
  		let sizeA = a.size || _getSize$1(a),
  			sizeB = b.size || _getSize$1(b);
  		return (Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20) ? (b.centerX - a.centerX) || (b.centerY - a.centerY) : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.
  	},
  	_offsetSegment$1 = (segment, shapeIndex) => {
  		let a = segment.slice(0),
  			l = segment.length,
  			wrap = l - 2,
  			i, index;
  		shapeIndex = shapeIndex | 0;
  		for (i = 0; i < l; i++) {
  			index = (i + shapeIndex) % wrap;
  			segment[i++] = a[index];
  			segment[i] = a[index+1];
  		}
  	},
  	_getTotalMovement$1 = (sb, eb, shapeIndex, offsetX, offsetY) => {
  		let l = sb.length,
  			d = 0,
  			wrap = l - 2,
  			index, i, x, y;
  		shapeIndex *= 6;
  		for (i = 0; i < l; i += 6) {
  			index = (i + shapeIndex) % wrap;
  			y = sb[index] - (eb[i] - offsetX);
  			x = sb[index+1] - (eb[i+1] - offsetY);
  			d += _sqrt$4(x * x + y * y);
  		}
  		return d;
  	},
  	_getClosestShapeIndex$1 = (sb, eb, checkReverse) => { //finds the index in a closed cubic bezier array that's closest to the angle provided (angle measured from the center or average x/y).
  		let l = sb.length,
  			sCenter = _getAverageXY$1(sb), //when comparing distances, adjust the coordinates as if the shapes are centered with each other.
  			eCenter = _getAverageXY$1(eb),
  			offsetX = eCenter[0] - sCenter[0],
  			offsetY = eCenter[1] - sCenter[1],
  			min = _getTotalMovement$1(sb, eb, 0, offsetX, offsetY),
  			minIndex = 0,
  			copy, d, i;
  		for (i = 6; i < l; i += 6) {
  			d = _getTotalMovement$1(sb, eb, i / 6, offsetX, offsetY);
  			if (d < min) {
  				min = d;
  				minIndex = i;
  			}
  		}
  		if (checkReverse) {
  			copy = sb.slice(0);
  			reverseSegment$1(copy);
  			for (i = 6; i < l; i += 6) {
  				d = _getTotalMovement$1(copy, eb, i / 6, offsetX, offsetY);
  				if (d < min) {
  					min = d;
  					minIndex = -i;
  				}
  			}
  		}
  		return minIndex / 6;
  	},
  	_getClosestAnchor$1 = (rawPath, x, y) => { //finds the x/y of the anchor that's closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.
  		let j = rawPath.length,
  			closestDistance = _bigNum$3,
  			closestX = 0,
  			closestY = 0,
  			segment, dx, dy, d, i, l;
  		while (--j > -1) {
  			segment = rawPath[j];
  			l = segment.length;
  			for (i = 0; i < l; i += 6) {
  				dx = segment[i] - x;
  				dy = segment[i+1] - y;
  				d = _sqrt$4(dx * dx + dy * dy);
  				if (d < closestDistance) {
  					closestDistance = d;
  					closestX = segment[i];
  					closestY = segment[i+1];
  				}
  			}
  		}
  		return [closestX, closestY];
  	},
  	_getClosestSegment$1 = (bezier, pool, startIndex, sortRatio, offsetX, offsetY) => { //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn't drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.
  		let l = pool.length,
  			index = 0,
  			minSize = Math.min(bezier.size || _getSize$1(bezier), pool[startIndex].size || _getSize$1(pool[startIndex])) * sortRatio, //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.
  			min = _bigNum$3,
  			cx = bezier.centerX + offsetX,
  			cy = bezier.centerY + offsetY,
  			size, i, dx, dy, d;
  		for (i = startIndex; i < l; i++) {
  			size = pool[i].size || _getSize$1(pool[i]);
  			if (size < minSize) {
  				break;
  			}
  			dx = pool[i].centerX - cx;
  			dy = pool[i].centerY - cy;
  			d = _sqrt$4(dx * dx + dy * dy);
  			if (d < min) {
  				index = i;
  				min = d;
  			}
  		}
  		d = pool[index];
  		pool.splice(index, 1);
  		return d;
  	},
  	_subdivideSegmentQty$1 = (segment, quantity) => {
  		let tally = 0,
  			max = 0.999999,
  			l = segment.length,
  			newPointsPerSegment = quantity / ((l - 2) / 6),
  			ax, ay, cp1x, cp1y, cp2x, cp2y, bx, by,
  			x1, y1, x2, y2, i, t;
  		for (i = 2; i < l; i += 6) {
  			tally += newPointsPerSegment;
  			while (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors
  				ax = segment[i-2];
  				ay = segment[i-1];
  				cp1x = segment[i];
  				cp1y = segment[i+1];
  				cp2x = segment[i+2];
  				cp2y = segment[i+3];
  				bx = segment[i+4];
  				by = segment[i+5];
  				t = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)
  				x1 = ax + (cp1x - ax) * t;
  				x2 = cp1x + (cp2x - cp1x) * t;
  				x1 += (x2 - x1) * t;
  				x2 += ((cp2x + (bx - cp2x) * t) - x2) * t;
  				y1 = ay + (cp1y - ay) * t;
  				y2 = cp1y + (cp2y - cp1y) * t;
  				y1 += (y2 - y1) * t;
  				y2 += ((cp2y + (by - cp2y) * t) - y2) * t;
  				segment.splice(i, 4,
  					ax + (cp1x - ax) * t,   //first control point
  					ay + (cp1y - ay) * t,
  					x1,                     //second control point
  					y1,
  					x1 + (x2 - x1) * t,     //new fabricated anchor on line
  					y1 + (y2 - y1) * t,
  					x2,                     //third control point
  					y2,
  					cp2x + (bx - cp2x) * t, //fourth control point
  					cp2y + (by - cp2y) * t
  				);
  				i += 6;
  				l += 6;
  				tally--;
  			}
  		}
  		return segment;
  	},
  	_equalizeSegmentQuantity$1 = (start, end, shapeIndex, map, fillSafe) => { //returns an array of shape indexes, 1 for each segment.
  		let dif = end.length - start.length,
  			longer = dif > 0 ? end : start,
  			shorter = dif > 0 ? start : end,
  			added = 0,
  			sortMethod = (map === "complexity") ? _sortByComplexity$1 : _sortBySize$1,
  			sortRatio = (map === "position") ? 0 : (typeof(map) === "number") ? map : 0.8,
  			i = shorter.length,
  			shapeIndices = (typeof(shapeIndex) === "object" && shapeIndex.push) ? shapeIndex.slice(0) : [shapeIndex],
  			reverse = (shapeIndices[0] === "reverse" || shapeIndices[0] < 0),
  			log = (shapeIndex === "log"),
  			eb, sb, b, x, y, offsetX, offsetY;
  		if (!shorter[0]) {
  			return;
  		}
  		if (longer.length > 1) {
  			start.sort(sortMethod);
  			end.sort(sortMethod);
  			offsetX = longer.size || _getTotalSize$1(longer); //ensures centerX and centerY are defined (used below).
  			offsetX = shorter.size || _getTotalSize$1(shorter);
  			offsetX = longer.centerX - shorter.centerX;
  			offsetY = longer.centerY - shorter.centerY;
  			if (sortMethod === _sortBySize$1) {
  				for (i = 0; i < shorter.length; i++) {
  					longer.splice(i, 0, _getClosestSegment$1(shorter[i], longer, i, sortRatio, offsetX, offsetY));
  				}
  			}
  		}
  		if (dif) {
  			if (dif < 0) {
  				dif = -dif;
  			}
  			if (longer[0].length > shorter[0].length) { //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)
  				_subdivideSegmentQty$1(shorter[0], ((longer[0].length - shorter[0].length)/6) | 0);
  			}
  			i = shorter.length;
  			while (added < dif) {
  				x = longer[i].size || _getSize$1(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.
  				b = _getClosestAnchor$1(shorter, longer[i].centerX, longer[i].centerY);
  				x = b[0];
  				y = b[1];
  				shorter[i++] = [x, y, x, y, x, y, x, y];
  				shorter.totalPoints += 8;
  				added++;
  			}
  		}
  		for (i = 0; i < start.length; i++) {
  			eb = end[i];
  			sb = start[i];
  			dif = eb.length - sb.length;
  			if (dif < 0) {
  				_subdivideSegmentQty$1(eb, (-dif/6) | 0);
  			} else if (dif > 0) {
  				_subdivideSegmentQty$1(sb, (dif/6) | 0);
  			}
  			if (reverse && fillSafe !== false && !sb.reversed) {
  				reverseSegment$1(sb);
  			}
  			shapeIndex = (shapeIndices[i] || shapeIndices[i] === 0) ? shapeIndices[i] : "auto";
  			if (shapeIndex) {
  				//if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.
  				if (sb.closed || (Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5)) {
  					if (shapeIndex === "auto" || shapeIndex === "log") {
  						shapeIndices[i] = shapeIndex = _getClosestShapeIndex$1(sb, eb, (!i || fillSafe === false));
  						if (shapeIndex < 0) {
  							reverse = true;
  							reverseSegment$1(sb);
  							shapeIndex = -shapeIndex;
  						}
  						_offsetSegment$1(sb, shapeIndex * 6);

  					} else if (shapeIndex !== "reverse") {
  						if (i && shapeIndex < 0) { //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.
  							reverseSegment$1(sb);
  						}
  						_offsetSegment$1(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);
  					}
  					//otherwise, if it's not a closed shape, consider reversing it if that would make the overall travel less
  				} else if (!reverse && (shapeIndex === "auto" && (Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1])) || (shapeIndex % 2))) {
  					reverseSegment$1(sb);
  					shapeIndices[i] = -1;
  					reverse = true;
  				} else if (shapeIndex === "auto") {
  					shapeIndices[i] = 0;
  				} else if (shapeIndex === "reverse") {
  					shapeIndices[i] = -1;
  				}
  				if (sb.closed !== eb.closed) { //if one is closed and one isn't, don't close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)
  					sb.closed = eb.closed = false;
  				}
  			}
  		}
  		if (log) {
  			_log$1("shapeIndex:[" + shapeIndices.join(",") + "]");
  		}
  		start.shapeIndex = shapeIndices;
  		return shapeIndices;
  	},
  	_pathFilter$1 = (a, shapeIndex, map, precompile, fillSafe) => {
  		let start = stringToRawPath$1(a[0]),
  			end = stringToRawPath$1(a[1]);
  		if (!_equalizeSegmentQuantity$1(start, end, (shapeIndex || shapeIndex === 0) ? shapeIndex : "auto", map, fillSafe)) {
  			return; //malformed path data or null target
  		}
  		a[0] = rawPathToString$1(start);
  		a[1] = rawPathToString$1(end);
  		if (precompile === "log" || precompile === true) {
  			_log$1('precompile:["' + a[0] + '","' + a[1] + '"]');
  		}
  	},
  	_offsetPoints$1 = (text, offset) => {
  		if (!offset) {
  			return text;
  		}
  		let a = text.match(_numExp$2) || [],
  			l = a.length,
  			s = "",
  			inc, i, j;
  		if (offset === "reverse") {
  			i = l-1;
  			inc = -2;
  		} else {
  			i = (((parseInt(offset, 10) || 0) * 2 + 1) + l * 100) % l;
  			inc = 2;
  		}
  		for (j = 0; j < l; j += 2) {
  			s += a[i-1] + "," + a[i] + " ";
  			i = (i + inc) % l;
  		}
  		return s;
  	},
  	//adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.
  	_equalizePointQuantity$1 = (a, quantity) => {
  		let tally = 0,
  			x = parseFloat(a[0]),
  			y = parseFloat(a[1]),
  			s = x + "," + y + " ",
  			max = 0.999999,
  			newPointsPerSegment, i, l, j, factor, nextX, nextY;
  		l = a.length;
  		newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);
  		for (i = 0; i < l-2; i += 2) {
  			tally += newPointsPerSegment;
  			nextX = parseFloat(a[i+2]);
  			nextY = parseFloat(a[i+3]);
  			if (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors
  				factor = 1 / (Math.floor(tally) + 1);
  				j = 1;
  				while (tally > max) {
  					s += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";
  					tally--;
  					j++;
  				}
  			}
  			s += nextX + "," + nextY + " ";
  			x = nextX;
  			y = nextY;
  		}
  		return s;
  	},
  	_pointsFilter$1 = a => {
  		let startNums = a[0].match(_numExp$2) || [],
  			endNums = a[1].match(_numExp$2) || [],
  			dif = endNums.length - startNums.length;
  		if (dif > 0) {
  			a[0] = _equalizePointQuantity$1(startNums, dif);
  		} else {
  			a[1] = _equalizePointQuantity$1(endNums, -dif);
  		}
  	},
  	_buildPointsFilter$1 = shapeIndex => !isNaN(shapeIndex) ? a => {
  			_pointsFilter$1(a);
  			a[1] = _offsetPoints$1(a[1], parseInt(shapeIndex, 10));
  		} : _pointsFilter$1,
  	_parseShape$1 = (shape, forcePath, target) => {
  		let isString = typeof(shape) === "string",
  			e, type;
  		if (!isString || _selectorExp$3.test(shape) || (shape.match(_numExp$2) || []).length < 3) {
  			e = _toArray$1(shape)[0];
  			if (e) {
  				type = (e.nodeName + "").toUpperCase();
  				if (forcePath && type !== "PATH") { //if we were passed an element (or selector text for an element) that isn't a path, convert it.
  					e = convertToPath$1(e, false);
  					type = "PATH";
  				}
  				shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";
  				if (e === target) { //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute
  					shape = e.getAttributeNS(null, "data-original") || shape;
  				}
  			} else {
  				_log$1("WARNING: invalid morph to: " + shape);
  				shape = false;
  			}
  		}
  		return shape;
  	},
  	//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
  	_populateSmoothData$1 = (rawPath, tolerance) => {
  		let j = rawPath.length,
  			limit = 0.2 * (tolerance || 1),
  			smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
  		while (--j > -1) {
  			segment = rawPath[j];
  			isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
  			smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
  			isSmooth.length = 4;
  			l = segment.length - 2;
  			for (i = 6; i < l; i += 6) {
  				x = segment[i] - segment[i - 2];
  				y = segment[i + 1] - segment[i - 1];
  				x2 = segment[i + 2] - segment[i];
  				y2 = segment[i + 3] - segment[i + 1];
  				a = _atan2$2(y, x);
  				a2 = _atan2$2(y2, x2);
  				smooth = (Math.abs(a - a2) < limit);
  				if (smooth) {
  					smoothData[i - 2] = a;
  					smoothData[i + 2] = a2;
  					smoothData[i - 1] = _sqrt$4(x * x + y * y);
  					smoothData[i + 3] = _sqrt$4(x2 * x2 + y2 * y2);
  				}
  				isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
  			}
  			//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
  			if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
  				x = segment[0] - segment[l-2];
  				y = segment[1] - segment[l-1];
  				x2 = segment[2] - segment[0];
  				y2 = segment[3] - segment[1];
  				a = _atan2$2(y, x);
  				a2 = _atan2$2(y2, x2);
  				if (Math.abs(a - a2) < limit) {
  					smoothData[l-2] = a;
  					smoothData[2] = a2;
  					smoothData[l-1] = _sqrt$4(x * x + y * y);
  					smoothData[3] = _sqrt$4(x2 * x2 + y2 * y2);
  					isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
  				}
  			}
  		}
  		return rawPath;
  	},
  	_parseOriginFactors$1 = v => {
  		let a = v.trim().split(" "),
  			x = ~v.indexOf("left") ? 0 : ~v.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),
  			y = ~v.indexOf("top") ? 0 : ~v.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);
  		return {x:x / 100, y:y / 100};
  	},
  	_shortAngle$1 = dif => (dif !== dif % _PI$1) ? dif + ((dif < 0) ? _2PI$2 : -_2PI$2) : dif,
  	_morphMessage$1 = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
  	_tweenRotation$1 = function(start, end, i, linkedPT) {
  		let so = this._origin,              //starting origin
  			eo = this._eOrigin,             //ending origin
  			dx = start[i] - so.x,
  			dy = start[i+1] - so.y,
  			d = _sqrt$4(dx * dx + dy * dy),   //length from starting origin to starting point
  			sa = _atan2$2(dy, dx),
  			angleDif, short;
  		dx = end[i] - eo.x;
  		dy = end[i+1] - eo.y;
  		angleDif = _atan2$2(dy, dx) - sa;
  		short = _shortAngle$1(angleDif);
  		//in the case of control points, we ALWAYS link them to their anchor so that they don't get torn apart and rotate the opposite direction. If it's not a control point, we look at the most recently linked point as long as they're within a certain rotational range of each other.
  		if (!linkedPT && _lastLinkedAnchor$1 && Math.abs(short + _lastLinkedAnchor$1.ca) < _angleMin$1) {
  			linkedPT = _lastLinkedAnchor$1;
  		}
  		return (this._anchorPT = _lastLinkedAnchor$1 = {
  			_next:this._anchorPT,
  			t:start,
  			sa:sa,                              //starting angle
  			ca:(linkedPT && short * linkedPT.ca < 0 && Math.abs(short) > _angleMax$1) ? angleDif : short,  //change in angle
  			sl:d,                               //starting length
  			cl:_sqrt$4(dx * dx + dy * dy) - d,    //change in length
  			i:i
  		});
  	},
  	_initCore$2 = required => {
  		gsap$2 = _getGSAP$1();
  		PluginClass$1 = PluginClass$1 || (gsap$2 && gsap$2.plugins.morphSVG);
  		if (gsap$2 && PluginClass$1) {
  			_toArray$1 = gsap$2.utils.toArray;
  			PluginClass$1.prototype._tweenRotation = _tweenRotation$1;
  			_coreInitted$2 = 1;
  		} else if (required) {
  			_log$1("Please gsap.registerPlugin(MorphSVGPlugin)");
  		}
  	};


  const MorphSVGPlugin$1 = {
  	version: "3.4.0",
  	name: "morphSVG",
  	rawVars: 1, // otherwise "render" would be interpreted as a function-based value.
  	register(core, Plugin) {
  		gsap$2 = core;
  		PluginClass$1 = Plugin;
  		_initCore$2();
  	},
  	init(target, value, tween, index, targets) {
  		_coreInitted$2 || _initCore$2(1);
  		if (!value) {
  			_log$1("invalid shape");
  			return false;
  		}
  		_isFunction$2(value) && (value = value.call(tween, index, target, targets));
  		let type, p, pt, shape, isPoly, shapeIndex, map, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;
  		if (typeof(value) === "string" || value.getBBox || value[0]) {
  			value = {shape:value};
  		} else if (typeof(value) === "object") { // if there are any function-based values, parse them here (and make a copy of the object so we're not modifying the original)
  			type = {};
  			for (p in value) {
  				type[p] = _isFunction$2(value[p]) && p !== "render" ? value[p].call(tween, index, target, targets) : value[p];
  			}
  			value = type;
  		}
  		let cs = target.nodeType ? window.getComputedStyle(target) : {},
  			fill = cs.fill + "",
  			fillSafe = !(fill === "none" || (fill.match(_numExp$2) || [])[3] === "0" || cs.fillRule === "evenodd"),
  			origins = (value.origin || "50 50").split(",");
  		type = (target.nodeName + "").toUpperCase();
  		isPoly = (type === "POLYLINE" || type === "POLYGON");
  		if (type !== "PATH" && !isPoly && !value.prop) {
  			_log$1("Cannot morph a <" + type + "> element. " + _morphMessage$1);
  			return false;
  		}
  		p = (type === "PATH") ? "d" : "points";
  		if (!value.prop && !_isFunction$2(target.setAttribute)) {
  			return false;
  		}
  		shape = _parseShape$1(value.shape || value.d || value.points || "", (p === "d"), target);
  		if (isPoly && _commands$1.test(shape)) {
  			_log$1("A <" + type + "> cannot accept path data. " + _morphMessage$1);
  			return false;
  		}
  		shapeIndex = (value.shapeIndex || value.shapeIndex === 0) ? value.shapeIndex : "auto";
  		map = value.map || MorphSVGPlugin$1.defaultMap;
  		this._prop = value.prop;
  		this._render = value.render || MorphSVGPlugin$1.defaultRender;
  		this._apply = ("updateTarget" in value) ? value.updateTarget : MorphSVGPlugin$1.defaultUpdateTarget;
  		this._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);
  		this._tween = tween;
  		if (shape) {
  			this._target = target;
  			precompiled = (typeof(value.precompile) === "object");
  			start = this._prop ? target[this._prop] : target.getAttribute(p);
  			if (!this._prop && !target.getAttributeNS(null, "data-original")) {
  				target.setAttributeNS(null, "data-original", start); //record the original state in a data-original attribute so that we can revert to it later.
  			}
  			if (p === "d" || this._prop) {
  				start = stringToRawPath$1(precompiled ? value.precompile[0] : start);
  				end = stringToRawPath$1(precompiled ? value.precompile[1] : shape);
  				if (!precompiled && !_equalizeSegmentQuantity$1(start, end, shapeIndex, map, fillSafe)) {
  					return false; //malformed path data or null target
  				}
  				if (value.precompile === "log" || value.precompile === true) {
  					_log$1('precompile:["' + rawPathToString$1(start) + '","' + rawPathToString$1(end) + '"]');
  				}
  				useRotation = (value.type || MorphSVGPlugin$1.defaultType) !== "linear";
  				if (useRotation) {
  					start = _populateSmoothData$1(start, value.smoothTolerance);
  					end = _populateSmoothData$1(end, value.smoothTolerance);
  					if (!start.size) {
  						_getTotalSize$1(start); //adds top/left/width/height values
  					}
  					if (!end.size) {
  						_getTotalSize$1(end);
  					}
  					originFactors = _parseOriginFactors$1(origins[0]);
  					this._origin = start.origin = {x:start.left + originFactors.x * start.width, y:start.top + originFactors.y * start.height};
  					if (origins[1]) {
  						originFactors = _parseOriginFactors$1(origins[1]);
  					}
  					this._eOrigin = {x:end.left + originFactors.x * end.width, y:end.top + originFactors.y * end.height};
  				}

  				this._rawPath = target._gsRawPath =  start;

  				j = start.length;
  				while (--j > -1) {
  					startSeg = start[j];
  					endSeg = end[j];
  					startSmooth = startSeg.isSmooth || [];
  					endSmooth = endSeg.isSmooth || [];
  					l = startSeg.length;
  					_lastLinkedAnchor$1 = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don't get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)
  					for (i = 0; i < l; i+=2) {
  						if (endSeg[i] !== startSeg[i] || endSeg[i+1] !== startSeg[i+1]) {
  							if (useRotation) {
  								if (startSmooth[i] && endSmooth[i]) { //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).
  									sData = startSeg.smoothData;
  									eData = endSeg.smoothData;
  									offset = i + ((i === l - 4) ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).
  									this._controlPT = {_next:this._controlPT, i:i, j:j, l1s:sData[i+1], l1c:eData[i+1] - sData[i+1], l2s:sData[offset], l2c:eData[offset] - sData[offset]};
  									pt = this._tweenRotation(startSeg, endSeg, i+2);
  									this._tweenRotation(startSeg, endSeg, i, pt);
  									this._tweenRotation(startSeg, endSeg, offset-1, pt);
  									i+=4;
  								} else {
  									this._tweenRotation(startSeg, endSeg, i);
  								}
  							} else {
  								pt = this.add(startSeg, i, startSeg[i], endSeg[i]);
  								pt = this.add(startSeg, i+1, startSeg[i+1], endSeg[i+1]) || pt;
  							}
  						}
  					}
  				}
  			} else {
  				pt = this.add(target, "setAttribute", target.getAttribute(p) + "", shape + "", index, targets, 0, _buildPointsFilter$1(shapeIndex), p);
  			}

  			if (useRotation) {
  				this.add(this._origin, "x", this._origin.x, this._eOrigin.x);
  				pt = this.add(this._origin, "y", this._origin.y, this._eOrigin.y);
  			}

  			if (pt) {
  				this._props.push("morphSVG");
  				pt.end = shape;
  				pt.endProp = p;
  			}
  		}
  		return _bonusValidated$1;
  	},

  	render(ratio, data) {
  		let rawPath = data._rawPath,
  			controlPT = data._controlPT,
  			anchorPT = data._anchorPT,
  			rnd = data._rnd,
  			target = data._target,
  			pt = data._pt,
  			s, space, easeInOut, segment, l, angle, i, j, x, y, sin, cos, offset;
  		while (pt) {
  			pt.r(ratio, pt.d);
  			pt = pt._next;
  		}
  		if (ratio === 1 && data._apply) {
  			pt = data._pt;
  			while (pt) {
  				if (pt.end) {
  					if (data._prop) {
  						target[data._prop] = pt.end;
  					} else {
  						target.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)
  					}
  				}
  				pt = pt._next;
  			}
  		} else if (rawPath) {

  			//rotationally position the anchors
  			while (anchorPT) {
  				angle = anchorPT.sa + ratio * anchorPT.ca;
  				l = anchorPT.sl + ratio * anchorPT.cl;    //length
  				anchorPT.t[anchorPT.i] = data._origin.x + _cos$4(angle) * l;
  				anchorPT.t[anchorPT.i + 1] = data._origin.y + _sin$4(angle) * l;
  				anchorPT = anchorPT._next;
  			}

  			//smooth out the control points
  			easeInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;
  			while (controlPT) {
  				i = controlPT.i;
  				segment = rawPath[controlPT.j];
  				offset = i + ((i === segment.length - 4) ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.
  				angle = _atan2$2(segment[offset] - segment[i+1], segment[offset-1] - segment[i]); //average the angles
  				sin = _sin$4(angle);
  				cos = _cos$4(angle);
  				x = segment[i+2];
  				y = segment[i+3];
  				l = controlPT.l1s + easeInOut * controlPT.l1c;    //length
  				segment[i] = x - cos * l;
  				segment[i+1] = y - sin * l;
  				l = controlPT.l2s + easeInOut * controlPT.l2c;
  				segment[offset-1] = x + cos * l;
  				segment[offset] = y + sin * l;
  				controlPT = controlPT._next;
  			}

  			target._gsRawPath = rawPath;

  			if (data._apply) {
  				s = "";
  				space = " ";
  				for (j = 0; j < rawPath.length; j++) {
  					segment = rawPath[j];
  					l = segment.length;
  					s += "M" + (((segment[0] * rnd) | 0) / rnd) + space + (((segment[1] * rnd) | 0) / rnd) + " C";
  					for (i = 2; i < l; i++) { //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places
  						s += (((segment[i] * rnd) | 0) / rnd) + space;
  					}
  				}
  				if (data._prop) {
  					target[data._prop] = s;
  				} else {
  					target.setAttribute("d", s);
  				}
  			}
  		}
  		data._render && rawPath && data._render.call(data._tween, rawPath, target);
  	},
  	kill(property) {
  		this._pt = this._rawPath = 0;
  	},
  	getRawPath: getRawPath$1,
  	stringToRawPath: stringToRawPath$1,
  	rawPathToString: rawPathToString$1,
  	pathFilter: _pathFilter$1,
  	pointsFilter: _pointsFilter$1,
  	getTotalSize: _getTotalSize$1,
  	equalizeSegmentQuantity: _equalizeSegmentQuantity$1,
  	convertToPath: (targets, swap) => _toArray$1(targets).map(target => convertToPath$1(target, swap !== false)),
  	defaultType: "linear",
  	defaultUpdateTarget: true,
  	defaultMap: "size"
  };

  _getGSAP$1() && gsap$2.registerPlugin(MorphSVGPlugin$1);

  /*!
   * DrawSVGPlugin 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /* eslint-disable */


  let gsap$3, _toArray$2, _win$2, _isEdge, _coreInitted$3,
  	_windowExists$2 = () => typeof(window) !== "undefined",
  	_getGSAP$2 = () => gsap$3 || (_windowExists$2() && (gsap$3 = window.gsap) && gsap$3.registerPlugin && gsap$3),
  	_numExp$3 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  	_types = {rect:["width","height"], circle:["r","r"], ellipse:["rx","ry"], line:["x2","y2"]},
  	_round$3 = value => Math.round(value * 10000) / 10000,
  	_parseNum = value => parseFloat(value || 0),
  	_getAttributeAsNumber = (target, attr) => _parseNum(target.getAttribute(attr)),
  	_sqrt$5 = Math.sqrt,
  	_getDistance = (x1, y1, x2, y2, scaleX, scaleY) => _sqrt$5(((_parseNum(x2) - _parseNum(x1)) * scaleX) ** 2 + ((_parseNum(y2) - _parseNum(y1)) * scaleY) ** 2),
  	_warn$1 = message => console.warn(message),
  	_hasNonScalingStroke = target => target.getAttribute("vector-effect") === "non-scaling-stroke",
  	_bonusValidated$2 = 1, //<name>DrawSVGPlugin</name>
  	//accepts values like "100%" or "20% 80%" or "20 50" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]
  	_parse = (value, length, defaultStart) => {
  		let i = value.indexOf(" "),
  			s, e;
  		if (i < 0) {
  			s = defaultStart !== undefined ? defaultStart + "" : value;
  			e = value;
  		} else {
  			s = value.substr(0, i);
  			e = value.substr(i + 1);
  		}
  		s = ~s.indexOf("%") ? (_parseNum(s) / 100) * length : _parseNum(s);
  		e = ~e.indexOf("%") ? (_parseNum(e) / 100) * length : _parseNum(e);
  		return (s > e) ? [e, s] : [s, e];
  	},
  	_getLength = target => {
  		target = _toArray$2(target)[0];
  		if (!target) {
  			return 0;
  		}
  		let type = target.tagName.toLowerCase(),
  			style = target.style,
  			scaleX = 1,
  			scaleY = 1,
  			length, bbox, points, prevPoint, i, rx, ry;
  		if (_hasNonScalingStroke(target)) { //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.
  			scaleY = target.getScreenCTM();
  			scaleX = _sqrt$5(scaleY.a * scaleY.a + scaleY.b * scaleY.b);
  			scaleY = _sqrt$5(scaleY.d * scaleY.d + scaleY.c * scaleY.c);
  		}
  		try { //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.
  			bbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.
  		} catch (e) {
  			//firefox has a bug that throws an error if the element isn't visible.
  			_warn$1("Some browsers won't measure invisible elements (like display:none or masks inside defs).");
  		}
  		let {x, y, width, height} = bbox || {x:0, y:0, width:0, height:0};
  		if ((!bbox || (!width && !height)) && _types[type]) { //if the element isn't visible, try to discern width/height using its attributes.
  			width =_getAttributeAsNumber(target, _types[type][0]);
  			height = _getAttributeAsNumber(target, _types[type][1]);
  			if (type !== "rect" && type !== "line") { //double the radius for circles and ellipses
  				width *= 2;
  				height *= 2;
  			}
  			if (type === "line") {
  				x = _getAttributeAsNumber(target, "x1");
  				y = _getAttributeAsNumber(target, "y1");
  				width = Math.abs(width - x);
  				height = Math.abs(height - y);
  			}
  		}
  		if (type === "path") {
  			prevPoint = style.strokeDasharray;
  			style.strokeDasharray = "none";
  			length = target.getTotalLength() || 0;
  			if (scaleX !== scaleY) {
  				_warn$1("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.");
  			}
  			length *= (scaleX + scaleY) / 2;
  			style.strokeDasharray = prevPoint;
  		} else if (type === "rect") {
  			length = width * 2 * scaleX + height * 2 * scaleY;
  		} else if (type === "line") {
  			length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);
  		} else if (type === "polyline" || type === "polygon") {
  			points = target.getAttribute("points").match(_numExp$3) || [];
  			if (type === "polygon") {
  				points.push(points[0], points[1]);
  			}
  			length = 0;
  			for (i = 2; i < points.length; i+=2) {
  				length += _getDistance(points[i-2], points[i-1], points[i], points[i+1], scaleX, scaleY) || 0;
  			}
  		} else if (type === "circle" || type === "ellipse") {
  			rx = (width / 2) * scaleX;
  			ry = (height / 2) * scaleY;
  			length = Math.PI * ( 3 * (rx + ry) - _sqrt$5((3 * rx + ry) * (rx + 3 * ry)) );
  		}
  		return length || 0;
  	},
  	_getPosition = (target, length) => {
  		target = _toArray$2(target)[0];
  		if (!target) {
  			return [0, 0];
  		}
  		if (!length) {
  			length = _getLength(target) + 1;
  		}
  		let cs = _win$2.getComputedStyle(target),
  			dash = cs.strokeDasharray || "",
  			offset = _parseNum(cs.strokeDashoffset),
  			i = dash.indexOf(",");
  		if (i < 0) {
  			i = dash.indexOf(" ");
  		}
  		dash = (i < 0) ? length : _parseNum(dash.substr(0, i)) || 1e-5;
  		if (dash > length) {
  			dash = length;
  		}
  		return [Math.max(0, -offset), Math.max(0, dash - offset)];
  	},
  	_initCore$3 = () => {
  		if (_windowExists$2()) {
  			_win$2 = window;
  			_coreInitted$3 = gsap$3 = _getGSAP$2();
  			_toArray$2 = gsap$3.utils.toArray;
  			_isEdge = (((_win$2.navigator || {}).userAgent || "").indexOf("Edge") !== -1); //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than "butt" (like "round") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)
  		}
  	};


  const DrawSVGPlugin = {
  	version:"3.4.0",
  	name:"drawSVG",
  	register(core) {
  		gsap$3 = core;
  		_initCore$3();
  	},
  	init(target, value, tween, index, targets) {
  		if (!target.getBBox) {
  			return false;
  		}
  		if (!_coreInitted$3) {
  			_initCore$3();
  		}
  		let length = _getLength(target) + 1,
  			start, end, overage, cs;
  		this._style = target.style;
  		this._target = target;
  		if (value + "" === "true") {
  			value = "0 100%";
  		} else if (!value) {
  			value = "0 0";
  		} else if ((value + "").indexOf(" ") === -1) {
  			value = "0 " + value;
  		}
  		start = _getPosition(target, length);
  		end = _parse(value, length, start[0]);
  		this._length = _round$3(length + 10);
  		if (start[0] === 0 && end[0] === 0) {
  			overage = Math.max(0.00001, end[1] - length); //allow people to go past the end, like values of 105% because for some paths, Firefox doesn't return an accurate getTotalLength(), so it could end up coming up short.
  			this._dash = _round$3(length + overage);
  			this._offset = _round$3(length - start[1] + overage);
  			this._offsetPT = this.add(this, "_offset", this._offset, _round$3(length - end[1] + overage));
  		} else {
  			this._dash = _round$3(start[1] - start[0]) || 0.000001; //some browsers render artifacts if dash is 0, so we use a very small number in that case.
  			this._offset = _round$3(-start[0]);
  			this._dashPT = this.add(this, "_dash", this._dash, _round$3(end[1] - end[0]) || 0.00001);
  			this._offsetPT = this.add(this, "_offset", this._offset, _round$3(-end[0]));
  		}
  		if (_isEdge) { //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's "round" and stroke-linejoin is also "round"). Imperceptible, relatively high-performance, and effective. Another option was to set the "d" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.
  			cs = _win$2.getComputedStyle(target);
  			if (cs.strokeLinecap !== cs.strokeLinejoin) {
  				end = _parseNum(cs.strokeMiterlimit);
  				this.add(target.style, "strokeMiterlimit", end, end + 0.01);
  			}
  		}
  		this._live = (_hasNonScalingStroke(target) || ~((value + "").indexOf("live")));
  		this._props.push("drawSVG");
  		return _bonusValidated$2;
  	},
  	render(ratio, data) {
  		let pt = data._pt,
  			style = data._style,
  			length, lengthRatio, dash, offset;
  		if (pt) {
  			//when the element has vector-effect="non-scaling-stroke" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.
  			if (data._live) {
  				length = _getLength(data._target) + 11;
  				if (length !== data._length) {
  					lengthRatio = length / data._length;
  					data._length = length;
  					data._offsetPT.s *= lengthRatio;
  					data._offsetPT.c *= lengthRatio;
  					if (data._dashPT) {
  						data._dashPT.s *= lengthRatio;
  						data._dashPT.c *= lengthRatio;
  					} else {
  						data._dash *= lengthRatio;
  					}
  				}
  			}
  			while (pt) {
  				pt.r(ratio, pt.d);
  				pt = pt._next;
  			}
  			dash = data._dash;
  			offset = data._offset;
  			length = data._length;
  			style.strokeDashoffset = data._offset;
  			if (ratio === 1 || !ratio) {
  				if (dash - offset < 0.001 && length - dash <= 10) { //works around a bug in Safari that caused strokes with rounded ends to still show initially when they shouldn't.
  					style.strokeDashoffset = offset + 1;
  				}
  				style.strokeDasharray = (offset < 0.001 && length - dash <= 10) ? "none" : (offset === dash) ? "0px, 999999px" : dash + "px," + length + "px";
  			} else {
  				style.strokeDasharray = dash + "px," + length + "px";
  			}
  		}
  	},
  	getLength: _getLength,
  	getPosition: _getPosition
  };

  _getGSAP$2() && gsap$3.registerPlugin(DrawSVGPlugin);

  /*!
   * matrix 3.4.0
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /* eslint-disable */

  let _doc$2, _win$3, _docElement$1, _body,	_divContainer, _svgContainer, _identityMatrix,
  	_transformProp$1 = "transform",
  	_transformOriginProp$1 = _transformProp$1 + "Origin",
  	_hasOffsetBug,
  	_setDoc = element => {
  		let doc = element.ownerDocument || element;
  		if (!(_transformProp$1 in element.style) && "msTransform" in element.style) { //to improve compatibility with old Microsoft browsers
  			_transformProp$1 = "msTransform";
  			_transformOriginProp$1 = _transformProp$1 + "Origin";
  		}
  		while (doc.parentNode && (doc = doc.parentNode)) {	}
  		_win$3 = window;
  		_identityMatrix = new Matrix2D();
  		if (doc) {
  			_doc$2 = doc;
  			_docElement$1 = doc.documentElement;
  			_body = doc.body;
  			// now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.
  			let d1 = doc.createElement("div"),
  				d2 = doc.createElement("div");
  			_body.appendChild(d1);
  			d1.appendChild(d2);
  			d1.style.position = "static";
  			d1.style[_transformProp$1] = "translate3d(0,0,1px)";
  			_hasOffsetBug = (d2.offsetParent !== d1);
  			_body.removeChild(d1);
  		}
  		return doc;
  	},
  	_forceNonZeroScale = e => { // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work
  		let a, cache;
  		while (e && e !== _body) {
  			cache = e._gsap;
  			if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
  				cache.scaleX = cache.scaleY = 1e-4;
  				cache.renderTransform(1, cache);
  				a ? a.push(cache) : (a = [cache]);
  			}
  			e = e.parentNode;
  		}
  		return a;
  	},
  	// possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.
  	// _forceDisplay = e => {
  	// 	let a = [],
  	// 		parent;
  	// 	while (e && e !== _body) {
  	// 		parent = e.parentNode;
  	// 		(_win.getComputedStyle(e).display === "none" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = "block");
  	// 		parent || _body.appendChild(e);
  	// 		e = parent;
  	// 	}
  	// 	return a;
  	// },
  	// _revertDisplay = a => {
  	// 	for (let i = 0; i < a.length; i+=3) {
  	// 		a[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty("display");
  	// 		a[i+2] || a[i].parentNode.removeChild(a[i]);
  	// 	}
  	// },
  	_svgTemps = [], //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.
  	_divTemps = [],
  	_getDocScrollTop = () => _win$3.pageYOffset  || _doc$2.scrollTop || _docElement$1.scrollTop || _body.scrollTop || 0,
  	_getDocScrollLeft = () => _win$3.pageXOffset || _doc$2.scrollLeft || _docElement$1.scrollLeft || _body.scrollLeft || 0,
  	_svgOwner = element => element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null),
  	_isFixed = element => {
  		if (_win$3.getComputedStyle(element).position === "fixed") {
  			return true;
  		}
  		element = element.parentNode;
  		if (element && element.nodeType === 1) { // avoid document fragments which will throw an error.
  			return _isFixed(element);
  		}
  	},
  	_createSibling = (element, i) => {
  		if (element.parentNode && (_doc$2 || _setDoc(element))) {
  			let svg = _svgOwner(element),
  				ns = svg ? (svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg") : "http://www.w3.org/1999/xhtml",
  				type = svg ? (i ? "rect" : "g") : "div",
  				x = i !== 2 ? 0 : 100,
  				y = i === 3 ? 100 : 0,
  				css = "position:absolute;display:block;pointer-events:none;",
  				e = _doc$2.createElementNS ? _doc$2.createElementNS(ns.replace(/^https/, "http"), type) : _doc$2.createElement(type);
  			if (i) {
  				if (!svg) {
  					if (!_divContainer) {
  						_divContainer = _createSibling(element);
  						_divContainer.style.cssText = css;
  					}
  					e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
  					_divContainer.appendChild(e);

  				} else {
  					if (!_svgContainer) {
  						_svgContainer = _createSibling(element);
  					}
  					e.setAttribute("width", 0.01);
  					e.setAttribute("height", 0.01);
  					e.setAttribute("transform", "translate(" + x + "," + y + ")");
  					_svgContainer.appendChild(e);
  				}
  			}
  			return e;
  		}
  		throw "Need document and parent.";
  	},
  	_consolidate = m => { // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
  		let c = new Matrix2D(),
  			i = 0;
  		for (; i < m.numberOfItems; i++) {
  			c.multiply(m.getItem(i).matrix);
  		}
  		return c;
  	},
  	_placeSiblings = (element, adjustGOffset) => {
  		let svg = _svgOwner(element),
  			isRootSVG = element === svg,
  			siblings = svg ? _svgTemps : _divTemps,
  			container, m, b, x, y;
  		if (element === _win$3) {
  			return element;
  		}
  		if (!siblings.length) {
  			siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
  		}
  		container = svg ? _svgContainer : _divContainer;
  		if (svg) {
  			b = isRootSVG ? {x:0, y:0} : element.getBBox();
  			m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.
  			if (m.numberOfItems) {
  				m = m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
  				x = m.a * b.x + m.c * b.y;
  				y = m.b * b.x + m.d * b.y;
  			} else {
  				m = _identityMatrix;
  				x = b.x;
  				y = b.y;
  			}
  			if (adjustGOffset && element.tagName.toLowerCase() === "g") {
  				x = y = 0;
  			}
  			container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
  			(isRootSVG ? svg : element.parentNode).appendChild(container);
  		} else {
  			x = y = 0;
  			if (_hasOffsetBug) { // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.
  				m = element.offsetParent;
  				b = element;
  				while (b && (b = b.parentNode) && b !== m && b.parentNode) {
  					if ((_win$3.getComputedStyle(b)[_transformProp$1] + "").length > 4) {
  						x = b.offsetLeft;
  						y = b.offsetTop;
  						b = 0;
  					}
  				}
  			}
  			b = container.style;
  			b.top = (element.offsetTop - y) + "px";
  			b.left = (element.offsetLeft - x) + "px";
  			m = _win$3.getComputedStyle(element);
  			b[_transformProp$1] = m[_transformProp$1];
  			b[_transformOriginProp$1] = m[_transformOriginProp$1];
  			b.border = m.border;
  			b.borderLeftStyle = m.borderLeftStyle;
  			b.borderTopStyle = m.borderTopStyle;
  			b.borderLeftWidth = m.borderLeftWidth;
  			b.borderTopWidth = m.borderTopWidth;
  			b.position = m.position === "fixed" ? "fixed" : "absolute";
  			element.parentNode.appendChild(container);
  		}
  		return container;
  	},
  	_setMatrix = (m, a, b, c, d, e, f) => {
  		m.a = a;
  		m.b = b;
  		m.c = c;
  		m.d = d;
  		m.e = e;
  		m.f = f;
  		return m;
  	};

  class Matrix2D {
  	constructor(a=1, b=0, c=0, d=1, e=0, f=0) {
  		_setMatrix(this, a, b, c, d, e, f);
  	}

  	inverse() {
  		let {a, b, c, d, e, f} = this,
  			determinant = (a * d - b * c) || 1e-10;
  		return _setMatrix(
  			this,
  			d / determinant,
  			-b / determinant,
  			-c / determinant,
  			a / determinant,
  			(c * f - d * e) / determinant,
  			-(a * f - b * e) / determinant
  		);
  	}

  	multiply(matrix) {
  		let {a, b, c, d, e, f} = this,
  			a2 = matrix.a,
  			b2 = matrix.c,
  			c2 = matrix.b,
  			d2 = matrix.d,
  			e2 = matrix.e,
  			f2 = matrix.f;
  		return _setMatrix(this,
  			a2 * a + c2 * c,
  			a2 * b + c2 * d,
  			b2 * a + d2 * c,
  			b2 * b + d2 * d,
  			e + e2 * a + f2 * c,
  			f + e2 * b + f2 * d);
  	}

  	clone() {
  		return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
  	}

  	equals(matrix) {
  		let {a, b, c, d, e, f} = this;
  		return (a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f);
  	}

  	apply(point, decoratee={}) {
  		let {x, y} = point,
  			{a, b, c, d, e, f} = this;
  		decoratee.x = (x * a + y * c + e) || 0;
  		decoratee.y = (x * b + y * d + f) || 0;
  		return decoratee;
  	}

  }

  //feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.
  // Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.
  // We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there
  // are transforms applied to ancestor elements.
  // The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:
  //     tx = m.a * x + m.c * y + m.e
  //     ty = m.b * x + m.d * y + m.f
  function getGlobalMatrix(element, inverse, adjustGOffset) { // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.
  	if (!element || !element.parentNode || (_doc$2 || _setDoc(element)).documentElement === element) {
  		return new Matrix2D();
  	}
  	let zeroScales = _forceNonZeroScale(element.parentNode),
  		svg = _svgOwner(element),
  		temps = svg ? _svgTemps : _divTemps,
  		container = _placeSiblings(element, adjustGOffset),
  		b1 = temps[0].getBoundingClientRect(),
  		b2 = temps[1].getBoundingClientRect(),
  		b3 = temps[2].getBoundingClientRect(),
  		parent = container.parentNode,
  		isFixed = _isFixed(element),
  		m = new Matrix2D(
  			(b2.left - b1.left) / 100,
  			(b2.top - b1.top) / 100,
  			(b3.left - b1.left) / 100,
  			(b3.top - b1.top) / 100,
  			b1.left + (isFixed ? 0 : _getDocScrollLeft()),
  			b1.top + (isFixed ? 0 : _getDocScrollTop())
  		);
  	parent.removeChild(container);
  	if (zeroScales) {
  		b1 = zeroScales.length;
  		while (b1--) {
  			b2 = zeroScales[b1];
  			b2.scaleX = b2.scaleY = 0;
  			b2.renderTransform(1, b2);
  		}
  	}
  	return inverse ? m.inverse() : m;
  }

  // export function getMatrix(element) {
  // 	_doc || _setDoc(element);
  // 	let m = (_win.getComputedStyle(element)[_transformProp] + "").substr(7).match(/[-.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g),
  // 		is2D = m && m.length === 6;
  // 	return !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);
  // }

  /*!
   * Draggable 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
   */

  let gsap$4, _win$4, _doc$3, _docElement$2, _body$1, _tempDiv$1, _placeholderDiv, _coreInitted$4, _checkPrefix, _toArray$3, _supportsPassive, _isTouchDevice, _touchEventLookup, _dragCount, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer,
  	_windowExists$3 = () => typeof(window) !== "undefined",
  	_getGSAP$3 = () => gsap$4 || (_windowExists$3() && (gsap$4 = window.gsap) && gsap$4.registerPlugin && gsap$4),
  	_isFunction$3 = value => typeof(value) === "function",
  	_isObject$1 = value => typeof(value) === "object",
  	_isUndefined$1 = value => typeof(value) === "undefined",
  	_emptyFunc$1 = () => false,
  	_transformProp$2 = "transform",
  	_transformOriginProp$2 = "transformOrigin",
  	_round$4 = value => Math.round(value * 10000) / 10000,
  	_isArray$1 = Array.isArray,
  	_createElement$1 = (type, ns) => {
  		let e = _doc$3.createElementNS ? _doc$3.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$3.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.
  		return e.style ? e : _doc$3.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  	},
  	_RAD2DEG$1 = 180 / Math.PI,
  	_bigNum$4 = 1e20,
  	_identityMatrix$1 = new Matrix2D(),
  	_getTime = Date.now || (() => new Date().getTime()),
  	_renderQueue = [],
  	_lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
  	_lookupCount = 0,
  	_clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
  	_lastDragTime = 0,
  	_temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
  	_windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
  	_copy = (obj, factor) => {
  		let copy = {}, p;
  		for (p in obj) {
  			copy[p] = factor ? obj[p] * factor : obj[p];
  		}
  		return copy;
  	},
  	_extend = (obj, defaults) => {
  		for (let p in defaults) {
  			if (!(p in obj)) {
  				obj[p] = defaults[p];
  			}
  		}
  		return obj;
  	},
  	_renderQueueTick = () => _renderQueue.forEach(func => func()),
  	_addToRenderQueue = func => {
  		_renderQueue.push(func);
  		if (_renderQueue.length === 1) {
  			gsap$4.ticker.add(_renderQueueTick);
  		}
  	},
  	_renderQueueTimeout = () => !_renderQueue.length && gsap$4.ticker.remove(_renderQueueTick),
  	_removeFromRenderQueue = func => {
  		let i = _renderQueue.length;
  		while (i--) {
  			if (_renderQueue[i] === func) {
  				_renderQueue.splice(i, 1);
  			}
  		}
  		gsap$4.to(_renderQueueTimeout, {overwrite:true, delay:15, duration:0, onComplete:_renderQueueTimeout, data:"_draggable"}); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
  	},
  	_setDefaults$1 = (obj, defaults) => {
  		for (let p in defaults) {
  			if (!(p in obj)) {
  				obj[p] = defaults[p];
  			}
  		}
  		return obj;
  	},
  	_addListener = (element, type, func, capture) => {
  		if (element.addEventListener) {
  			let touchType = _touchEventLookup[type];
  			capture = capture || (_supportsPassive ? {passive: false} : null);
  			element.addEventListener(touchType || type, func, capture);
  			(touchType && type !== touchType) && element.addEventListener(type, func, capture);//some browsers actually support both, so must we. But pointer events cover all.
  		}
  	},
  	_removeListener = (element, type, func) => {
  		if (element.removeEventListener) {
  			let touchType = _touchEventLookup[type];
  			element.removeEventListener(touchType || type, func);
  			(touchType && type !== touchType) && element.removeEventListener(type, func);
  		}
  	},
  	_preventDefault = event => {
  		event.preventDefault && event.preventDefault();
  		event.preventManipulation && event.preventManipulation();  //for some Microsoft browsers
  	},
  	_hasTouchID = (list, ID) => {
  		let i = list.length;
  		while (i--) {
  			if (list[i].identifier === ID) {
  				return true;
  			}
  		}
  	},
  	_onMultiTouchDocumentEnd = event => {
  		_isMultiTouching = (event.touches && _dragCount < event.touches.length);
  		_removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);
  	},

  	_onMultiTouchDocument = event => {
  		_isMultiTouching = (event.touches && _dragCount < event.touches.length);
  		_addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
  	},
  	_getDocScrollTop$1 = doc => _win$4.pageYOffset  || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0,
  	_getDocScrollLeft$1 = doc => _win$4.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0,
  	_addScrollListener = (e, callback) => {
  		_addListener(e, "scroll", callback);
  		if (!_isRoot(e.parentNode)) {
  			_addScrollListener(e.parentNode, callback);
  		}
  	},
  	_removeScrollListener = (e, callback) => {
  		_removeListener(e, "scroll", callback);
  		if (!_isRoot(e.parentNode)) {
  			_removeScrollListener(e.parentNode, callback);
  		}
  	},
  	_isRoot = e => !!(!e || e === _docElement$2 || e.nodeType === 9 || e === _doc$3.body || e === _win$4 || !e.nodeType || !e.parentNode),
  	_getMaxScroll = (element, axis) => {
  		let dim = (axis === "x") ? "Width" : "Height",
  			scroll = "scroll" + dim,
  			client = "client" + dim;
  		return Math.max(0, _isRoot(element) ? Math.max(_docElement$2[scroll], _body$1[scroll]) - (_win$4["inner" + dim] || _docElement$2[client] || _body$1[client]) : element[scroll] - element[client]);
  	},
  	_recordMaxScrolls = (e, skipCurrent) => { //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
  		let x = _getMaxScroll(e, "x"),
  			y = _getMaxScroll(e, "y");
  		if (_isRoot(e)) {
  			e = _windowProxy;
  		} else {
  			_recordMaxScrolls(e.parentNode, skipCurrent);
  		}
  		e._gsMaxScrollX = x;
  		e._gsMaxScrollY = y;
  		if (!skipCurrent) {
  			e._gsScrollX = e.scrollLeft || 0;
  			e._gsScrollY = e.scrollTop || 0;
  		}
  	},
  	_setStyle = (element, property, value) => {
  		let style = element.style;
  		if (!style) {
  			return;
  		}
  		if (_isUndefined$1(style[property])) {
  			property = _checkPrefix(property, element) || property;
  		}
  		if (value == null) {
  			style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
  		} else {
  			style[property] = value;
  		}
  	},
  	_getComputedStyle = element => _win$4.getComputedStyle((element instanceof Element) ? element : element.host || (element.parentNode || {}).host || element), //the "host" stuff helps to accommodate ShadowDom objects.

  	_tempRect = {}, //reuse to reduce garbage collection tasks
  	_parseRect = e => { //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
  		if (e === _win$4) {
  			_tempRect.left = _tempRect.top = 0;
  			_tempRect.width = _tempRect.right = _docElement$2.clientWidth || e.innerWidth || _body$1.clientWidth || 0;
  			_tempRect.height = _tempRect.bottom = ((e.innerHeight || 0) - 20 < _docElement$2.clientHeight) ? _docElement$2.clientHeight : e.innerHeight || _body$1.clientHeight || 0;
  			return _tempRect;
  		}
  		let doc = e.ownerDocument || _doc$3,
  			r = !_isUndefined$1(e.pageX) ? {left: e.pageX - _getDocScrollLeft$1(doc), top: e.pageY - _getDocScrollTop$1(doc), right: e.pageX - _getDocScrollLeft$1(doc) + 1, bottom: e.pageY - _getDocScrollTop$1(doc) + 1} : (!e.nodeType && !_isUndefined$1(e.left) && !_isUndefined$1(e.top)) ? e : _toArray$3(e)[0].getBoundingClientRect();
  		if (_isUndefined$1(r.right) && !_isUndefined$1(r.width)) {
  			r.right = r.left + r.width;
  			r.bottom = r.top + r.height;
  		} else if (_isUndefined$1(r.width)) { //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
  			r = {width: r.right - r.left, height: r.bottom - r.top, right: r.right, left: r.left, bottom: r.bottom, top: r.top};
  		}
  		return r;
  	},

  	_dispatchEvent = (target, type, callbackName) => {
  		let vars = target.vars,
  			callback = vars[callbackName],
  			listeners = target._listeners[type],
  			result;
  		if (_isFunction$3(callback)) {
  			result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
  		}
  		if (listeners && target.dispatchEvent(type) === false) {
  			result = false;
  		}
  		return result;
  	},
  	_getBounds = (target, context) => { //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
  		let e = _toArray$3(target)[0],
  			top, left, offset;
  		if (!e.nodeType && e !== _win$4) {
  			if (!_isUndefined$1(target.left)) {
  				offset = {x:0, y:0}; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin
  				return {left: target.left - offset.x, top: target.top - offset.y, width: target.width, height: target.height};
  			}
  			left = target.min || target.minX || target.minRotation || 0;
  			top = target.min || target.minY || 0;
  			return {left:left, top:top, width:(target.max || target.maxX || target.maxRotation || 0) - left, height:(target.max || target.maxY || 0) - top};
  		}
  		return _getElementBounds(e, context);
  	},
  	_point1 = {}, //we reuse to minimize garbage collection tasks.
  	_getElementBounds = (element, context) => {
  		context = _toArray$3(context)[0];
  		let isSVG = (element.getBBox && element.ownerSVGElement),
  			doc = element.ownerDocument || _doc$3,
  			left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs, contextParent;
  		if (element === _win$4) {
  			top = _getDocScrollTop$1(doc);
  			left = _getDocScrollLeft$1(doc);
  			right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
  			bottom = top + (((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight) ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
  		} else if (context === _win$4 || _isUndefined$1(context)) {
  			return element.getBoundingClientRect();
  		} else {
  			left = top =  0;
  			if (isSVG) {
  				bbox = element.getBBox();
  				width = bbox.width;
  				height = bbox.height;
  			} else {
  				if (element.viewBox && (bbox = element.viewBox.baseVal)) {
  					left = bbox.x || 0;
  					top = bbox.y || 0;
  					width = bbox.width;
  					height = bbox.height;
  				}
  				if (!width) {
  					cs = _getComputedStyle(element);
  					bbox = cs.boxSizing === "border-box";
  					width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
  					height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
  				}
  			}
  			right = width;
  			bottom = height;
  		}
  		if (element === context) {
  			return {left:left, top:top, width: right - left, height: bottom - top};
  		}
  		matrix = getGlobalMatrix(context, true).multiply(getGlobalMatrix(element));
  		p1 = matrix.apply({x:left, y:top});
  		p2 = matrix.apply({x:right, y:top});
  		p3 = matrix.apply({x:right, y:bottom});
  		p4 = matrix.apply({x:left, y:bottom});
  		left = Math.min(p1.x, p2.x, p3.x, p4.x);
  		top = Math.min(p1.y, p2.y, p3.y, p4.y);
  		contextParent = context.parentNode || {};
  		return {left: left + (contextParent.scrollLeft || 0), top: top + (contextParent.scrollTop || 0), width: Math.max(p1.x, p2.x, p3.x, p4.x) - left, height: Math.max(p1.y, p2.y, p3.y, p4.y) - top};
  	},
  	_parseInertia = (draggable, snap, max, min, factor, forceZeroVelocity) => {
  		let vars = {},
  			a, i, l;
  		if (snap) {
  			if (factor !== 1 && snap instanceof Array) { //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
  				vars.end = a = [];
  				l = snap.length;
  				if (_isObject$1(snap[0])) { //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.
  					for (i = 0; i < l; i++) {
  						a[i] = _copy(snap[i], factor);
  					}
  				} else {
  					for (i = 0; i < l; i++) {
  						a[i] = snap[i] * factor;
  					}
  				}
  				max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.
  				min -= 1.1;
  			} else if (_isFunction$3(snap)) {
  				vars.end = value => {
  					let result = snap.call(draggable, value),
  						copy, p;
  					if (factor !== 1) {
  						if (_isObject$1(result)) {
  							copy = {};
  							for (p in result) {
  								copy[p] = result[p] * factor;
  							}
  							result = copy;
  						} else {
  							result *= factor;
  						}
  					}
  					return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
  				};
  			} else {
  				vars.end = snap;
  			}
  		}
  		if (max || max === 0) {
  			vars.max = max;
  		}
  		if (min || min === 0) {
  			vars.min = min;
  		}
  		if (forceZeroVelocity) {
  			vars.velocity = 0;
  		}
  		return vars;
  	},
  	_isClickable = element => { //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
  		let data;
  		return (!element || !element.getAttribute || element === _body$1) ? false : ((data = element.getAttribute("data-clickable")) === "true" || (data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true"))) ? true : _isClickable(element.parentNode);
  	},
  	_setSelectable = (elements, selectable) => {
  		let i = elements.length,
  			e;
  		while (i--) {
  			e = elements[i];
  			e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc$1;
  			//setStyle(e, "userSelect", (selectable ? "text" : "none"));
  			gsap$4.set(e, {lazy:true, userSelect: (selectable ? "text" : "none")});
  		}
  	},
  	_isFixed$1 = element => {
  		if (_getComputedStyle(element).position === "fixed") {
  			return true;
  		}
  		element = element.parentNode;
  		if (element && element.nodeType === 1) { // avoid document fragments which will throw an error.
  			return _isFixed$1(element);
  		}
  	},
  	_supports3D$1, _addPaddingBR,

  	//The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
  	ScrollProxy = function(element, vars) {
  		element = gsap$4.utils.toArray(element)[0];
  		vars = vars || {};
  		let content = document.createElement("div"),
  			style = content.style,
  			node = element.firstChild,
  			offsetTop = 0,
  			offsetLeft = 0,
  			prevTop = element.scrollTop,
  			prevLeft = element.scrollLeft,
  			scrollWidth = element.scrollWidth,
  			scrollHeight = element.scrollHeight,
  			extraPadRight = 0,
  			maxLeft = 0,
  			maxTop = 0,
  			elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;
  		if (_supports3D$1 && vars.force3D !== false) {
  			transformStart = "translate3d(";
  			transformEnd = "px,0px)";
  		} else if (_transformProp$2) {
  			transformStart = "translate(";
  			transformEnd = "px)";
  		}
  		this.scrollTop = function(value, force) {
  			if (!arguments.length) {
  				return -this.top();
  			}
  			this.top(-value, force);
  		};
  		this.scrollLeft = function(value, force) {
  			if (!arguments.length) {
  				return -this.left();
  			}
  			this.left(-value, force);
  		};
  		this.left = function(value, force) {
  			if (!arguments.length) {
  				return -(element.scrollLeft + offsetLeft);
  			}
  			let dif = element.scrollLeft - prevLeft,
  				oldOffset = offsetLeft;
  			if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
  				prevLeft = element.scrollLeft;
  				gsap$4.killTweensOf(this, {left:1, scrollLeft:1});
  				this.left(-prevLeft);
  				if (vars.onKill) {
  					vars.onKill();
  				}
  				return;
  			}
  			value = -value; //invert because scrolling works in the opposite direction
  			if (value < 0) {
  				offsetLeft = (value - 0.5) | 0;
  				value = 0;
  			} else if (value > maxLeft) {
  				offsetLeft = (value - maxLeft) | 0;
  				value = maxLeft;
  			} else {
  				offsetLeft = 0;
  			}
  			if (offsetLeft || oldOffset) {
  				if (!this._skip) {
  					style[_transformProp$2] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
  				}
  				if (offsetLeft + extraPadRight >= 0) {
  					style.paddingRight =  offsetLeft + extraPadRight + "px";
  				}
  			}
  			element.scrollLeft = value | 0;
  			prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
  		};
  		this.top = function(value, force) {
  			if (!arguments.length) {
  				return -(element.scrollTop + offsetTop);
  			}
  			let dif = element.scrollTop - prevTop,
  				oldOffset = offsetTop;
  			if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
  				prevTop = element.scrollTop;
  				gsap$4.killTweensOf(this, {top:1, scrollTop:1});
  				this.top(-prevTop);
  				if (vars.onKill) {
  					vars.onKill();
  				}
  				return;
  			}
  			value = -value; //invert because scrolling works in the opposite direction
  			if (value < 0) {
  				offsetTop = (value - 0.5) | 0;
  				value = 0;
  			} else if (value > maxTop) {
  				offsetTop = (value - maxTop) | 0;
  				value = maxTop;
  			} else {
  				offsetTop = 0;
  			}
  			if (offsetTop || oldOffset) {
  				if (!this._skip) {
  					style[_transformProp$2] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
  				}
  			}
  			element.scrollTop = value | 0;
  			prevTop = element.scrollTop;
  		};

  		this.maxScrollTop = () => maxTop;
  		this.maxScrollLeft = () => maxLeft;

  		this.disable = function() {
  			node = content.firstChild;
  			while (node) {
  				nextNode = node.nextSibling;
  				element.appendChild(node);
  				node = nextNode;
  			}
  			if (element === content.parentNode) { //in case disable() is called when it's already disabled.
  				element.removeChild(content);
  			}
  		};
  		this.enable = function() {
  			node = element.firstChild;
  			if (node === content) {
  				return;
  			}
  			while (node) {
  				nextNode = node.nextSibling;
  				content.appendChild(node);
  				node = nextNode;
  			}
  			element.appendChild(content);
  			this.calibrate();
  		};
  		this.calibrate = function(force) {
  			let widthMatches = (element.clientWidth === elementWidth),
  				cs, x, y;
  			prevTop = element.scrollTop;
  			prevLeft = element.scrollLeft;
  			if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
  				return; //no need to recalculate things if the width and height haven't changed.
  			}
  			if (offsetTop || offsetLeft) {
  				x = this.left();
  				y = this.top();
  				this.left(-element.scrollLeft);
  				this.top(-element.scrollTop);
  			}
  			cs = _getComputedStyle(element);
  			//first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)
  			if (!widthMatches || force) {
  				style.display = "block";
  				style.width = "auto";
  				style.paddingRight = "0px";
  				extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
  				//if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.
  				if (extraPadRight) {
  					extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
  				}
  			}
  			style.display = "inline-block";
  			style.position = "relative";
  			style.overflow = "visible";
  			style.verticalAlign = "top";
  			style.boxSizing = "content-box";
  			style.width = "100%";
  			style.paddingRight = extraPadRight + "px";
  			//some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error
  			if (_addPaddingBR) {
  				style.paddingBottom = cs.paddingBottom;
  			}
  			elementWidth = element.clientWidth;
  			elementHeight = element.clientHeight;
  			scrollWidth = element.scrollWidth;
  			scrollHeight = element.scrollHeight;
  			maxLeft = element.scrollWidth - elementWidth;
  			maxTop = element.scrollHeight - elementHeight;
  			contentHeight = content.offsetHeight;
  			style.display = "block";
  			if (x || y) {
  				this.left(x);
  				this.top(y);
  			}
  		};
  		this.content = content;
  		this.element = element;
  		this._skip = false;
  		this.enable();
  	},
  	_initCore$4 = required => {
  		if (_windowExists$3() && document.body) {
  			let nav = window && window.navigator;
  			_win$4 = window;
  			_doc$3 = document;
  			_docElement$2 = _doc$3.documentElement;
  			_body$1 = _doc$3.body;
  			_tempDiv$1 = _createElement$1("div");
  			_supportsPointer = !!window.PointerEvent;
  			_placeholderDiv = _createElement$1("div");
  			_placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
  			_defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
  			_isAndroid = (nav && nav.userAgent.toLowerCase().indexOf("android") !== -1); //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing
  			_isTouchDevice = (("ontouchstart" in _docElement$2) && ("orientation" in _win$4)) || (nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0));
  			_addPaddingBR = (function() { //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
  				let div = _createElement$1("div"),
  					child = _createElement$1("div"),
  					childStyle = child.style,
  					parent = _body$1,
  					val;
  				childStyle.display = "inline-block";
  				childStyle.position = "relative";
  				div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
  				div.appendChild(child);
  				parent.appendChild(div);
  				val = (child.offsetHeight + 18 > div.scrollHeight); //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.
  				parent.removeChild(div);
  				return val;
  			}());
  			_touchEventLookup = (function(types) { //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
  				let standard = types.split(","),
  					converted = (!_isUndefined$1(_tempDiv$1.onpointerdown) ? "pointerdown,pointermove,pointerup,pointercancel" : !_isUndefined$1(_tempDiv$1.onmspointerdown) ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
  					obj = {},
  					i = 4;
  				while (--i > -1) {
  					obj[standard[i]] = converted[i];
  					obj[converted[i]] = standard[i];
  				}
  				//to avoid problems in iOS 9, test to see if the browser supports the "passive" option on addEventListener().
  				try {
  					_docElement$2.addEventListener("test", null, Object.defineProperty({}, "passive", {
  						get: function () {
  							_supportsPassive = 1;
  						}
  					}));
  				} catch (e) {}
  				return obj;
  			}("touchstart,touchmove,touchend,touchcancel"));
  			_addListener(_doc$3, "touchcancel", _emptyFunc$1); //some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
  			_addListener(_win$4, "touchmove", _emptyFunc$1); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.
  			_body$1 && _body$1.addEventListener("touchstart", _emptyFunc$1); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
  			_addListener(_doc$3, "contextmenu", function() {
  				for (let p in _lookup) {
  					if (_lookup[p].isPressed) {
  						_lookup[p].endDrag();
  					}
  				}
  			});
  			gsap$4 = _coreInitted$4 = _getGSAP$3();
  		}
  		if (gsap$4) {
  			InertiaPlugin = gsap$4.plugins.inertia;
  			_checkPrefix = gsap$4.utils.checkPrefix;
  			_transformProp$2 = _checkPrefix(_transformProp$2);
  			_transformOriginProp$2 = _checkPrefix(_transformOriginProp$2);
  			_toArray$3 = gsap$4.utils.toArray;
  			_supports3D$1 = !!_checkPrefix("perspective");
  		} else if (required) {
  			console.warn("Please gsap.registerPlugin(Draggable)");
  		}
  	};






  class EventDispatcher {

  	constructor(target) {
  		this._listeners = {};
  		this.target = target || this;
  	}

  	addEventListener(type, callback) {
  		let list = this._listeners[type] || (this._listeners[type] = []);
  		if (!~list.indexOf(callback)) {
  			list.push(callback);
  		}
  	}

  	removeEventListener(type, callback) {
  		let list = this._listeners[type],
  			i = (list && list.indexOf(callback)) || -1;
  		(i > -1) && list.splice(i, 1);
  	}

  	dispatchEvent(type) {
  		let result;
  		(this._listeners[type] || []).forEach(callback => (callback.call(this, {type: type, target: this.target}) === false) && (result = false));
  		return result; //if any of the callbacks return false, pass that along.
  	}
  }









  class Draggable extends EventDispatcher {

  	constructor(target, vars) {
  		super();
  		if (!gsap$4) {
  			_initCore$4(1);
  		}
  		target = _toArray$3(target)[0]; //in case the target is a selector object or selector text
  		if (!InertiaPlugin) {
  			InertiaPlugin = gsap$4.plugins.inertia;
  		}
  		this.vars = vars = _copy(vars || {});
  		this.target = target;
  		this.x = this.y = this.rotation = 0;
  		this.dragResistance = parseFloat(vars.dragResistance) || 0;
  		this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
  		this.lockAxis = vars.lockAxis;
  		this.autoScroll = vars.autoScroll || 0;
  		this.lockedAxis = null;
  		this.allowEventDefault = !!vars.allowEventDefault;

  		gsap$4.getProperty(target, "x"); // to ensure that transforms are instantiated.

  		let type = (vars.type || "x,y").toLowerCase(),
  			xyMode = (~type.indexOf("x") || ~type.indexOf("y")),
  			rotationMode = (type.indexOf("rotation") !== -1),
  			xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
  			yProp = xyMode ? "y" : "top",
  			allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),
  			allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),
  			minimumMovement = vars.minimumMovement || 2,
  			self = this,
  			triggers = _toArray$3(vars.trigger || vars.handle || target),
  			killProps = {},
  			dragEndTime = 0,
  			checkAutoScrollBounds = false,
  			autoScrollMarginTop = vars.autoScrollMarginTop || 40,
  			autoScrollMarginRight = vars.autoScrollMarginRight || 40,
  			autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
  			autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
  			isClickable = vars.clickableTest || _isClickable,
  			clickTime = 0,
  			gsCache = target._gsap || gsap$4.core.getCache(target),
  			isFixed = _isFixed$1(target),
  			getPropAsNum = (property, unit) => parseFloat(gsCache.get(target, property, unit)),
  			ownerDoc = target.ownerDocument || _doc$3,
  			enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault,

  			onContextMenu = e => { //used to prevent long-touch from triggering a context menu.
  				// (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.
  				_preventDefault(e);
  				e.stopImmediatePropagation && e.stopImmediatePropagation();
  				return false;
  			},

  			//this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
  			render = suppressEvents => {
  				if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
  					let e = target,
  						autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better "feel" speed-wise.
  						parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
  					checkAutoScrollBounds = false;
  					_windowProxy.scrollTop = ((_win$4.pageYOffset != null) ? _win$4.pageYOffset : (ownerDoc.documentElement.scrollTop != null) ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop);
  					_windowProxy.scrollLeft = ((_win$4.pageXOffset != null) ? _win$4.pageXOffset : (ownerDoc.documentElement.scrollLeft != null) ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft);
  					pointerX = self.pointerX - _windowProxy.scrollLeft;
  					pointerY = self.pointerY - _windowProxy.scrollTop;
  					while (e && !isRoot) { //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
  						isRoot = _isRoot(e.parentNode);
  						parent = isRoot ? _windowProxy : e.parentNode;
  						rect = isRoot ? {bottom:Math.max(_docElement$2.clientHeight, _win$4.innerHeight || 0), right: Math.max(_docElement$2.clientWidth, _win$4.innerWidth || 0), left:0, top:0} : parent.getBoundingClientRect();
  						changeX = changeY = 0;
  						if (allowY) {
  							gap = parent._gsMaxScrollY - parent.scrollTop;
  							if (gap < 0) {
  								changeY = gap;
  							} else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
  								checkAutoScrollBounds = true;
  								changeY = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.bottom - pointerY)) / autoScrollMarginBottom)) | 0);
  							} else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
  								checkAutoScrollBounds = true;
  								changeY = -Math.min(parent.scrollTop, (autoScrollFactor * (1 - Math.max(0, (pointerY - rect.top)) / autoScrollMarginTop)) | 0);
  							}
  							if (changeY) {
  								parent.scrollTop += changeY;
  							}
  						}
  						if (allowX) {
  							gap = parent._gsMaxScrollX - parent.scrollLeft;
  							if (gap < 0) {
  								changeX = gap;
  							} else if (pointerX > rect.right - autoScrollMarginRight && gap) {
  								checkAutoScrollBounds = true;
  								changeX = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.right - pointerX)) / autoScrollMarginRight)) | 0);
  							} else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
  								checkAutoScrollBounds = true;
  								changeX = -Math.min(parent.scrollLeft, (autoScrollFactor * (1 - Math.max(0, (pointerX - rect.left)) / autoScrollMarginLeft)) | 0);
  							}
  							if (changeX) {
  								parent.scrollLeft += changeX;
  							}
  						}

  						if (isRoot && (changeX || changeY)) {
  							_win$4.scrollTo(parent.scrollLeft, parent.scrollTop);
  							setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
  						}
  						e = parent;
  					}
  				}
  				if (dirty) {
  					let {x, y} = self;
  					if (rotationMode) {
  						self.deltaX = x - parseFloat(gsCache.rotation);
  						self.rotation = x;
  						gsCache.rotation = x + "deg";
  						gsCache.renderTransform(1, gsCache);
  					} else {
  						if (scrollProxy) {
  							if (allowY) {
  								self.deltaY = y - scrollProxy.top();
  								scrollProxy.top(y);
  							}
  							if (allowX) {
  								self.deltaX = x - scrollProxy.left();
  								scrollProxy.left(x);
  							}
  						} else if (xyMode) {
  							if (allowY) {
  								self.deltaY = y - parseFloat(gsCache.y);
  								gsCache.y = y + "px";
  							}
  							if (allowX) {
  								self.deltaX = x - parseFloat(gsCache.x);
  								gsCache.x = x + "px";
  							}
  							gsCache.renderTransform(1, gsCache);
  						} else {
  							if (allowY) {
  								self.deltaY = y - parseFloat(target.style.top || 0);
  								target.style.top = y + "px";
  							}
  							if (allowX) {
  								self.deltaY = x - parseFloat(target.style.left || 0);
  								target.style.left = x + "px";
  							}
  						}
  					}
  					if (hasDragCallback && !suppressEvents && !isDispatching) {
  						isDispatching = true; //in case onDrag has an update() call (avoid endless loop)
  						if (_dispatchEvent(self, "drag", "onDrag") === false) {
  							if (allowX) {
  								self.x -= self.deltaX;
  							}
  							if (allowY) {
  								self.y -= self.deltaY;
  							}
  							render(true);
  						}
  						isDispatching = false;
  					}
  				}
  				dirty = false;
  			},

  			//copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.
  			syncXY = (skipOnUpdate, skipSnap) => {
  				let { x, y } = self,
  					snappedValue, cs;
  				if (!target._gsap) { //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).
  					gsCache = gsap$4.core.getCache(target);
  				}
  				if (xyMode) {
  					self.x = parseFloat(gsCache.x);
  					self.y = parseFloat(gsCache.y);
  				} else if (rotationMode) {
  					self.x = self.rotation = parseFloat(gsCache.rotation);
  				} else if (scrollProxy) {
  					self.y = scrollProxy.top();
  					self.x = scrollProxy.left();
  				} else {
  					self.y = parseInt(target.style.top || ((cs = _getComputedStyle(target)) && cs.top), 10) || 0;
  					self.x = parseInt(target.style.left || (cs || {}).left, 10) || 0;
  				}
  				if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
  					if (snapXY) {
  						_temp1.x = self.x;
  						_temp1.y = self.y;
  						snappedValue = snapXY(_temp1);
  						if (snappedValue.x !== self.x) {
  							self.x = snappedValue.x;
  							dirty = true;
  						}
  						if (snappedValue.y !== self.y) {
  							self.y = snappedValue.y;
  							dirty = true;
  						}
  					}
  					if (snapX) {
  						snappedValue = snapX(self.x);
  						if (snappedValue !== self.x) {
  							self.x = snappedValue;
  							if (rotationMode) {
  								self.rotation = snappedValue;
  							}
  							dirty = true;
  						}
  					}
  					if (snapY) {
  						snappedValue = snapY(self.y);
  						if (snappedValue !== self.y) {
  							self.y = snappedValue;
  						}
  						dirty = true;
  					}
  				}
  				if (dirty) {
  					render(true);
  				}
  				if (!skipOnUpdate) {
  					self.deltaX = self.x - x;
  					self.deltaY = self.y - y;
  					_dispatchEvent(self, "throwupdate", "onThrowUpdate");
  				}
  			},

  			buildSnapFunc = (snap, min, max, factor) => {
  				if (min == null) {
  					min = -_bigNum$4;
  				}
  				if (max == null) {
  					max = _bigNum$4;
  				}
  				if (_isFunction$3(snap)) {
  					return n => {
  						let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
  						return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : (n < min) ? min + (n - min) * edgeTolerance : n)) * factor;
  					};
  				}
  				if (_isArray$1(snap)) {
  					return n => {
  						let i = snap.length,
  							closest = 0,
  							absDif = _bigNum$4,
  							val, dif;
  						while (--i > -1) {
  							val = snap[i];
  							dif = val - n;
  							if (dif < 0) {
  								dif = -dif;
  							}
  							if (dif < absDif && val >= min && val <= max) {
  								closest = i;
  								absDif = dif;
  							}
  						}
  						return snap[closest];
  					};
  				}
  				return isNaN(snap) ? n => n : () => snap * factor;
  			},

  			buildPointSnapFunc = (snap, minX, maxX, minY, maxY, radius, factor) => {
  				radius = (radius && radius < _bigNum$4) ? radius * radius : _bigNum$4; //so we don't have to Math.sqrt() in the functions. Performance optimization.
  				if (_isFunction$3(snap)) {
  					return point => {
  						let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
  							x = point.x,
  							y = point.y,
  							result, dx, dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
  						point.x = x = (x > maxX ? maxX + (x - maxX) * edgeTolerance : (x < minX) ? minX + (x - minX) * edgeTolerance : x);
  						point.y = y = (y > maxY ? maxY + (y - maxY) * edgeTolerance : (y < minY) ? minY + (y - minY) * edgeTolerance : y);
  						result = snap.call(self, point);
  						if (result !== point) {
  							point.x = result.x;
  							point.y = result.y;
  						}
  						if (factor !== 1) {
  							point.x *= factor;
  							point.y *= factor;
  						}
  						if (radius < _bigNum$4) {
  							dx = point.x - x;
  							dy = point.y - y;
  							if (dx * dx + dy * dy > radius) {
  								point.x = x;
  								point.y = y;
  							}
  						}
  						return point;
  					};
  				}
  				if (_isArray$1(snap)) {
  					return p => {
  						let i = snap.length,
  							closest = 0,
  							minDist = _bigNum$4,
  							x, y, point, dist;
  						while (--i > -1) {
  							point = snap[i];
  							x = point.x - p.x;
  							y = point.y - p.y;
  							dist = x * x + y * y;
  							if (dist < minDist) {
  								closest = i;
  								minDist = dist;
  							}
  						}
  						return (minDist <= radius) ? snap[closest] : p;
  					};
  				}
  				return n => n;
  			},

  			calculateBounds = () => {
  				let bounds, targetBounds, snap, snapIsRaw;
  				hasBounds = false;
  				if (scrollProxy) {
  					scrollProxy.calibrate();
  					self.minX = minX = -scrollProxy.maxScrollLeft();
  					self.minY = minY = -scrollProxy.maxScrollTop();
  					self.maxX = maxX = self.maxY = maxY = 0;
  					hasBounds = true;
  				} else if (!!vars.bounds) {
  					bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}
  					if (rotationMode) {
  						self.minX = minX = bounds.left;
  						self.maxX = maxX = bounds.left + bounds.width;
  						self.minY = minY = self.maxY = maxY = 0;
  					} else if (!_isUndefined$1(vars.bounds.maxX) || !_isUndefined$1(vars.bounds.maxY)) {
  						bounds = vars.bounds;
  						self.minX = minX = bounds.minX;
  						self.minY = minY = bounds.minY;
  						self.maxX = maxX = bounds.maxX;
  						self.maxY = maxY = bounds.maxY;
  					} else {
  						targetBounds = _getBounds(target, target.parentNode);
  						self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left - 0.5);
  						self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top - 0.5);
  						self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
  						self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
  					}
  					if (minX > maxX) {
  						self.minX = maxX;
  						self.maxX = maxX = minX;
  						minX = self.minX;
  					}
  					if (minY > maxY) {
  						self.minY = maxY;
  						self.maxY = maxY = minY;
  						minY = self.minY;
  					}
  					if (rotationMode) {
  						self.minRotation = minX;
  						self.maxRotation = maxX;
  					}
  					hasBounds = true;
  				}
  				if (vars.liveSnap) {
  					snap = (vars.liveSnap === true) ? (vars.snap || {}) : vars.liveSnap;
  					snapIsRaw = (_isArray$1(snap) || _isFunction$3(snap));
  					if (rotationMode) {
  						snapX = buildSnapFunc((snapIsRaw ? snap : snap.rotation), minX, maxX, 1);
  						snapY = null;
  					} else {
  						if (snap.points) {
  							snapXY = buildPointSnapFunc((snapIsRaw ? snap : snap.points), minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
  						} else {
  							if (allowX) {
  								snapX = buildSnapFunc((snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft), minX, maxX, scrollProxy ? -1 : 1);
  							}
  							if (allowY) {
  								snapY = buildSnapFunc((snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop), minY, maxY, scrollProxy ? -1 : 1);
  							}
  						}
  					}
  				}
  			},

  			onThrowComplete = () => {
  				self.isThrowing = false;
  				_dispatchEvent(self, "throwcomplete", "onThrowComplete");
  			},
  			onThrowInterrupt = () => {
  				self.isThrowing = false;
  			},

  			animate = (inertia, forceZeroVelocity) => {
  				let snap, snapIsRaw, tween, overshootTolerance;
  				if (inertia && InertiaPlugin) {
  					if (inertia === true) {
  						snap = vars.snap || vars.liveSnap || {};
  						snapIsRaw = (_isArray$1(snap) || _isFunction$3(snap));
  						inertia = {resistance:(vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)};
  						if (rotationMode) {
  							inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
  						} else {
  							if (allowX) {
  								inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "x"));
  							}
  							if (allowY) {
  								inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "y"));
  							}
  							if (snap.points || (_isArray$1(snap) && _isObject$1(snap[0]))) {
  								inertia.linkedProps = xProp + "," + yProp;
  								inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.
  							}
  						}
  					}
  					self.isThrowing = true;
  					overshootTolerance = (!isNaN(vars.overshootTolerance)) ? vars.overshootTolerance : (vars.edgeResistance === 1) ? 0 : (1 - self.edgeResistance) + 0.2;
  					if (!inertia.duration) {
  						inertia.duration = {max: Math.max(vars.minDuration || 0, ("maxDuration" in vars) ? vars.maxDuration : 2), min: (!isNaN(vars.minDuration) ? vars.minDuration : (overshootTolerance === 0 || (_isObject$1(inertia) && inertia.resistance > 1000)) ? 0 : 0.5), overshoot: overshootTolerance};
  					}
  					self.tween = tween = gsap$4.to(scrollProxy || target, {
  						inertia: inertia,
  						data: "_draggable",
  						onComplete: onThrowComplete,
  						onInterrupt: onThrowInterrupt,
  						onUpdate: (vars.fastMode ? _dispatchEvent : syncXY),
  						onUpdateParams: (vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : (snap && snap.radius) ? [false, true] : [])
  					});
  					if (!vars.fastMode) {
  						if (scrollProxy) {
  							scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
  						}
  						tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.
  						syncXY(true, true);
  						self.endX = self.x;
  						self.endY = self.y;
  						if (rotationMode) {
  							self.endRotation = self.x;
  						}
  						tween.play(0);
  						syncXY(true, true);
  						if (scrollProxy) {
  							scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
  						}
  					}
  				} else if (hasBounds) {
  					self.applyBounds();
  				}
  			},

  			updateMatrix = shiftStart => {
  				let start = matrix,
  					p;
  				matrix = getGlobalMatrix(target.parentNode, true);
  				if (shiftStart && self.isPressed && !matrix.equals(start || new Matrix2D())) { //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
  					p = start.inverse().apply({x:startPointerX, y:startPointerY});
  					matrix.apply(p, p);
  					startPointerX = p.x;
  					startPointerY = p.y;
  				}
  				if (matrix.equals(_identityMatrix$1)) { //if there are no transforms, we can optimize performance by not factoring in the matrix
  					matrix = null;
  				}
  			},

  			recordStartPositions = () => {
  				let edgeTolerance = 1 - self.edgeResistance,
  					parsedOrigin, x, y;
  				updateMatrix(false);
  				if (matrix) {
  					_point1.x = self.pointerX;
  					_point1.y = self.pointerY;
  					matrix.apply(_point1, _point1);
  					startPointerX = _point1.x; //translate to local coordinate system
  					startPointerY = _point1.y;
  				}
  				if (dirty) {
  					setPointerPosition(self.pointerX, self.pointerY);
  					render(true);
  				}
  				if (scrollProxy) {
  					calculateBounds();
  					startElementY = scrollProxy.top();
  					startElementX = scrollProxy.left();
  				} else {
  					//if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
  					if (isTweening()) {
  						syncXY(true, true);
  						calculateBounds();
  					} else {
  						self.applyBounds();
  					}
  					if (rotationMode) {
  						parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp$2] || "0 0").split(" ");
  						rotationOrigin = self.rotationOrigin = getGlobalMatrix(target).apply({x: parseFloat(parsedOrigin[0]) || 0, y: parseFloat(parsedOrigin[1]) || 0});
  						syncXY(true, true);
  						x = self.pointerX - rotationOrigin.x;
  						y = rotationOrigin.y - self.pointerY;
  						if (isFixed) {
  							x -= _getDocScrollLeft$1(ownerDoc);
  							y += _getDocScrollTop$1(ownerDoc);
  						}
  						startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)
  						startElementY = self.y = Math.atan2(y, x) * _RAD2DEG$1;
  					} else {
  						//parent = !isFixed && target.parentNode;
  						//startScrollTop = parent ? parent.scrollTop || 0 : 0;
  						//startScrollLeft = parent ? parent.scrollLeft || 0 : 0;
  						startElementY = getPropAsNum(yProp, "px"); //record the starting top and left values so that we can just add the mouse's movement to them later.
  						startElementX = getPropAsNum(xProp, "px");
  					}
  				}

  				if (hasBounds && edgeTolerance) {
  					if (startElementX > maxX) {
  						startElementX = maxX + (startElementX - maxX) / edgeTolerance;
  					} else if (startElementX < minX) {
  						startElementX = minX - (minX - startElementX) / edgeTolerance;
  					}
  					if (!rotationMode) {
  						if (startElementY > maxY) {
  							startElementY = maxY + (startElementY - maxY) / edgeTolerance;
  						} else if (startElementY < minY) {
  							startElementY = minY - (minY - startElementY) / edgeTolerance;
  						}
  					}
  				}
  				self.startX = startElementX;
  				self.startY = startElementY;
  			},

  			isTweening = () => self.tween && self.tween.isActive(),

  			removePlaceholder = () => {
  				if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) { //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
  					_placeholderDiv.parentNode.removeChild(_placeholderDiv);
  				}
  			},

  			//called when the mouse is pressed (or touch starts)
  			onPress = (e, force) => {
  				let i;
  				if (!enabled || self.isPressed || !e || ((e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type])) { //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
  					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
  					return;
  				}
  				interrupted = isTweening();
  				self.pointerEvent = e;
  				if (_touchEventLookup[e.type]) { //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
  					touchEventTarget = ~e.type.indexOf("touch") ? (e.currentTarget || e.target) : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".
  					_addListener(touchEventTarget, "touchend", onRelease);
  					_addListener(touchEventTarget, "touchmove", onMove);
  					_addListener(touchEventTarget, "touchcancel", onRelease);
  					_addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
  				} else {
  					touchEventTarget = null;
  					_addListener(ownerDoc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.
  				}
  				touchDragAxis = null;
  				if (!_supportsPointer  || !touchEventTarget) {
  					_addListener(ownerDoc, "mouseup", onRelease);
  					if (e && e.target) {
  						_addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
  					}
  				}
  				isClicking = (isClickable.call(self, e.target) && vars.dragClickables === false && !force);
  				if (isClicking) {
  					_addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.
  					_dispatchEvent(self, "pressInit", "onPressInit");
  					_dispatchEvent(self, "press", "onPress");
  					_setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)
  					return;
  				}
  				allowNativeTouchScrolling = (!touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || (self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2))) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.
  				isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;
  				if (isPreventingDefault) {
  					_preventDefault(e);
  					_addListener(_win$4, "touchforcechange", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
  				}
  				if (e.changedTouches) { //touch events store the data slightly differently
  					e = touch = e.changedTouches[0];
  					touchID = e.identifier;
  				} else if (e.pointerId) {
  					touchID = e.pointerId; //for some Microsoft browsers
  				} else {
  					touch = touchID = null;
  				}
  				_dragCount++;
  				_addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)
  				startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove
  				startPointerX = self.pointerX = e.pageX;
  				_dispatchEvent(self, "pressInit", "onPressInit");
  				if (allowNativeTouchScrolling || self.autoScroll) {
  					_recordMaxScrolls(target.parentNode);
  				}
  				if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) { //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
  					_placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
  					target.parentNode.appendChild(_placeholderDiv);
  				}
  				recordStartPositions();
  				self.tween && self.tween.kill();
  				self.isThrowing = false;
  				gsap$4.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.
  				scrollProxy && gsap$4.killTweensOf(target, {scrollTo:1}, true); //just in case the original target's scroll position is being tweened somewhere else.
  				self.tween = self.lockedAxis = null;
  				if (vars.zIndexBoost || (!rotationMode && !scrollProxy && vars.zIndexBoost !== false)) {
  					target.style.zIndex = Draggable.zIndex++;
  				}
  				self.isPressed = true;
  				hasDragCallback = !!(vars.onDrag || self._listeners.drag);
  				hasMoveCallback = !!(vars.onMove || self._listeners.move);
  				if (!rotationMode && (vars.cursor !== false || vars.activeCursor)) {
  					i = triggers.length;
  					while (--i > -1) {
  						//_setStyle(triggers[i], "cursor", vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor));
  						gsap$4.set(triggers[i], {cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)});
  					}
  				}
  				_dispatchEvent(self, "press", "onPress");
  			},

  			//called every time the mouse/touch moves
  			onMove = e => {
  				let originalEvent = e,
  					touches, pointerX, pointerY, i, dx, dy;
  				if (!enabled || _isMultiTouching || !self.isPressed || !e) {
  					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
  					return;
  				}
  				self.pointerEvent = e;
  				touches = e.changedTouches;
  				if (touches) { //touch events store the data slightly differently
  					e = touches[0];
  					if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
  						i = touches.length;
  						while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
  						if (i < 0) {
  							return;
  						}
  					}
  				} else if (e.pointerId && touchID && e.pointerId !== touchID) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
  					return;
  				}

  				if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) { //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
  					_point1.x = e.pageX;
  					_point1.y = e.pageY;
  					matrix && matrix.apply(_point1, _point1);
  					pointerX = _point1.x;
  					pointerY = _point1.y;
  					dx = Math.abs(pointerX - startPointerX);
  					dy = Math.abs(pointerY - startPointerY);
  					if ((dx !== dy && (dx > minimumMovement || dy > minimumMovement)) || (_isAndroid && allowNativeTouchScrolling === touchDragAxis)) {
  						touchDragAxis = (dx > dy && allowX) ? "x" : "y";
  						if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
  							_addListener(_win$4, "touchforcechange", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari
  						}
  						if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
  							self.lockedAxis = (touchDragAxis === "x") ? "y" : "x";
  							_isFunction$3(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);
  						}
  						if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
  							onRelease(originalEvent);
  							return;
  						}
  					}
  				}
  				if (!self.allowEventDefault && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling !== touchDragAxis)) && originalEvent.cancelable !== false) {
  					_preventDefault(originalEvent);
  					isPreventingDefault = true;
  				} else if (isPreventingDefault) {
  					isPreventingDefault = false;
  				}

  				if (self.autoScroll) {
  					checkAutoScrollBounds = true;
  				}
  				setPointerPosition(e.pageX - (isFixed && rotationMode ? _getDocScrollLeft$1(ownerDoc) : 0), e.pageY - (isFixed && rotationMode ? _getDocScrollTop$1(ownerDoc) : 0), hasMoveCallback);
  			},

  			setPointerPosition = (pointerX, pointerY, invokeOnMove) => {
  				let dragTolerance = 1 - self.dragResistance,
  					edgeTolerance = 1 - self.edgeResistance,
  					prevPointerX = self.pointerX,
  					prevPointerY = self.pointerY,
  					prevStartElementY = startElementY,
  					prevX = self.x,
  					prevY = self.y,
  					prevEndX = self.endX,
  					prevEndY = self.endY,
  					prevEndRotation = self.endRotation,
  					prevDirty = dirty,
  					xChange, yChange, x, y, dif, temp;
  				self.pointerX = pointerX;
  				self.pointerY = pointerY;
  				if (rotationMode) {
  					y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG$1;
  					dif = self.y - y;
  					if (dif > 180) {
  						startElementY -= 360;
  						self.y = y;
  					} else if (dif < -180) {
  						startElementY += 360;
  						self.y = y;
  					}
  					if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
  						self.y = y;
  						x = startElementX + (startElementY - y) * dragTolerance;
  					} else {
  						x = startElementX;
  					}

  				} else {
  					if (matrix) {
  						temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
  						pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
  						pointerX = temp;
  					}
  					yChange = (pointerY - startPointerY);
  					xChange = (pointerX - startPointerX);
  					if (yChange < minimumMovement && yChange > -minimumMovement) {
  						yChange = 0;
  					}
  					if (xChange < minimumMovement && xChange > -minimumMovement) {
  						xChange = 0;
  					}
  					if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
  						temp = self.lockedAxis;
  						if (!temp) {
  							self.lockedAxis = temp = (allowX && Math.abs(xChange) > Math.abs(yChange)) ? "y" : allowY ? "x" : null;
  							if (temp && _isFunction$3(self.vars.onLockAxis)) {
  								self.vars.onLockAxis.call(self, self.pointerEvent);
  							}
  						}
  						if (temp === "y") {
  							yChange = 0;
  						} else if (temp === "x") {
  							xChange = 0;
  						}
  					}
  					x = _round$4(startElementX + xChange * dragTolerance);
  					y = _round$4(startElementY + yChange * dragTolerance);
  				}

  				if ((snapX || snapY || snapXY) && (self.x !== x || (self.y !== y && !rotationMode))) {
  					if (snapXY) {
  						_temp1.x = x;
  						_temp1.y = y;
  						temp = snapXY(_temp1);
  						x = _round$4(temp.x);
  						y = _round$4(temp.y);
  					}
  					if (snapX) {
  						x = _round$4(snapX(x));
  					}
  					if (snapY) {
  						y = _round$4(snapY(y));
  					}
  				} else if (hasBounds) {
  					if (x > maxX) {
  						x = maxX + Math.round((x - maxX) * edgeTolerance);
  					} else if (x < minX) {
  						x = minX + Math.round((x - minX) * edgeTolerance);
  					}
  					if (!rotationMode) {
  						if (y > maxY) {
  							y = Math.round(maxY + (y - maxY) * edgeTolerance);
  						} else if (y < minY) {
  							y = Math.round(minY + (y - minY) * edgeTolerance);
  						}
  					}
  				}
  				if (self.x !== x || (self.y !== y && !rotationMode)) {
  					if (rotationMode) {
  						self.endRotation = self.x = self.endX = x;
  						dirty = true;
  					} else {
  						if (allowY) {
  							self.y = self.endY = y;
  							dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
  						}
  						if (allowX) {
  							self.x = self.endX = x;
  							dirty = true;
  						}
  					}
  					if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {
  						if (!self.isDragging && self.isPressed) {
  							self.isDragging = true;
  							_dispatchEvent(self, "dragstart", "onDragStart");
  						}
  					} else { //revert because the onMove returned false!
  						self.pointerX = prevPointerX;
  						self.pointerY = prevPointerY;
  						startElementY = prevStartElementY;
  						self.x = prevX;
  						self.y = prevY;
  						self.endX = prevEndX;
  						self.endY = prevEndY;
  						self.endRotation = prevEndRotation;
  						dirty = prevDirty;
  					}
  				}
  			},

  			//called when the mouse/touch is released
  			onRelease = (e, force) => {
  				if (!enabled || !self.isPressed || (e && touchID != null && !force && ((e.pointerId && e.pointerId !== touchID) || (e.changedTouches && !_hasTouchID(e.changedTouches, touchID))))) {  //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
  					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
  					return;
  				}
  				self.isPressed = false;
  				let originalEvent = e,
  					wasDragging = self.isDragging,
  					isContextMenuRelease = (self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2)),
  					placeholderDelayedCall = gsap$4.delayedCall(0.001, removePlaceholder),
  					touches, i, syntheticEvent, eventTarget, syntheticClick;
  				if (touchEventTarget) {
  					_removeListener(touchEventTarget, "touchend", onRelease);
  					_removeListener(touchEventTarget, "touchmove", onMove);
  					_removeListener(touchEventTarget, "touchcancel", onRelease);
  					_removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
  				} else {
  					_removeListener(ownerDoc, "mousemove", onMove);
  				}
  				_removeListener(_win$4, "touchforcechange", _preventDefault);
  				if (!_supportsPointer || !touchEventTarget) {
  					_removeListener(ownerDoc, "mouseup", onRelease);
  					if (e && e.target) {
  						_removeListener(e.target, "mouseup", onRelease);
  					}
  				}
  				dirty = false;
  				if (isClicking && !isContextMenuRelease) {
  					if (e) {
  						_removeListener(e.target, "change", onRelease);
  						self.pointerEvent = originalEvent;
  					}
  					_setSelectable(triggers, false);
  					_dispatchEvent(self, "release", "onRelease");
  					_dispatchEvent(self, "click", "onClick");
  					isClicking = false;
  					return;
  				}
  				_removeFromRenderQueue(render);
  				if (!rotationMode) {
  					i = triggers.length;
  					while (--i > -1) {
  						_setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
  					}
  				}
  				if (wasDragging) {
  					dragEndTime = _lastDragTime = _getTime();
  					self.isDragging = false;
  				}
  				_dragCount--;
  				if (e) {
  					touches = e.changedTouches;
  					if (touches) { //touch events store the data slightly differently
  						e = touches[0];
  						if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
  							i = touches.length;
  							while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
  							if (i < 0) {
  								return;
  							}
  						}
  					}
  					self.pointerEvent = originalEvent;
  					self.pointerX = e.pageX;
  					self.pointerY = e.pageY;
  				}
  				if (isContextMenuRelease && originalEvent) {
  					_preventDefault(originalEvent);
  					isPreventingDefault = true;
  					_dispatchEvent(self, "release", "onRelease");
  				} else if (originalEvent && !wasDragging) {
  					isPreventingDefault = false;
  					if (interrupted && (vars.snap || vars.bounds)) { //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
  						animate(vars.inertia || vars.throwProps);
  					}
  					_dispatchEvent(self, "release", "onRelease");
  					if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) { //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
  						_dispatchEvent(self, "click", "onClick");
  						if (_getTime() - clickTime < 300) {
  							_dispatchEvent(self, "doubleclick", "onDoubleClick");
  						}
  						eventTarget = originalEvent.target || target; //old IE uses srcElement
  						clickTime = _getTime();
  						syntheticClick = () => { // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
  							if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {
  								if (eventTarget.click) { //some browsers (like mobile Safari) don't properly trigger the click event
  									eventTarget.click();
  								} else if (ownerDoc.createEvent) {
  									syntheticEvent = ownerDoc.createEvent("MouseEvents");
  									syntheticEvent.initMouseEvent("click", true, true, _win$4, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
  									eventTarget.dispatchEvent(syntheticEvent);
  								}
  							}
  						};
  						if (!_isAndroid && !originalEvent.defaultPrevented) { //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
  							gsap$4.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's "trusted".
  						}
  					}
  				} else {
  					animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or IntertiaPlugin isn't loaded.
  					if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling === touchDragAxis)) && originalEvent.cancelable !== false) {
  						isPreventingDefault = true;
  						_preventDefault(originalEvent);
  					} else {
  						isPreventingDefault = false;
  					}
  					_dispatchEvent(self, "release", "onRelease");
  				}
  				isTweening() && placeholderDelayedCall.duration( self.tween.duration() ); //sync the timing so that the placeholder DIV gets
  				wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");
  				return true;
  			},

  			updateScroll = e => {
  				if (e && self.isDragging && !scrollProxy) {
  					let parent = e.target || target.parentNode,
  						deltaX = parent.scrollLeft - parent._gsScrollX,
  						deltaY = parent.scrollTop - parent._gsScrollY;
  					if (deltaX || deltaY) {
  						if (matrix) {
  							startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
  							startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
  						} else {
  							startPointerX -= deltaX;
  							startPointerY -= deltaY;
  						}
  						parent._gsScrollX += deltaX;
  						parent._gsScrollY += deltaY;
  						setPointerPosition(self.pointerX, self.pointerY);
  					}
  				}
  			},

  			onClick = e => { //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
  				let time = _getTime(),
  					recentlyClicked = (time - clickTime < 40),
  					recentlyDragged = (time - dragEndTime < 40),
  					alreadyDispatched = (recentlyClicked && clickDispatch === clickTime),
  					defaultPrevented = (self.pointerEvent && self.pointerEvent.defaultPrevented),
  					alreadyDispatchedTrusted = (recentlyClicked && trustedClickDispatch === clickTime),
  					trusted = e.isTrusted || (e.isTrusted == null && recentlyClicked && alreadyDispatched); //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?
  				if ((alreadyDispatched || (recentlyDragged && self.vars.suppressClickOnDrag !== false) ) && e.stopImmediatePropagation) {
  					e.stopImmediatePropagation();
  				}
  				if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || (trusted && !alreadyDispatchedTrusted))) { //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
  					if (trusted && alreadyDispatched) {
  						trustedClickDispatch = clickTime;
  					}
  					clickDispatch = clickTime;
  					return;
  				}
  				if (self.isPressed || recentlyDragged || recentlyClicked) {
  					if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
  						_preventDefault(e);
  					}
  				}
  			},

  			localizePoint = p => matrix ? {x:p.x * matrix.a + p.y * matrix.c + matrix.e, y:p.x * matrix.b + p.y * matrix.d + matrix.f} : {x:p.x, y:p.y};

  		old = Draggable.get(target);
  		if (old) {
  			old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
  		}

  		//give the user access to start/stop dragging...
  		this.startDrag = (event, align) => {
  			let r1, r2, p1, p2;
  			onPress(event || self.pointerEvent, true);
  			//if the pointer isn't on top of the element, adjust things accordingly
  			if (align && !self.hitTest(event || self.pointerEvent)) {
  				r1 = _parseRect(event || self.pointerEvent);
  				r2 = _parseRect(target);
  				p1 = localizePoint({x:r1.left + r1.width / 2, y:r1.top + r1.height / 2});
  				p2 = localizePoint({x:r2.left + r2.width / 2, y:r2.top + r2.height / 2});
  				startPointerX -= p1.x - p2.x;
  				startPointerY -= p1.y - p2.y;
  			}
  			if (!self.isDragging) {
  				self.isDragging = true;
  				_dispatchEvent(self, "dragstart", "onDragStart");
  			}
  		};
  		this.drag = onMove;
  		this.endDrag = e =>	onRelease(e || self.pointerEvent, true);
  		this.timeSinceDrag = () => self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
  		this.timeSinceClick = () => (_getTime() - clickTime) / 1000;
  		this.hitTest = (target, threshold) => Draggable.hitTest(self.target, target, threshold);

  		this.getDirection = (from, diagonalThreshold) => { //from can be "start" (default), "velocity", or an element
  			let mode = (from === "velocity" && InertiaPlugin) ? from : (_isObject$1(from) && !rotationMode) ? "element" : "start",
  				xChange, yChange, ratio, direction, r1, r2;
  			if (mode === "element") {
  				r1 = _parseRect(self.target);
  				r2 = _parseRect(from);
  			}
  			xChange = (mode === "start") ? self.x - startElementX : (mode === "velocity") ? InertiaPlugin.getVelocity(target, xProp) : (r1.left + r1.width / 2) - (r2.left + r2.width / 2);
  			if (rotationMode) {
  				return xChange < 0 ? "counter-clockwise" : "clockwise";
  			} else {
  				diagonalThreshold = diagonalThreshold || 2;
  				yChange = (mode === "start") ? self.y - startElementY : (mode === "velocity") ? InertiaPlugin.getVelocity(target, yProp) : (r1.top + r1.height / 2) - (r2.top + r2.height / 2);
  				ratio = Math.abs(xChange / yChange);
  				direction = (ratio < 1 / diagonalThreshold) ? "" : (xChange < 0) ? "left" : "right";
  				if (ratio < diagonalThreshold) {
  					if (direction !== "") {
  						direction += "-";
  					}
  					direction += (yChange < 0) ? "up" : "down";
  				}
  			}
  			return direction;
  		};

  		this.applyBounds = (newBounds, sticky) => {
  			let x, y, forceZeroVelocity, e, parent, isRoot;
  			if (newBounds && vars.bounds !== newBounds) {
  				vars.bounds = newBounds;
  				return self.update(true, sticky);
  			}
  			syncXY(true);
  			calculateBounds();
  			if (hasBounds && !isTweening()) {
  				x = self.x;
  				y = self.y;
  				if (x > maxX) {
  					x = maxX;
  				} else if (x < minX) {
  					x = minX;
  				}
  				if (y > maxY) {
  					y = maxY;
  				} else if (y < minY) {
  					y = minY;
  				}
  				if (self.x !== x || self.y !== y) {
  					forceZeroVelocity = true;
  					self.x = self.endX = x;
  					if (rotationMode) {
  						self.endRotation = x;
  					} else {
  						self.y = self.endY = y;
  					}
  					dirty = true;
  					render(true);
  					if (self.autoScroll && !self.isDragging) {
  						_recordMaxScrolls(target.parentNode);
  						e = target;
  						_windowProxy.scrollTop = ((_win$4.pageYOffset != null) ? _win$4.pageYOffset : (ownerDoc.documentElement.scrollTop != null) ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop);
  						_windowProxy.scrollLeft = ((_win$4.pageXOffset != null) ? _win$4.pageXOffset : (ownerDoc.documentElement.scrollLeft != null) ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft);
  						while (e && !isRoot) { //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
  							isRoot = _isRoot(e.parentNode);
  							parent = isRoot ? _windowProxy : e.parentNode;
  							if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
  								parent.scrollTop = parent._gsMaxScrollY;
  							}
  							if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
  								parent.scrollLeft = parent._gsMaxScrollX;
  							}
  							e = parent;
  						}
  					}
  				}
  				if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
  					animate(vars.inertia || vars.throwProps, forceZeroVelocity);
  				}
  			}
  			return self;
  		};

  		this.update = (applyBounds, sticky, ignoreExternalChanges) => {
  			let { x, y } = self;
  			updateMatrix(!sticky);
  			if (applyBounds) {
  				self.applyBounds();
  			} else {
  				if (dirty && ignoreExternalChanges) {
  					render(true);
  				}
  				syncXY(true);
  			}
  			if (sticky) {
  				setPointerPosition(self.pointerX, self.pointerY);
  				dirty && render(true);
  			}
  			if (self.isPressed && !sticky && ((allowX && Math.abs(x - self.x) > 0.01) || (allowY && (Math.abs(y - self.y) > 0.01 && !rotationMode)))) {
  				recordStartPositions();
  			}
  			if (self.autoScroll) {
  				_recordMaxScrolls(target.parentNode, self.isDragging);
  				checkAutoScrollBounds = self.isDragging;
  				render(true);
  				//in case reparenting occurred.
  				_removeScrollListener(target, updateScroll);
  				_addScrollListener(target, updateScroll);
  			}
  			return self;
  		};

  		this.enable = type => {
  			let setVars = {lazy: true},
  				id, i, trigger;
  			if (!rotationMode && vars.cursor !== false) {
  				setVars.cursor = vars.cursor || _defaultCursor;
  			}
  			if (gsap$4.utils.checkPrefix("touchCallout")) {
  				setVars.touchCallout = "none";
  			}
  			setVars.touchAction = (allowX === allowY) ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x";
  			if (type !== "soft") {
  				i = triggers.length;
  				while (--i > -1) {
  					trigger = triggers[i];
  					_supportsPointer || _addListener(trigger, "mousedown", onPress);
  					_addListener(trigger, "touchstart", onPress);
  					_addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.
  					gsap$4.set(trigger, setVars);
  					if (trigger.getBBox && trigger.ownerSVGElement) { // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.
  						gsap$4.set(trigger.ownerSVGElement, {touchAction: (allowX === allowY) ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"});
  					}
  					vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
  				}
  				_setSelectable(triggers, false);
  			}
  			_addScrollListener(target, updateScroll);
  			enabled = true;
  			if (InertiaPlugin && type !== "soft") {
  				InertiaPlugin.track(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
  			}
  			target._gsDragID = id = "d" + (_lookupCount++);
  			_lookup[id] = self;
  			if (scrollProxy) {
  				scrollProxy.enable();
  				scrollProxy.element._gsDragID = id;
  			}
  			(vars.bounds || rotationMode) && recordStartPositions();
  			vars.bounds && self.applyBounds();
  			return self;
  		};

  		this.disable = type => {
  			let dragging = self.isDragging,
  				i, trigger;
  			if (!rotationMode) {
  				i = triggers.length;
  				while (--i > -1) {
  					_setStyle(triggers[i], "cursor", null);
  				}
  			}
  			if (type !== "soft") {
  				i = triggers.length;
  				while (--i > -1) {
  					trigger = triggers[i];
  					_setStyle(trigger, "touchCallout", null);
  					_setStyle(trigger, "touchAction", null);
  					_removeListener(trigger, "mousedown", onPress);
  					_removeListener(trigger, "touchstart", onPress);
  					_removeListener(trigger, "click", onClick);
  					_removeListener(trigger, "contextmenu", onContextMenu);
  				}
  				_setSelectable(triggers, true);
  				if (touchEventTarget) {
  					_removeListener(touchEventTarget, "touchcancel", onRelease);
  					_removeListener(touchEventTarget, "touchend", onRelease);
  					_removeListener(touchEventTarget, "touchmove", onMove);
  				}
  				_removeListener(ownerDoc, "mouseup", onRelease);
  				_removeListener(ownerDoc, "mousemove", onMove);
  			}
  			_removeScrollListener(target, updateScroll);
  			enabled = false;
  			if (InertiaPlugin && type !== "soft") {
  				InertiaPlugin.untrack(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
  			}
  			if (scrollProxy) {
  				scrollProxy.disable();
  			}
  			_removeFromRenderQueue(render);
  			self.isDragging = self.isPressed = isClicking = false;
  			if (dragging) {
  				_dispatchEvent(self, "dragend", "onDragEnd");
  			}
  			return self;
  		};

  		this.enabled = function(value, type) {
  			return arguments.length ? (value ? self.enable(type) : self.disable(type)) : enabled;
  		};

  		this.kill = function() {
  			self.isThrowing = false;
  			if (self.tween) {
  				self.tween.kill();
  			}
  			self.disable();
  			gsap$4.set(triggers, {clearProps:"userSelect"});
  			delete _lookup[target._gsDragID];
  			return self;
  		};

  		if (~type.indexOf("scroll")) {
  			scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({onKill:function() { //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
  					if (self.isPressed) {
  						onRelease(null);
  					}}}, vars));
  			//a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)
  			target.style.overflowY = (allowY && !_isTouchDevice) ? "auto" : "hidden";
  			target.style.overflowX = (allowX && !_isTouchDevice) ? "auto" : "hidden";
  			target = scrollProxy.content;
  		}

  		if (rotationMode) {
  			killProps.rotation = 1;
  		} else {
  			if (allowX) {
  				killProps[xProp] = 1;
  			}
  			if (allowY) {
  				killProps[yProp] = 1;
  			}
  		}

  		gsCache.force3D = ("force3D" in vars) ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.

  		this.enable();
  	}




  	static register(core) {
  		gsap$4 = core;
  		_initCore$4();
  	}

  	static create(targets, vars) {
  		if (!_coreInitted$4) {
  			_initCore$4(true);
  		}
  		return _toArray$3(targets).map(target => new Draggable(target, vars));
  	}

  	static get(target) {
  		return _lookup[(_toArray$3(target)[0] || {})._gsDragID];
  	}

  	static timeSinceDrag() {
  		return (_getTime() - _lastDragTime) / 1000;
  	}

  	static hitTest(obj1, obj2, threshold) {
  		if (obj1 === obj2) {
  			return false;
  		}
  		let r1 = _parseRect(obj1),
  			r2 = _parseRect(obj2),
  			{ top, left, right, bottom, width, height } = r1,
  			isOutside = (r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top),
  			overlap, area, isRatio;
  		if (isOutside || !threshold) {
  			return !isOutside;
  		}
  		isRatio = ((threshold + "").indexOf("%") !== -1);
  		threshold = parseFloat(threshold) || 0;
  		overlap = {left: Math.max(left, r2.left), top: Math.max(top, r2.top)};
  		overlap.width = Math.min(right, r2.right) - overlap.left;
  		overlap.height = Math.min(bottom, r2.bottom) - overlap.top;
  		if (overlap.width < 0 || overlap.height < 0) {
  			return false;
  		}
  		if (isRatio) {
  			threshold *= 0.01;
  			area = overlap.width * overlap.height;
  			return (area >= width * height * threshold || area >= r2.width * r2.height * threshold);
  		}
  		return (overlap.width > threshold && overlap.height > threshold);
  	}

  }

  _setDefaults$1(Draggable.prototype, {pointerX:0, pointerY: 0, startX: 0, startY: 0, deltaX: 0, deltaY: 0, isDragging: false, isPressed: false});

  Draggable.zIndex = 1000;
  Draggable.version = "3.4.0";

  _getGSAP$3() && gsap$4.registerPlugin(Draggable);

  /*!
   * GSDevTools 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  let gsap$5, _coreInitted$5, _doc$4, _docEl, _win$5, _recordedRoot, Animation$1, _rootTween, _rootInstance, _keyboardInstance, _globalTimeline$1, _independentRoot, _delayedCall,
  	_startupPhase = true, //for the first 2 seconds, we don't record any zero-duration tweens because they're typically just setup stuff and/or the "from" or "startAt" tweens. In version 1.20.3 we started flagging those with data:"isStart"|"isFromStart" but this logic helps GSDevTools work with older versions too.
  	_globalStartTime = 0,
  	_windowExists$4 = () => typeof(window) !== "undefined",
  	_getGSAP$4 = () => gsap$5 || (_windowExists$4() && (gsap$5 = window.gsap) && gsap$5.registerPlugin && gsap$5),
  	_isString$3 = value => typeof(value) === "string",
  	_isFunction$4 = value => typeof(value) === "function",
  	_isObject$2 = value => typeof(value) === "object",
  	_isUndefined$2 = value => typeof(value) === "undefined",
  	_svgNS = "http://www.w3.org/2000/svg",
  	_domNS = "http://www.w3.org/1999/xhtml",
  	_idSeed = 0, //we assign an ID to each GSDevTools instance so that we can segregate the sessionStorage data accordingly.
  	_lookup$1 = {},
  	_supportsStorage = (function() {
  		try {
  			sessionStorage.setItem("gsTest", "1");
  			sessionStorage.removeItem("gsTest");
  			return true;
  		} catch (e) {
  			return false;
  		}
  	}()),
  	_parseAnimation = animationOrId => (animationOrId instanceof Animation$1) ? animationOrId : animationOrId ? gsap$5.getById(animationOrId) : null,
  	_createElement$2 = (type, container, cssText) => {
  		let element = _doc$4.createElementNS ? _doc$4.createElementNS(type === "svg" ? _svgNS : _domNS, type) : _doc$4.createElement(type);
  		if (container) {
  			if (_isString$3(container)) {
  				container = _doc$4.querySelector(container);
  			}
  			container.appendChild(element);
  		}
  		if (type === "svg") {
  			element.setAttribute("xmlns", _svgNS);
  			element.setAttribute("xmlns:xlink", _domNS);
  		}
  		if (cssText) {
  			element.style.cssText = cssText;
  		}
  		return element;
  	},
  	_clearSelection = () => {
  		if (_doc$4.selection) {
  			_doc$4.selection.empty();
  		} else if (_win$5.getSelection) {
  			_win$5.getSelection().removeAllRanges();
  		}
  	},
  	_getChildrenOf = (timeline, includeTimelines) => {
  		let a = [],
  			cnt = 0,
  			Tween = gsap$5.core.Tween,
  			tween = timeline._first;
  		while (tween) {
  			if (tween instanceof Tween) {
  				if (tween.vars.id) {
  					a[cnt++] = tween;
  				}
  			} else {
  				if (includeTimelines && tween.vars.id) {
  					a[cnt++] = tween;
  				}
  				a = a.concat(_getChildrenOf(tween, includeTimelines));
  				cnt = a.length;
  			}
  			tween = tween._next;
  		}
  		return a;
  	},
  	_getClippedDuration = (animation, excludeRootRepeats) => {
  		let max = 0,
  			repeat = Math.max(0, animation._repeat),
  			t = animation._first;
  		if (!t) {
  			max = animation.duration();
  		}
  		while (t) {
  			max = Math.max(max, t.totalDuration() > 999 ? t.endTime(false) : t._start + t._tDur / t._ts);
  			t = t._next;
  		}
  		return (!excludeRootRepeats && repeat) ? max * (repeat + 1) + (animation._rDelay * repeat) : max;
  	},
  	_globalizeTime = function(animation, rawTime) {
  		let a = animation,
  			time = arguments.length > 1 ? +rawTime : a.rawTime();
  		while (a) {
  			time = a._start + time / (a._ts || 1);
  			a = a.parent;
  		}
  		return time;
  	},
  	_timeToProgress = (time, animation, defaultValue, relativeProgress) => {
  		let add, i, a;
  		if (_isString$3(time)) {
  			if (time.charAt(1) === "=") {
  				add = parseInt(time.charAt(0) + "1", 10) * parseFloat(time.substr(2));
  				if (add < 0 && relativeProgress === 0) { //if something like inTime:"-=2", we measure it from the END, not the beginning
  					relativeProgress = 100;
  				}
  				time = (relativeProgress / 100 * animation.duration()) + add;
  			} else if (isNaN(time) && animation.labels && animation.labels[time] !== -1) {
  				time = animation.labels[time];
  			} else if (animation === _recordedRoot) { //perhaps they defined an id of an animation, like "myAnimation+=2"
  				i = time.indexOf("=");
  				if (i > 0) {
  					add = parseInt(time.charAt(i-1) + "1", 10) * parseFloat(time.substr(i+1));
  					time = time.substr(0, i-1);
  				} else {
  					add = 0;
  				}
  				a = gsap$5.getById(time);
  				if (a) {
  					time = _globalizeTime(a, defaultValue / 100 * a.duration()) + add;
  				}
  			}
  		}

  		time = isNaN(time) ? defaultValue : parseFloat(time);
  		return Math.min(100, Math.max(0, time / animation.duration() * 100));
  	},
  	_addedCSS,
  	_createRootElement = (element, minimal, css) => {
  		if (!_addedCSS) {
  			_createElement$2("style", _docEl).innerHTML = '.gs-dev-tools{height:51px;bottom:0;left:0;right:0;display:block;position:fixed;overflow:visible;padding:0}.gs-dev-tools *{box-sizing:content-box;visibility:visible}.gs-dev-tools .gs-top{position:relative;z-index:499}.gs-dev-tools .gs-bottom{display:flex;align-items:center;justify-content:space-between;background-color:rgba(0,0,0,.6);height:42px;border-top:1px solid #999;position:relative}.gs-dev-tools .timeline{position:relative;height:8px;margin-left:15px;margin-right:15px;overflow:visible}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{height:8px;width:100%;position:absolute;top:0;left:0}.gs-dev-tools .timeline-track{background-color:#999;opacity:.6}.gs-dev-tools .progress-bar{background-color:#91e600;height:8px;top:0;width:0;pointer-events:none}.gs-dev-tools .seek-bar{width:100%;position:absolute;height:24px;top:-12px;left:0;background-color:transparent}.gs-dev-tools .in-point,.gs-dev-tools .out-point{width:15px;height:26px;position:absolute;top:-18px}.gs-dev-tools .in-point-shape{fill:#6d9900;stroke:rgba(0,0,0,.5);stroke-width:1}.gs-dev-tools .out-point-shape{fill:#994242;stroke:rgba(0,0,0,.5);stroke-width:1}.gs-dev-tools .in-point{transform:translateX(-100%)}.gs-dev-tools .out-point{left:100%}.gs-dev-tools .grab{stroke:rgba(255,255,255,.3);stroke-width:1}.gs-dev-tools .playhead{position:absolute;top:-5px;transform:translate(-50%,0);left:0;border-radius:50%;width:16px;height:16px;border:1px solid #6d9900;background-color:#91e600}.gs-dev-tools .gs-btn-white{fill:#fff}.gs-dev-tools .pause{opacity:0}.gs-dev-tools .select-animation{vertical-align:middle;position:relative;padding:6px 10px}.gs-dev-tools .select-animation-container{flex-grow:4;width:40%}.gs-dev-tools .select-arrow{display:inline-block;width:12px;height:7px;margin:0 7px;transform:translate(0,-2px)}.gs-dev-tools .select-arrow-shape{stroke:rgba(255,255,255,.6);stroke-width:2px;fill:none}.gs-dev-tools .rewind{height:16px;width:19px;padding:10px 4px;min-width:24px}.gs-dev-tools .rewind-path{opacity:.6}.gs-dev-tools .play-pause{width:24px;height:24px;padding:6px 10px;min-width:24px}.gs-dev-tools .ease{width:30px;height:30px;padding:10px;min-width:30px;display:none}.gs-dev-tools .ease-path{fill:none;stroke:rgba(255,255,255,.6);stroke-width:2px}.gs-dev-tools .ease-border{fill:rgba(255,255,255,.25)}.gs-dev-tools .time-scale{font-family:monospace;font-size:18px;text-align:center;color:rgba(255,255,255,.6);padding:4px 4px 4px 0;min-width:30px;margin-left:7px}.gs-dev-tools .loop{width:20px;padding:5px;min-width:20px}.gs-dev-tools .loop-path{fill:rgba(255,255,255,.6)}.gs-dev-tools label span{color:#fff;font-family:monospace;text-decoration:none;font-size:16px;line-height:18px}.gs-dev-tools .time-scale span{color:rgba(255,255,255,.6)}.gs-dev-tools button:focus,.gs-dev-tools select:focus{outline:0}.gs-dev-tools label{position:relative;cursor:pointer}.gs-dev-tools label.locked{text-decoration:none;cursor:auto}.gs-dev-tools label input,.gs-dev-tools label select{position:absolute;left:0;top:0;z-index:1;font:inherit;font-size:inherit;line-height:inherit;height:100%;width:100%;color:#000!important;opacity:0;background:0 0;border:none;padding:0;margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer}.gs-dev-tools label input+.display{position:relative;z-index:2}.gs-dev-tools .gs-bottom-right{vertical-align:middle;display:flex;align-items:center;flex-grow:4;width:40%;justify-content:flex-end}.gs-dev-tools .time-container{font-size:18px;font-family:monospace;color:rgba(255,255,255,.6);margin:0 5px}.gs-dev-tools .logo{width:32px;height:32px;position:relative;top:2px;margin:0 12px}.gs-dev-tools .gs-hit-area{background-color:transparent;width:100%;height:100%;top:0;position:absolute}.gs-dev-tools.minimal{height:auto;display:flex;align-items:stretch}.gs-dev-tools.minimal .gs-top{order:2;flex-grow:4;background-color:rgba(0,0,0,1)}.gs-dev-tools.minimal .gs-bottom{background-color:rgba(0,0,0,1);border-top:none}.gs-dev-tools.minimal .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools.minimal .in-point,.gs-dev-tools.minimal .out-point{display:none}.gs-dev-tools.minimal .select-animation-container{display:none}.gs-dev-tools.minimal .rewind{display:none}.gs-dev-tools.minimal .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools.minimal .time-scale{min-width:26px}.gs-dev-tools.minimal .loop{width:18px;min-width:18px;display:none}.gs-dev-tools.minimal .gs-bottom-right{display:none}@media only screen and (max-width:600px){.gs-dev-tools{height:auto;display:flex;align-items:stretch}.gs-dev-tools .gs-top{order:2;flex-grow:4;background-color:rgba(0,0,0,1);height:42px}.gs-dev-tools .gs-bottom{background-color:rgba(0,0,0,1);border-top:none}.gs-dev-tools .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools .in-point,.gs-dev-tools .out-point{display:none}.gs-dev-tools .select-animation-container{display:none}.gs-dev-tools .rewind{display:none}.gs-dev-tools .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools .time-scale{min-width:26px}.gs-dev-tools .loop{width:18px;min-width:18px;display:none}.gs-dev-tools .gs-bottom-right{display:none}}';
  			_addedCSS = true;
  		}
  		if (_isString$3(element)) {
  			element = _doc$4.querySelector(element);
  		}
  		let root = _createElement$2("div", element || _docEl.getElementsByTagName("body")[0] || _docEl);
  		root.setAttribute("class", "gs-dev-tools" + (minimal ? " minimal" : ""));
  		root.innerHTML = '<div class=gs-hit-area></div><div class=gs-top><div class=timeline><div class=timeline-track></div><div class=progress-bar></div><div class=seek-bar></div><svg class=in-point viewBox="0 0 15 26"xmlns=http://www.w3.org/2000/svg><polygon class=in-point-shape points=".5 .5 14.5 .5 14.5 25.5 .5 17.5"/><polyline class=grab points="5.5 4 5.5 15"/><polyline class=grab points="9.5 4 9.5 17"/></svg> <svg class=out-point viewBox="0 0 15 26"xmlns=http://www.w3.org/2000/svg><polygon class=out-point-shape points=".5 .5 14.5 .5 14.5 17.5 .5 25.5"/><polyline class=grab points="5.5 4 5.5 17"/><polyline class=grab points="9.5 4 9.5 15"/></svg><div class=playhead></div></div></div><div class=gs-bottom><div class=select-animation-container><label class=select-animation><select class=animation-list><option>Global Timeline<option>myTimeline</select><nobr><span class="display animation-label">Global Timeline</span> <svg class=select-arrow viewBox="0 0 12.05 6.73"xmlns=http://www.w3.org/2000/svg><polyline class=select-arrow-shape points="0.35 0.35 6.03 6.03 11.7 0.35"/></svg></nobr></label></div><svg class=rewind viewBox="0 0 12 15.38"xmlns=http://www.w3.org/2000/svg><path d=M0,.38H2v15H0Zm2,7,10,7.36V0Z class="gs-btn-white rewind-path"/></svg> <svg class=play-pause viewBox="0 0 20.97 25.67"xmlns=http://www.w3.org/2000/svg><g class=play><path d="M8,4.88 C8,10.18 8,15.48 8,20.79 5.33,22.41 2.66,24.04 0,25.67 0,17.11 0,8.55 0,0 2.66,1.62 5.33,3.25 8,4.88"class="gs-btn-white play-1"style=stroke:#fff;stroke-width:.6px /><path d="M14.485,8.855 C16.64,10.18 18.8,11.5 20.97,12.83 16.64,15.48 12.32,18.13 8,20.79 8,15.48 8,10.18 8,4.88 10.16,6.2 12.32,7.53 14.48,8.85"class="gs-btn-white play-2"style=stroke:#fff;stroke-width:.6px /></g></svg> <svg class=loop viewBox="0 0 29 25.38"xmlns=http://www.w3.org/2000/svg><path d=M27.44,5.44,20.19,0V3.06H9.06A9.31,9.31,0,0,0,0,12.41,9.74,9.74,0,0,0,.69,16l3.06-2.23a6,6,0,0,1-.12-1.22,5.49,5.49,0,0,1,5.43-5.5H20.19v3.81Z class=loop-path /><path d=M25.25,11.54a5.18,5.18,0,0,1,.12,1.12,5.41,5.41,0,0,1-5.43,5.41H9.19V14.5L1.94,19.94l7.25,5.44V22.06H19.94A9.2,9.2,0,0,0,29,12.84a9.42,9.42,0,0,0-.68-3.53Z class=loop-path /></svg> <svg class=ease viewBox="0 0 25.67 25.67"xmlns=http://www.w3.org/2000/svg><path d=M.48,25.12c1.74-3.57,4.28-12.6,8.8-10.7s4.75,1.43,6.5-1.11S19.89,1.19,25.2.55 class=ease-path /><path d=M24.67,1V24.67H1V1H24.67m1-1H0V25.67H25.67V0Z class=ease-border /></svg><label class=time-scale><select><option value=10>10x<option value=5>5x<option value=2>2x<option value=1 selected>1x<option value=0.5>0.5x<option value=0.25>0.25x<option value=0.1>0.1x</select><span class="display time-scale-label">1x</span></label><div class=gs-bottom-right><div class=time-container><span class=time>0.00</span> / <span class=duration>0.00</span></div><a href="https://greensock.com/docs/v3/Plugins/GSDevTools?source=GSDevTools"target=_blank title=Docs><svg class=logo viewBox="0 0 100 100"xmlns=http://www.w3.org/2000/svg><path d="M60 15.4c-.3-.4-.5-.6-.5-.7.1-.6.2-1 .2-1.7v-.4c.6.6 1.3 1.3 1.8 1.7.2.2.5.3.8.3.2 0 .3 0 .5.1h1.6c.8 0 1.6.1 2 0 .1 0 .2 0 .3-.1.6-.3 1.4-1 2.1-1.6 0 .6.1 1.2.1 1.7v1.5c0 .3 0 .5.1.7-.1.1-.2.1-.4.2-.7.4-1.7 1-2.3.9-.5-.1-1.5-.3-2.6-.7-1.2-.3-2.4-.8-3.2-1.2 0 0-.1 0-.1-.1s-.2-.4-.4-.6zm24.6 21.9c-.5-1.7-1.9-2-4.2-.7.9-1.5 2.1-1.5 2.3-2.1.9-2.5-.6-4.6-1.2-5.3.7-1.8 1.4-4.5-1-6.8-1-1-2.4-1.2-3.6-1.1 1.8 1.7 3.4 4.4 2.5 7.2-.1.3-.9.7-1.7 1 0 0 .4 2-.3 3.5-.3.6-.8 1.5-1.3 2.6 1 .9 1.6 1 3 1.3-.9.1-1.2.4-1.2.5-.7 3 1 3.4 1.4 4.8 0 .1 0 .2.1.3v.4c-.3.3-1.4.5-2.5.5s-1.8 1-1.8 1c-.2.1-.3.3-.4.4v1c0 .1 0 .4.1.6.1.5.3 1.3.4 1.8.9.6 1.4.9 2.2 1.1.5.1 1 .2 1.5.1.3-.1.7-.3 1-.7 1.5-1.7 1.9-3.2 2.2-4.1 0-.1 0-.2.1-.2 0 .1.1.1.1.2 0 0 .1-.1.1-.2l.1-.1c1.3-1.6 2.9-4.5 2.1-7zM74.3 49.9c-.1-.3-.1-.7-.2-1.1v-.2c-.1-.2-.1-.4-.2-.6 0-.1-.1-.3-.1-.5s-.1-.5-.1-.7v-.1c0-.2-.1-.5-.1-.7-.1-.3-.1-.7-.2-1.1v-.1c0-.2 0-.3-.1-.5v-.9c0-.1 0-.2.1-.3V43h-.3c-1.1.1-3.8.4-6.7.2-1.2-.1-2.4-.3-3.6-.6-1-.3-1.8-.5-2.3-.7-1.2-.4-1.6-.6-1.8-.7 0 .2-.1.4-.1.7 0 .3-.1.5-.1.8-.1.2-.1.4-.2.6l.1.1c.5.5 1.5 1.3 1.5 2.1v.2c-.1.4-.4.5-.8.9-.1.1-.6.7-1.1 1.1l-.6.6c-.1 0-.1.1-.2.1-.1.1-.3.2-.4.3-.2.1-.7.5-.8.6-.1.1-.2.1-.3.1-2.8 8.8-2.2 13.5-1.5 16.1.1.5.3 1 .4 1.3-.4.5-.8 1-1.2 1.4-1.2 1.5-2 2.6-2.6 4.2 0 .1 0 .1-.1.2 0 .1 0 .2-.1.2-.2.5-.3 1-.4 1.5-.6 2.3-.8 4.5-.9 6.6-.1 2.4-.2 4.6-.5 6.9.7.3 3.1.9 4.7.6.2-.1 0-3.9.6-5.7l.6-1.5c.4-.9.9-1.9 1.3-3.1.3-.7.5-1.5.7-2.4.1-.5.2-1 .3-1.6V74v-.1c.1-.6.1-1.3.1-2 0-.2-.7.3-1.1.9.3-1.8 1.3-2.1 2-3.2.3-.5.6-1.1.6-2 2.5-1.7 4-3.7 5-5.7.2-.4.4-.9.6-1.4.3-.8.5-1.6.7-2.4.3-1.4.8-3.2 1.2-4.8v-.1c.4-1.2.8-2.2 1.2-2.6-.2.9-.4 1.7-.6 2.5v.2c-.6 3.5-.7 6.2-2 9.2 1 2.6 1.9 3.9 2 7.6-2 0-3.2 1.6-3.7 3.2 1.2.3 3.9.7 8.3.1h.3c.1-.5.3-1.1.5-1.5.3-.8.5-1.5.6-2.2.2-1.3.1-2.4 0-3.2 3.9-3.7 2.6-11 1.6-16.6zm.3-15.1c.1-.3.2-.6.4-.8.2-.3.3-.7.5-1 .1-.3.3-.6.4-.9.5-1.5.4-2.8.3-3.5-.1 0-.1-.1-.2-.1-.5-.2-.9-.4-1.4-.6-.1 0-.2-.1-.3-.1-3.8-1.2-7.9-.9-11.9.1-1 .2-1.9.5-2.9.1-2.3-.8-3.9-1.9-4.6-2.8l-.2-.2c-.1.2-.2.4-.4.6.2 2.3-.5 3.9-1.4 5.1.9 1.2 2.6 2.8 3.6 3.4 1.1.6 1.7.7 3.4.4-.6.7-1.1 1-1.9 1.4.1.7.2 2 .5 3.4.3.3 1.2.8 2.3 1.3.5.3 1.1.5 1.7.7.8.3 1.7.6 2.4.8.1 0 .2.1.3.1.5.1 1.1.2 1.8.2h.9c2.1 0 4.5-.2 5.4-.3h.1c-.1-2.7.2-4.6.7-6.2.2-.3.4-.7.5-1.1zm-23.2 9.3v.2c-.3 1.7.5 2.4 1.9 3.4.6.5 0 .5.5.8.3.2.7.3 1 .3.3 0 .5 0 .8-.1.2-.1.4-.3.6-.5.1-.1.3-.2.5-.4.3-.2.6-.5.7-.6.1-.1.2-.1.3-.2.2-.2.5-.5.6-.7.2-.2.4-.5.5-.7 0-.1.1-.1.1-.1v-.1c.1-.4-.3-.8-.8-1.3-.2-.2-.4-.3-.5-.5-.3-.3-.6-.5-1-.7-.9-.5-1.9-.7-3-.7l-.3-.3c-2.2-2.5-3.2-4.8-3.9-6.5-.9-2.1-1.9-3.3-3.9-4.9 1 .4 1.8.8 2.3 1.1.5.4 1.3.4 1.9.2.2-.1.5-.2.7-.3.2-.1.4-.2.6-.4 1.6-1.3 2.5-3.8 2.6-5.6v-.1c.2-.3.6-1.1.8-1.4l.1.1c.1.1.3.2.6.5.1 0 .1.1.2.1.1.1.2.1.2.2.8.6 1.9 1.3 2.6 1.7 1.4.7 2.3.7 5.3-.1 2.2-.6 4.8-.8 6.8-.8 1.4 0 2.7.3 4 .7.2.1.4.1.5.2.3.1.6.2.9.4 0 0 .1 0 .1.1.8.4 2.1 1.2 2.5-.3.1-2-.6-3.9-1.6-5.3 0 0-.1 0-.1-.1-.1-.1-.2-.2-.4-.3-.1-.1-.2-.1-.3-.2-.1-.1-.2-.2-.4-.2-.6-.4-1.2-.8-1.6-.9-.1-.1-.3-.1-.4-.2h-.1-.1c-.1 0-.3-.1-.4-.1-.1 0-.1 0-.2-.1h-.1l-.2-.4c-.2-.1-.4-.2-.5-.2h-.6c-.3 0-.5.1-.7.1-.7.1-1.2.3-1.7.4-.2 0-.3.1-.5.1-.5.1-1 .2-1.6.2-.4 0-.9-.1-1.5-.2-.4-.1-.8-.2-1.1-.3-.2-.1-.4-.1-.6-.2-.6-.2-1.1-.3-1.7-.4h-.2-1.8c-.3 0-.6.1-1 .1H57.9c-.8 0-1.5 0-2.3-.1-.2 0-.5-.1-.7-.1-.5-.1-.9-.2-1.3-.4-.2-.1-.3-.1-.4-.2-.1 0-.2 0-.2-.1-.3-.1-.6-.1-.9-.1H51h-.1c-.4 0-.9.1-1.4.2-1.1.2-2.1.6-3 1.3-.3.2-.6.5-.8.8-.1.1-.2.2-.2.3-.4.6-.8 1.2-.9 2 0 .2-.1.4-.1.6 0 .2 1.7.7 2.3 2.8-.8-1.2-2.3-2.5-4.1-1.4-1.5 1-1.1 3.1-2.4 5.4-.3.5-.6.9-1 1.4-.8 1-.7 2.1.2 4.4 1.4 3.4 7.6 5.3 11.5 8.3l.4.4zm8.7-36.3c0 .6.1 1 .2 1.6v.1c0 .3.1.6.1.9.1 1.2.4 2 1 2.9 0 .1.1.1.1.2.3.2.5.3.8.4 1.1.2 3.1.3 4.2 0 .2-.1.5-.3.7-.5.4-.4.7-1.1.9-1.7.1-.7.3-1.3.4-1.8 0-.2.1-.4.1-.5v-.1c0-.2 0-.3.1-.5.2-.7.2-2.4.3-2.8.1-.7 0-1.8-.1-2.5 0-.2-.1-.4-.1-.5v-.1c-.2-.5-1.4-1.4-4.3-1.4-3.1 0-4 1-4.1 1.5v.1c0 .1 0 .3-.1.5-.1.4-.2 1.4-.2 1.9v2.3zm-6 88.6c0-.1-.1-.2-.1-.3-.7-1.5-1.1-3.5-1.3-4.6.4.1.7.6.8.3.2-.5-.4-1.5-.5-2.2v-.1c-.5-.5-4-.5-3.7-.3-.4.8-1 .6-1.3 2.1-.1.7.8.1 1.7.1-1.4.9-3 2.1-3.4 3.2-.1.1-.1.2-.1.3 0 .2-.1.4-.1.5-.1 1.2.5 1.6 2 2.4H48.4c1.4.3 3 .3 4.3.3 1.2-.2 1.6-.7 1.6-1.4-.2-.1-.2-.2-.2-.3z"style=fill:#efefef /><path d="M56.1 36.5c.3 1.4.5 2.4.8 4.2h-.2c-.1.5-.1.9-.1 1.3-1-.4-2.2-.5-2.6-.5-3.7-4.4-2.9-6.1-4.4-8.3.4-.2 1-.4 1.5-.8 1.6 1.9 3.3 3 5 4.1zm-1.7 13.2s-1.4 0-2.3-1c0 0-.1-.5.1-.7 0 0-1.2-1-1.5-1.7-.2-.5-.3-1.1-.2-1.6-4.4-3.7-10.9-4.2-12.9-9.1-.5-1.2-1.3-2.9-.9-3.9-.3.1-.5.2-.8.3-2.9.9-11.7 5.3-17.9 8.8 1.6 1.7 2.6 4.3 3.2 7.2l.3 1.5c.1.5.1 1 .2 1.5.1 1.4.4 2.7.8 3.9.2.8.6 1.5.9 2.2.6 1 1.2 1.9 2.1 2.6.6.5 1.2.9 1.9 1.3 2.1 1.1 5 1.6 8.6 1.5H37.9c.5 0 1 .1 1.5.1h.1c.4.1.9.1 1.3.2h.2c.4.1.9.2 1.3.4h.1c.4.1.8.3 1.1.5h.1c.4.2.7.4 1.1.6h.1c.7.4 1.3.9 1.9 1.5l.1.1c.6.5 1.1 1.1 1.5 1.8 0 .1.1.1.1.2s.1.1.1.2c.4.6 1.2 1.1 1.9 1.3.7-.9 1.5-1.8 2.2-2.8-1.6-6 0-11.7 1.8-16.9zm-26-15.9c5-2.4 9-4.1 9.9-4.5.3-.6.6-1.4.9-2.6.1-.3.2-.5.3-.8 1-2.7 2.7-2.8 3.5-3v-.2c.1-1.1.5-2 1-2.8-8.8 2.5-18 5.5-28 11.7-.1.1-.2.2-.4.2C11.3 34.5 3 40.3 1.3 51c2.4-2.7 6-5.6 10.5-8.5.1-.1.3-.2.5-.3.2-.1.5-.3.7-.4 1.2-.7 2.4-1.4 3.6-2.2 2.2-1.2 4.5-2.4 6.7-3.5 1.8-.8 3.5-1.6 5.1-2.3zm54.9 61.3l-.3-.3c-.8-.6-4.1-1.2-5.5-2.3-.4-.3-1.1-.7-1.7-1.1-1.6-.9-3.5-1.8-3.5-2.1v-.1c-.2-1.7-.2-7 .1-8.8.3-1.8.7-4.4.8-5.1.1-.6.5-1.2.1-1.2h-.4c-.2 0-.4.1-.8.1-1.5.3-4.3.6-6.6.4-.9-.1-1.6-.2-2-.3-.5-.1-.7-.2-.9-.3H62.3c-.4.5 0 2.7.6 4.8.3 1.1.8 2 1.2 3 .3.8.6 1.8.8 3.1 0 .2.1.4.1.7.2 2.8.3 3.6-.2 4.9-.1.3-.3.6-.4 1-.4.9-.7 1.7-.6 2.3 0 .2.1.4.1.5.2.4.6.7 1.2.8.2 0 .3.1.5.1.3 0 .6.1.9.1 3.4 0 5.2 0 8.6.4 2.5.4 3.9.6 5.1.5.4 0 .9-.1 1.4-.1 1.2-.2 1.8-.5 1.9-.9-.1.2-.1.1-.2-.1zM60.2 16.4zm-.5 1.7zm3.8.5c.1 0 .3.1.5.1.4.1.7.2 1.2.3.3.1.6.1.9.1h1.3c.3-.1.7-.1 1-.2.7-.2 1.5-.4 2.7-.6h.3c.3 0 .6.1.9.3.1.1.2.1.4.2.3.2.8.2 1.2.4h.1c.1 0 .1.1.2.1.6.3 1.3.7 1.9 1.1l.3.3c.9-.1 1.6-.2 2.1-.2h.1c-.2-.4-.3-1.3-1.8-.6-.6-.7-.8-1.3-2.1-.9-.1-.2-.2-.3-.3-.4l-.1-.1c-.1-.1-.2-.3-.3-.4 0-.1-.1-.1-.1-.2-.2-.3-.5-.5-.9-.7-.7-.4-1.5-.6-2.3-.5-.2 0-.4.1-.6.2-.1 0-.2.1-.2.1-.1 0-.2.1-.3.2-.5.3-1.3.8-2.1 1-.1 0-.1 0-.2.1-.2 0-.4.1-.5.1H66.5h-.1c-.4-.1-1.1-.2-2-.5-.1 0-.2-.1-.3-.1-.9-.2-1.8-.5-2.7-.8-.3-.1-.7-.2-1-.3-.1 0-.1 0-.2-.1h-.1s-.1 0-.1-.1c-.3-.3-.7-.6-1.3-.8-.5-.2-1.2-.4-2.1-.5-.2 0-.5 0-.7.1-.4.2-.8.6-1.2.9.1.1.3.3.4.5.1.2.2.4.3.7l-.6-.6c-.5-.4-1.1-.8-1.7-.9-.8-.2-1.4.4-2.3.9 1 0 1.8.1 2.5.4.1 0 .1 0 .2.1h.1c.1 0 .2.1.3.1.9.4 1.8.6 2.7.6h1.3c.5 0 .8-.1 1.1-.1.1 0 .4 0 .7-.1h2.2c.4.4.9.6 1.6.8z"style=fill:#88ce02 /><path d="M100 51.8c0-19.5-12.5-36.1-30-42.1.1-1.2.2-2.4.3-3.1.1-1.5.2-3.9-.5-4.9-1.6-2.3-9.1-2.1-10.5-.1-.4.6-.7 3.6-.6 5.9-1.1-.1-2.2-.1-3.3-.1-16.5 0-30.9 9-38.6 22.3-2.4 1.4-4.7 2.8-6.1 4C5.4 38 2.2 43.2 1 47c-1.6 4.7-1.1 7.6.4 5.8 1.2-1.5 6.6-5.9 10.1-8.2-.4 2.3-.6 4.8-.6 7.2 0 21 14.5 38.5 34 43.3-.1 1.1.1 2 .7 2.6.9.8 3.2 2 6.4 1.6 2.9-.3 3.5-.5 3.2-2.9h.2c2.7 0 5.3-.2 7.8-.7.1.1.2.2.4.3 1.5 1 7.1.8 9.6.7s6.2.9 8.6.5c2.9-.5 3.4-2.3 1.6-3.2-1.5-.8-3.8-1.3-6.7-3.1C90.6 83.4 100 68.7 100 51.8zM60.1 5.5c0-.5.1-1.5.2-2.1 0-.2 0-.4.1-.5v-.1c.1-.5 1-1.5 4.1-1.5 2.9 0 4.2.9 4.3 1.4v.1c0 .1 0 .3.1.5.1.8.2 1.9.1 2.7 0 .5-.1 2.1-.2 2.9 0 .1 0 .3-.1.5v.1c0 .2-.1.3-.1.5-.1.5-.2 1.1-.4 1.8-.1.6-.5 1.2-.9 1.7-.2.3-.5.5-.7.5-1.1.3-3.1.3-4.2 0-.3-.1-.5-.2-.8-.4 0-.1-.1-.1-.1-.2-.6-.9-.9-1.7-1-2.9 0-.4-.1-.6-.1-.9v-.1c-.1-.6-.2-1-.2-1.6v-.3c-.1-1.3-.1-2.1-.1-2.1zm-.4 7.5v-.4c.6.6 1.3 1.3 1.8 1.7.2.2.5.3.8.3.2 0 .3 0 .5.1h1.6c.8 0 1.6.1 2 0 .1 0 .2 0 .3-.1.6-.3 1.4-1 2.1-1.6 0 .6.1 1.2.1 1.7v1.5c0 .3 0 .5.1.7-.1.1-.2.1-.4.2-.7.4-1.7 1-2.3.9-.5-.1-1.5-.3-2.6-.7-1.2-.3-2.4-.8-3.2-1.2 0 0-.1 0-.1-.1-.2-.3-.4-.5-.6-.7-.3-.4-.5-.6-.5-.7.3-.4.4-.9.4-1.6zm.5 3.4zm-7.3-.3c.6.1 1.2.5 1.7.9.2.2.5.4.6.6-.1-.2-.2-.5-.3-.7-.1-.2-.3-.4-.4-.5.4-.3.8-.7 1.2-.9.2-.1.4-.1.7-.1.9.1 1.6.2 2.1.5.6.2 1 .5 1.3.8 0 0 .1 0 .1.1h.1c.1 0 .1 0 .2.1.3.1.6.2 1 .3.9.3 1.9.6 2.7.8.1 0 .2.1.3.1.9.2 1.6.4 2 .5h.4c.2 0 .4 0 .5-.1.1 0 .1 0 .2-.1.7-.2 1.5-.7 2.1-1 .1-.1.2-.1.3-.2.1 0 .2-.1.2-.1.2-.1.4-.2.6-.2.8-.2 1.7.1 2.3.5.3.2.6.4.9.7 0 .1.1.1.1.2.1.2.2.3.3.4l.1.1c.1.1.2.2.3.4 1.3-.4 1.5.2 2.1.9 1.6-.7 1.7.2 1.8.6h-.1c-.5 0-1.2 0-2.1.2l-.3-.3c-.5-.4-1.2-.8-1.9-1.1-.1 0-.1-.1-.2-.1h-.1c-.4-.2-.8-.2-1.2-.4-.1-.1-.2-.1-.4-.2-.3-.1-.6-.3-.9-.3h-.3c-1.2.1-2 .4-2.7.6-.3.1-.7.2-1 .2-.4.1-.8.1-1.3 0-.3 0-.6-.1-.9-.1-.5-.1-.8-.2-1.2-.3-.2 0-.3-.1-.5-.1h-.1c-.6-.2-1.2-.3-1.8-.4h-.1-2.1c-.4.1-.6.1-.7.1-.3 0-.7.1-1.1.1h-1.3c-.9 0-1.9-.2-2.7-.6-.1 0-.2-.1-.3-.1H53c-.1 0-.1 0-.2-.1-.7-.3-1.6-.4-2.5-.4 1.2-.8 1.8-1.4 2.6-1.3zm6.8 2zm-15.2 4.1c.1-.7.4-1.4.9-2 .1-.1.2-.2.2-.3l.8-.8c.9-.6 1.9-1.1 3-1.3.5-.1 1-.2 1.4-.2H52c.3 0 .6.1.9.1.1 0 .2 0 .2.1.1.1.2.1.4.2.4.2.8.3 1.3.4.2 0 .5.1.7.1.7.1 1.5.1 2.3.1H58.7c.4 0 .7-.1 1-.1H61.7c.6.1 1.1.2 1.7.4.2 0 .4.1.6.2.3.1.7.2 1.1.3.6.1 1.1.2 1.5.2.6 0 1.1-.1 1.6-.2.2 0 .3-.1.5-.1.5-.1 1-.3 1.7-.4.2 0 .5-.1.7-.1h.6c.2 0 .4.1.5.2l.1.1h.1c.1 0 .1 0 .2.1.2.1.3.1.4.1h.2c.1.1.3.1.4.2.4.2 1 .6 1.6.9.1.1.2.2.4.2.1.1.2.1.3.2.2.1.3.3.4.3l.1.1c1.1 1.4 1.8 3.3 1.6 5.3-.3 1.5-1.6.7-2.5.3 0 0-.1 0-.1-.1-.3-.1-.6-.2-.9-.4-.2-.1-.4-.1-.5-.2-1.2-.4-2.5-.7-4-.7-2 0-4.6.1-6.8.8-3 .8-4 .8-5.3.1-.8-.4-1.8-1.1-2.6-1.7-.1-.1-.2-.1-.2-.2-.1-.1-.1-.1-.2-.1-.3-.2-.6-.4-.6-.5l-.1-.1c-.2.3-.6 1-.8 1.4v.1c-.1 1.7-1 4.2-2.6 5.6-.2.1-.4.3-.6.4-.2.1-.5.2-.7.3-.7.2-1.4.2-1.9-.2-.5-.3-1.3-.7-2.3-1.1 2 1.6 3 2.8 3.9 4.9.7 1.7 1.7 4 3.9 6.5l.3.3c1.1 0 2.1.2 3 .7.4.2.7.4 1 .7.2.2.4.3.5.5.5.4.9.8.8 1.3v.1s0 .1-.1.1c-.1.2-.3.5-.5.7-.1.1-.4.4-.6.7-.1.1-.2.2-.3.2-.1.1-.4.3-.7.6-.2.2-.4.3-.5.4-.2.1-.4.4-.6.5-.3.1-.5.2-.8.1-.3 0-.7-.2-1-.3-.5-.3.1-.3-.5-.8-1.4-1-2.2-1.7-1.9-3.4v-.2c-.2-.1-.3-.3-.5-.4-3.9-3-10.1-4.9-11.5-8.3-.9-2.3-1-3.4-.2-4.4.4-.5.8-1 1-1.4 1.3-2.3.9-4.4 2.4-5.4 1.8-1.2 3.3.2 4.1 1.4-.5-2.1-2.3-2.6-2.3-2.8.3.1.3-.1.3-.3zm29 20s-.1 0 0 0c-.1 0-.1 0 0 0-.9.1-3.3.3-5.4.3h-.9c-.7 0-1.3-.1-1.8-.2-.1 0-.2 0-.3-.1-.7-.2-1.6-.5-2.4-.8-.6-.2-1.2-.5-1.7-.7-1.1-.5-2.1-1.1-2.3-1.3-.5-1.4-.7-2.7-.7-3.4.8-.4 1.3-.7 1.9-1.4-1.7.3-2.4.2-3.4-.4-1-.5-2.6-2.2-3.6-3.4 1-1.2 1.7-2.9 1.4-5.1.1-.2.3-.4.4-.6 0 .1.1.1.2.2.7.9 2.4 2 4.6 2.8 1.1.4 2 .1 2.9-.1 4-1 8.1-1.3 11.9-.1.1 0 .2.1.3.1.5.2.9.4 1.4.6.1 0 .1.1.2.1.1.7.2 2-.3 3.5-.1.3-.2.6-.4.9-.2.3-.3.6-.5 1-.1.3-.2.5-.4.8-.2.4-.3.8-.5 1.3-.4 1.4-.7 3.4-.6 6zm-23.9-9c.4-.2 1-.4 1.5-.8 1.6 1.8 3.3 3 5 4.1.3 1.4.5 2.4.8 4.2h-.2c-.1.5-.1.9-.1 1.3-1-.4-2.2-.5-2.6-.5-3.7-4.3-3-6-4.4-8.3zm-32.9 6.5c-1.3.7-2.5 1.4-3.6 2.2-.2.1-.5.3-.7.4-.1.1-.3.2-.5.3-4.5 2.9-8.1 5.8-10.5 8.5 1.7-10.8 10-16.5 14.3-19.2.1-.1.2-.2.4-.2 10-6.2 19.2-9.2 28-11.7-.5.8-.9 1.7-1 2.8v.2c-.8.1-2.5.2-3.5 3-.1.2-.2.5-.3.8-.3 1.2-.6 2-.9 2.6-.9.4-5 2.2-9.9 4.5-1.6.8-3.3 1.6-5 2.4-2.3 1-4.6 2.2-6.8 3.4zm28 24.8s0-.1 0 0c-.4-.3-.8-.5-1.2-.7h-.1c-.4-.2-.7-.3-1.1-.5h-.1c-.4-.1-.8-.3-1.3-.4h-.2c-.4-.1-.8-.2-1.3-.2h-.1c-.5-.1-1-.1-1.5-.1H35.9c-3.7.1-6.5-.4-8.6-1.5-.7-.4-1.4-.8-1.9-1.3-.9-.7-1.5-1.6-2.1-2.6-.4-.7-.7-1.4-.9-2.2-.4-1.2-.6-2.5-.8-3.9 0-.5-.1-1-.2-1.5l-.3-1.5c-.6-2.9-1.6-5.5-3.2-7.2 6.3-3.5 15-7.9 17.8-8.8.3-.1.6-.2.8-.3-.3 1.1.4 2.7.9 3.9 2.1 4.9 8.6 5.4 12.9 9.1 0 .5 0 1.1.2 1.6.5.6 1.7 1.6 1.7 1.6-.2.2-.1.7-.1.7.9 1 2.3 1 2.3 1-1.8 5.2-3.4 10.9-1.9 16.9-.7 1-1.5 1.8-2.2 2.8-.7-.2-1.4-.6-1.9-1.3 0-.1-.1-.1-.1-.2s-.1-.1-.1-.2l-1.5-1.8-.1-.1c-.5-.4-1.2-.9-1.9-1.3zm7.9 33.6c-1.3.1-2.9 0-4.3-.3h-.2-.1c-1.5-.8-2.1-1.2-2-2.4 0-.2 0-.3.1-.5 0-.1.1-.2.1-.3.5-1.1 2.1-2.2 3.4-3.2-.8 0-1.8.7-1.7-.1.2-1.5.9-1.3 1.3-2.1-.2-.3 3.3-.2 3.8.3v.1c0 .7.7 1.7.5 2.2-.1.3-.4-.2-.8-.3.2 1.1.6 3.1 1.3 4.6.1.1.1.2.1.3 0 .1.1.2.1.3 0 .7-.4 1.2-1.6 1.4zM59 67.7c0 .9-.3 1.6-.6 2-.7 1.1-1.7 1.4-2 3.2.4-.6 1.1-1.1 1.1-.9 0 .8-.1 1.4-.1 2v.2c-.1.6-.2 1.1-.3 1.6-.2.9-.5 1.7-.7 2.4-.4 1.2-.9 2.1-1.3 3.1l-.6 1.5c-.6 1.7-.4 5.6-.6 5.7-1.6.3-4.1-.3-4.7-.6.3-2.2.4-4.5.5-6.9.1-2.1.3-4.3.9-6.6.1-.5.3-1 .4-1.5 0-.1 0-.2.1-.2 0-.1 0-.1.1-.2.5-1.6 1.4-2.7 2.6-4.2.4-.4.7-.9 1.2-1.4-.1-.4-.2-.8-.4-1.3-.7-2.6-1.3-7.3 1.5-16.1.1 0 .2-.1.3-.1.2-.1.7-.5.8-.6.1-.1.3-.2.4-.3.1 0 .1-.1.2-.1l.6-.6 1.1-1.1c.4-.4.7-.5.8-.9v-.2c0-.8-1.1-1.5-1.5-2.1l-.1-.1c.1-.2.1-.4.2-.6 0-.2.1-.5.1-.8 0-.2.1-.5.1-.7.1.1.6.4 1.8.7.6.2 1.3.4 2.3.7 1.1.3 2.4.5 3.6.6 2.9.2 5.6 0 6.7-.2h.3v.1c0 .1 0 .2-.1.3v.9c0 .2 0 .3.1.5v.1c0 .4.1.7.2 1.1 0 .3.1.5.1.7v.1c0 .3.1.5.1.7 0 .2.1.3.1.5.1.2.1.4.2.6v.2c.1.4.2.8.2 1.1 1 5.7 2.3 12.9-1.1 16.7.2.8.3 1.9 0 3.2-.1.7-.3 1.4-.6 2.2-.2.5-.3 1-.5 1.5h-.3c-4.5.6-7.1.2-8.3-.1.5-1.6 1.7-3.3 3.7-3.2-.1-3.7-1.1-5-2-7.6 1.3-3 1.3-5.7 2-9.2v-.2c.2-.8.3-1.6.6-2.5-.4.5-.8 1.5-1.2 2.6v.1c-.5 1.5-.9 3.4-1.2 4.8-.2.8-.4 1.6-.7 2.4-.2.5-.4.9-.6 1.4-1.5 1.9-3 3.9-5.5 5.6zm18.5 24.9c1.5 1.1 4.7 1.8 5.5 2.3l.3.3c.1.1.1.2.1.3-.1.4-.7.7-1.9.9-.5.1-.9.1-1.4.1-1.3 0-2.6-.2-5.1-.5-3.4-.5-5.2-.4-8.6-.4-.3 0-.6 0-.9-.1-.2 0-.4-.1-.5-.1-.6-.2-1-.5-1.2-.8-.1-.2-.1-.3-.1-.5-.1-.7.2-1.5.6-2.3.2-.4.3-.7.4-1 .5-1.3.4-2.1.2-4.9 0-.2-.1-.4-.1-.7-.2-1.3-.5-2.3-.8-3.1-.4-1.1-.9-1.9-1.2-3-.6-2.1-1-4.3-.6-4.8H62.5c.2.1.5.2.9.3.5.1 1.1.2 2 .3 2.2.2 5.1-.2 6.6-.4.3-.1.6-.1.8-.1h.4c.4 0 .1.6-.1 1.2-.1.7-.5 3.3-.8 5.1-.3 1.8-.2 7.1-.1 8.8v.1c0 .3 1.9 1.2 3.5 2.1.7.2 1.4.5 1.8.9zm4.8-48.2c0 .1 0 .1 0 0-.1.1-.2.2-.2.3 0-.1-.1-.1-.1-.2 0 .1 0 .2-.1.2-.2.9-.6 2.4-2.2 4.1-.4.4-.7.6-1 .7-.5.1-.9 0-1.5-.1-.9-.2-1.3-.6-2.2-1.1-.1-.6-.3-1.3-.4-1.8 0-.3-.1-.5-.1-.6v-1l.4-.4s.7-1 1.8-1 2.2-.2 2.5-.5v-.1-.3c0-.1 0-.2-.1-.3-.4-1.4-2.1-1.8-1.4-4.8 0-.2.3-.5 1.2-.5-1.4-.3-2-.4-3-1.3.5-1.1 1-1.9 1.3-2.6.8-1.5.3-3.5.3-3.5.8-.3 1.6-.7 1.7-1 .9-2.8-.7-5.5-2.5-7.2 1.2-.1 2.6.1 3.6 1.1 2.4 2.4 1.8 5 1 6.8.6.7 2.1 2.9 1.2 5.3-.2.6-1.4.6-2.3 2.1 2.3-1.3 3.7-1 4.2.7 1 2.4-.6 5.3-2.1 7z"/><path d="M22 53.4v-.2c0-.2-.1-.5-.2-.9s-.1-.8-.2-1.3c-.5-4.7-1.9-9.4-4.9-11.3 3.7-2 16.8-8.5 21.9-10.5 2.9-1.2.8-.4-.2 1.4-.8 1.4-.3 2.9-.5 3.2-.6.8-12.6 10.5-15.9 19.6zm32.2-2.3c-3.4 3.8-12 11-18.2 11.4 8.7-.2 12.2 4.1 14.7 9.7 2.6-5.2 2.7-10.3 2.6-16.1 0-2.6 1.8-6 .9-5zm5.3-23L54.3 24s-1.1 3.1-1 4.6c.1 1.6-1.8 2.7-.9 3.6.9.9 3.2 2.5 4 3.4.7.9 1.1 7.1 1.1 7.1l2.2 2.7s1-1.8 1.1-6.3c.2-5.4-2.9-7.1-3.3-8.6-.4-1.4.6-2.9 2-2.4zm3.1 45.6l3.9.3s1.2-2.2 2.1-3.5c.9-1.4.4-1.6 0-4.6-.4-3-1.4-9.3-1.2-13.6l-3.1 10.2s1.8 5.6 1.6 6.4c-.1.8-3.3 4.8-3.3 4.8zm5 18.8c-1.1 0-2.5-.4-3.5-.8l-1 .3.2 4s5.2.7 4.6-.4c-.6-1.2-.3-3.1-.3-3.1zm12 .6c-1 0-.3.2.4 1.2.8 1 .1 2-.8 2.3l3.2.5 1.9-1.7c.1 0-3.7-2.3-4.7-2.3zM73 76c-1.6.5-4.2.8-5.9.8-1.7.1-3.7-.1-5-.5v1.4s1.2.5 5.4.5c3.5.1 5.7-.8 5.7-.8l.9-.8c-.1.1.5-1.1-1.1-.6zm-.2 3.1c-1.6.6-3.9.6-5.6.7-1.7.1-3.7-.1-5-.5l.1 1.4s.7.3 4.9.4c3.5.1 5.7-.7 5.7-.7l.3-.5c-.1-.1.3-1-.4-.8zm5.9-42.7c-.9-.8-1.4-2.4-1.5-3.3l-1.9 2.5.7 1.2s2.5.1 2.8.1c.4 0 .3-.1-.1-.5zM69 14.7c.6-.7.2-2.7.2-2.7L66 14.6l-4.4-.8-.5-1.3-1.3-.1c.8 1.8 1.8 2.5 3.3 3.1.9.4 4.5.9 5.9-.8z"style=opacity:.4;fill-rule:evenodd;clip-rule:evenodd /></svg></a></div></div>';
  		if (element) {
  			root.style.position = "absolute";
  			root.style.top = minimal ? "calc(100% - 42px)" : "calc(100% - 51px)";
  		}
  		if (css) {
  			if (_isString$3(css)) {
  				root.style.cssText = css;
  			} else if (_isObject$2(css)) {
  				css.data = "root";
  				gsap$5.set(root, css).kill();
  			}
  			if (root.style.top) {
  				root.style.bottom = "auto";
  			}
  			if (root.style.width) {
  				gsap$5.set(root, {xPercent: -50, left: "50%", right: "auto", data:"root"}).kill();
  			}
  		}
  		if (!minimal && root.offsetWidth < 600) {
  			root.setAttribute("class", "gs-dev-tools minimal");
  			if (element) {
  				root.style.top = "calc(100% - 42px)";
  			}
  		}
  		return root;
  	},
  	_clickedOnce = true, //perhaps we shouldn't preventDefault() on the first mousedown/touchstart/pointerdown so that iframes get focus properly. Did that previously, but now it seems to prevent interaction on the first click (annoying).
  	_addListener$1 = (e, type, callback, capture) => {
  		let handler, altType;
  		if (type === "mousedown" || type === "mouseup") {
  			e.style.cursor = "pointer";
  		}
  		if (type === "mousedown") {
  			//some browsers call BOTH mousedown AND touchstart, for example, on a single interaction so we need to skip one of them if both are called within 100ms.
  			altType = !_isUndefined$2(e.onpointerdown) ? "pointerdown" : !_isUndefined$2(e.ontouchstart) ? "touchstart" : null;
  			if (altType) {
  				handler = event => {
  					if (event.target.nodeName.toLowerCase() !== "select" && event.type === altType) { //don't preventDefault() on a <select> or else it won't open!
  						event.stopPropagation();
  						if (_clickedOnce) { //otherwise, both touchstart and mousedown will get called.
  							event.preventDefault();
  							callback.call(e, event);
  						}
  					} else if (event.type !== altType) {
  						callback.call(e, event);
  					}
  					_clickedOnce = true;
  				};
  				e.addEventListener(altType, handler, capture);
  				if (altType !== "pointerdown") {
  					e.addEventListener(type, handler, capture);
  				}
  				return;
  			}
  		}
  		e.addEventListener(type, callback, capture);
  	},
  	_removeListener$1 = (e, type, callback) => {
  		e.removeEventListener(type, callback);
  		type = type !== "mousedown" ? null : !_isUndefined$2(e.onpointerdown) ? "pointerdown" : !_isUndefined$2(e.ontouchstart) ? "touchstart" : null;
  		if (type) {
  			e.removeEventListener(type, callback);
  		}
  	},
  	_selectValue = (element, value, label, insertIfAbsent) => {
  		let options = element.options,
  			i = options.length,
  			option;
  		value += "";
  		while (--i > -1) {
  			if (options[i].innerHTML === value || options[i].value === value) {
  				element.selectedIndex = i;
  				label.innerHTML = options[i].innerHTML;
  				return options[i];
  			}
  		}
  		if (insertIfAbsent) {
  			option = _createElement$2("option", element);
  			option.setAttribute("value", value);
  			option.innerHTML = label.innerHTML = _isString$3(insertIfAbsent) ? insertIfAbsent : value;
  			element.selectedIndex = options.length - 1;
  		}
  	},
  	//increments the selected value of a <select> up or down by a certain amount.
  	_shiftSelectedValue = (element, amount, label) => {
  		let options = element.options,
  			i = Math.min(options.length - 1, Math.max(0, element.selectedIndex + amount));
  		element.selectedIndex = i;
  		if (label) {
  			label.innerHTML = options[i].innerHTML;
  		}
  		return options[i].value;
  	},
  	//moves everything from _globalTimeline into _recordedRoot and updates the _rootTween if it is currently controlling the Global timeline (_recordedRoot). _recordedTemp is just a temporary recording area for anything that happens while _recordedRoot is paused. Returns true if the _recordedRoot's duration changed due to the merge.
  	_merge$1 = () => {
  		let t = _globalTimeline$1._first,
  			duration, next, target;
  		if (_rootInstance) {
  			duration = _recordedRoot._dur;
  			while (t) {
  				next = t._next;
  				target = t._targets && t._targets[0];
  				if (!(_isFunction$4(target) && target === t.vars.onComplete && !t._dur) && !(target && target._gsIgnore)) { //typically, delayedCalls aren't included in the _recordedTemp, but since the hijacked add() below fires BEFORE TweenLite's constructor sets the target, we couldn't check that target === vars.onComplete there. And Draggable creates a tween with just an onComplete (no onReverseComplete), thus it fails that test. Therefore, we test again here to avoid merging that in.
  					_recordedRoot.add(t, t._start - t._delay);
  				}
  				t = next;
  			}
  			return (duration !== _recordedRoot.duration());
  		}
  	},
  	_buildPlayPauseMorph = svg => {
  		let tl = gsap$5.timeline({data:"root", parent:_independentRoot, onComplete:() => tl.kill() });
  		tl.to(svg.querySelector(".play-1"), {duration:0.4, attr:{d:"M5.75,3.13 C5.75,9.79 5.75,16.46 5.75,23.13 4.08,23.13 2.41,23.13 0.75,23.13 0.75,16.46 0.75,9.79 0.75,3.12 2.41,3.12 4.08,3.12 5.75,3.12"}, ease:"power2.inOut", rotation:360, transformOrigin:"50% 50%"})
  		  .to(svg.querySelector(".play-2"), {duration:0.4, attr:{d:"M16.38,3.13 C16.38,9.79 16.38,16.46 16.38,23.13 14.71,23.13 13.04,23.13 11.38,23.13 11.38,16.46 11.38,9.79 11.38,3.12 13.04,3.12 14.71,3.12 16.38,3.12"}, ease:"power2.inOut", rotation:360, transformOrigin:"50% 50%"}, 0.05);
  		return tl;
  	},

  	_buildLoopAnimation = svg => {
  		let tl = gsap$5.timeline({data:"root", id:"loop", parent:_independentRoot, paused:true, onComplete:() => tl.kill() });
  		tl.to(svg, {duration: 0.5, rotation:360, ease:"power3.inOut", transformOrigin:"50% 50%"})
  		  .to(svg.querySelectorAll(".loop-path"), {duration:0.5, fill:"#91e600", ease:"none"}, 0);
  		return tl;
  	},

  	_getAnimationById = id => gsap$5.getById(id) || _independentRoot.getById(id) || (id === _recordedRoot.vars.id && _recordedRoot),



  	_initCore$5 = core => {
  		gsap$5 = core || _getGSAP$4();
  		if (!_coreInitted$5) {
  			if (gsap$5 && _windowExists$4()) {
  				_doc$4 = document;
  				_docEl = _doc$4.documentElement;
  				_win$5 = window;
  				gsap$5.registerPlugin(Draggable);
  				_globalTimeline$1 = gsap$5.globalTimeline;
  				_globalTimeline$1._sort = true;
  				_globalTimeline$1.autoRemoveChildren = false;
  				Animation$1 = gsap$5.core.Animation;
  				_independentRoot = gsap$5.timeline({data:"indy", autoRemoveChildren:true, smoothChildTiming:true});
  				_independentRoot.kill();
  				_independentRoot._dp = 0; //don't let it revert to the global timeline as its parent.
  				_independentRoot.to({}, {duration:1e12});
  				_recordedRoot = gsap$5.timeline({data:"root", id:"Global Timeline", autoRemoveChildren:false, smoothChildTiming:true, parent:_independentRoot});
  				_rootTween = gsap$5.to(_recordedRoot, {duration:1, time:1, ease:"none", data:"root", id:"_rootTween", paused:true, immediateRender:false, parent:_independentRoot});
  				// so that auto-overwriting works. Initially we transferred the tweens to the _recordedRoot.
  				_globalTimeline$1.killTweensOf = function(targets, props, onlyActive) {
  					_recordedRoot.killTweensOf(targets, props, onlyActive);
  					_recordedRoot.killTweensOf.call(_globalTimeline$1, targets, props, onlyActive);
  				};
  				_independentRoot._start = gsap$5.ticker.time;
  				gsap$5.ticker.add(time => _independentRoot.render(time - _independentRoot._start));

  				//align the all of the playheads so they're starting at 0 now.
  				_globalTimeline$1._start += _globalTimeline$1._time;
  				_recordedRoot._start = _globalTimeline$1._time = _globalTimeline$1._tTime = 0;
  				_delayedCall = (delay, callback, params, scope) => gsap$5.to(callback, {delay:delay, duration:0, onComplete:callback, onReverseComplete:callback, onCompleteParams:params, onReverseCompleteParams:params, callbackScope:scope, parent:_independentRoot});

  				//in case GSDevTools.create() is called before anything is actually on the global timeline, we've gotta update it or else the duration will be 0 and it'll be stuck.
  				_delayedCall(0.01, () => _rootInstance ? _rootInstance.update() : _merge$1());

  				//initially we record everything into the _recordedRoot Timeline because developers might call GSDevTools.create() AFTER some of their code executes, but after 2 seconds if there aren't any GSDevTool instances that have globalSync enabled, we should dump all the stuff from _recordedRoot into the global timeline to improve performance and avoid issues where _recordedRoot is paused and reaches its end and wants to stop the playhead.
  				_delayedCall(2, () => {
  					let t, next, offset;
  					if (!_rootInstance) {
  						_merge$1();
  						t = _recordedRoot._first;
  						offset = _recordedRoot._start;
  						while (t) {
  							next = t._next;
  							//any animations that aren't finished should be dumped into the root timeline. If they're done, just kill them.
  							if (t._tDur !== t._tTime || (!t._dur && t.progress() !== 1)) {
  								_globalTimeline$1.add(t, t._start - t._delay + offset);
  							} else {
  								t.kill();
  							}
  							t = next;
  						}
  					}
  					if (GSDevTools.globalRecordingTime > 2) {
  						_delayedCall(GSDevTools.globalRecordingTime - 2, () => {
  							_rootInstance && _rootInstance.update();
  							_globalTimeline$1.autoRemoveChildren = true;
  						});
  					} else {
  						_globalTimeline$1.autoRemoveChildren = true;
  					}
  					_startupPhase = false;
  				});
  				_coreInitted$5 = 1;
  			}
  		}
  	},
  	_checkIndependence = (animation, vars) => {
  		if (!vars.globalSync && animation.parent !== _globalTimeline$1) { //in case it's nested in a timeline (playing it won't help if the parent timeline isn't playing).
  			_globalTimeline$1.add(animation, _globalTimeline$1.time());
  		}
  	},







  	GSDevTools = function(vars) {
  		if (!_coreInitted$5) {
  			_initCore$5();
  			gsap$5 || console.warn("Please gsap.registerPlugin(GSDevTools)");
  		}

  		this.vars = vars = vars || {};
  		if (vars.animation) {
  			(GSDevTools.getByAnimation(vars.animation) || {kill:() => 0}).kill();
  		}
  		vars.id = vars.id || (_isString$3(vars.animation) ? vars.animation : _idSeed++); //try to find a unique ID so that sessionStorage can be mapped to it (otherwise, for example, all the embedded codepens on a page would share the same settings). So if no id is defined, see if there's a string-based "animation" defined. Last of all, we default to a numeric counter that we increment.
  		_lookup$1[vars.id + ""] = this;

  		("globalSync" in vars) || (vars.globalSync = !vars.animation); //if the user calls create() and passes in an animation AFTER the initial recording time has elapsed, there's a good chance the animation won't be in the recordedRoot, so we change the default globalSync to false because that's the most intuitive behavior.

  		//GENERAL/UTILITY
  		let _self = this,
  			root = _createRootElement(vars.container, vars.minimal, vars.css),
  			find = s => root.querySelector(s),
  			record = (key, value) => {
  				if (vars.persist !== false && _supportsStorage) {
  					sessionStorage.setItem("gs-dev-" + key + vars.id, value);
  				}
  				return value;
  			},
  			recall = key => {
  				let value;
  				if (vars.persist !== false && _supportsStorage) {
  					value = sessionStorage.getItem("gs-dev-" + key + vars.id);
  					return (key === "animation") ? value : (key === "loop") ? (value === "true") : parseFloat(value); // handle data typing too.
  				}
  			},


  			//SCRUBBER/PROGRESS
  			playhead = find(".playhead"),
  			timelineTrack = find(".timeline-track"),
  			progressBar = find(".progress-bar"),
  			timeLabel = find(".time"),
  			durationLabel = find(".duration"),
  			pixelToTimeRatio, timeAtDragStart, dragged, skipDragUpdates,
  			progress = 0,
  			inPoint = find(".in-point"),
  			outPoint = find(".out-point"),
  			inProgress = 0,
  			outProgress = 100,
  			pausedWhenDragStarted,
  			list = find(".animation-list"),
  			animationLabel = find(".animation-label"),
  			selectedAnimation, //the currently selected animation
  			linkedAnimation, //the animation that's linked to all the controls and scrubber. This is always _rootTween if globalSync is true, so it can be different than the selectedAnimation!
  			declaredAnimation, //whatever the user defines in the config object initially (often this will be null). If the user defines a string, it'll be resolved to a real Animation instance for this variable.
  			startTime, endTime,
  			_fullyInitialized, //we call initialize() initially, and then again on the very next tick just in case someone called GSDevTools.create() BEFORE they create their animations. This variable tracks that state. Note: we don't record sessionStorage.setItem() until we're fully initialized, otherwise we may inadvertently set in/out points to the defaults just because the animation couldn't be found (yet).
  			keyboardHandler,
  			playPauseButton = find(".play-pause"),
  			playPauseMorph = _buildPlayPauseMorph(playPauseButton),
  			paused = false,
  			loopButton = find(".loop"),
  			loopAnimation = _buildLoopAnimation(loopButton),
  			loopEnabled,
  			timeScale = find(".time-scale select"),
  			timeScaleLabel = find(".time-scale-label"),
  			//spits back a common onPress function for anything that's dragged along the timeline (playhead, inPoint, outPoint). The originRatio is a value from 0-1 indicating how far along the x-axis the origin is located (0.5 is in the center, 0 is left, 1 is on right side). limitElement is optional, and sets the bounds such that the element can't be dragged past the limitElement.
  			onPressTimeline = (element, originRatio, limitToInOut) => {
  				return function(e) {
  					let trackBounds = timelineTrack.getBoundingClientRect(),
  						elementBounds = element.getBoundingClientRect(),
  						left = elementBounds.width * originRatio,
  						x = gsap$5.getProperty(element, "x"),
  						minX = trackBounds.left - elementBounds.left - left + x,
  						maxX = trackBounds.right - elementBounds.right + (elementBounds.width - left) + x,
  						unlimitedMinX = minX,
  						limitBounds;
  					if (limitToInOut) {
  						if (element !== inPoint) {
  							limitBounds = inPoint.getBoundingClientRect();
  							if (limitBounds.left) { //if inPoint is hidden (like display:none), ignore.
  								minX += (limitBounds.left + limitBounds.width) - trackBounds.left;
  							}
  						}
  						if (element !== outPoint) {
  							limitBounds = outPoint.getBoundingClientRect();
  							if (limitBounds.left) { //if outPoint is hidden (like display:none), ignore.
  								maxX -= (trackBounds.left + trackBounds.width) - limitBounds.left;
  							}
  						}
  					}
  					pausedWhenDragStarted = paused;
  					this.applyBounds({minX:minX, maxX:maxX});
  					pixelToTimeRatio = linkedAnimation.duration() / trackBounds.width;
  					timeAtDragStart = -unlimitedMinX * pixelToTimeRatio;
  					if (!skipDragUpdates) {
  						linkedAnimation.pause(timeAtDragStart + pixelToTimeRatio * this.x);
  					} else {
  						linkedAnimation.pause();
  					}
  					if (this.target === playhead) {
  						if (this.activated) {
  							this.allowEventDefault = false;
  						}
  						this.activated = true;
  					}
  					dragged = true;
  				};
  			},
  			progressDrag = Draggable.create(playhead, {
  				type:"x",
  				cursor: "ew-resize",
  				allowNativeTouchScrolling: false,
  				allowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem "stuck" to the mouse.
  				onPress: onPressTimeline(playhead, 0.5, true),
  				onDrag: function() {
  					let time = timeAtDragStart + pixelToTimeRatio * this.x;
  					if (time < 0) {
  						time = 0;
  					} else if (time > linkedAnimation._dur) {
  						time = linkedAnimation._dur;
  					}
  					if (!skipDragUpdates) {
  						linkedAnimation.time(time);
  					}
  					progressBar.style.width = Math.min(outProgress - inProgress, Math.max(0, (time / linkedAnimation._dur) * 100 - inProgress)) + "%";
  					timeLabel.innerHTML = time.toFixed(2);
  				},
  				onRelease: function() {
  					if (!paused) {
  						linkedAnimation.resume();
  					}
  				}
  			})[0],
  			resetInOut = () => {
  				inProgress = 0;
  				outProgress = 100;
  				inPoint.style.left = "0%";
  				outPoint.style.left = "100%";
  				record("in", inProgress);
  				record("out", outProgress);
  				updateProgress(true);
  			},
  			inDrag = Draggable.create(inPoint, {
  				type: "x",
  				cursor: "ew-resize",
  				zIndexBoost: false,
  				allowNativeTouchScrolling: false,
  				allowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem "stuck" to the mouse.
  				onPress: onPressTimeline(inPoint, 1, true),
  				onDoubleClick: resetInOut,
  				onDrag: function() {
  					inProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;
  					linkedAnimation.progress(inProgress / 100);
  					updateProgress(true);
  				},
  				onRelease: function() {
  					if (inProgress < 0) {
  						inProgress = 0;
  					}
  					_clearSelection();
  					//for responsiveness, convert the px-based transform into %-based left position.
  					inPoint.style.left = inProgress + "%";
  					record("in", inProgress);
  					gsap$5.set(inPoint, {x:0, data:"root", display:"block"}); //set display:block so that it remains visible even when the minimal skin is enabled.
  					if (!paused) {
  						linkedAnimation.resume();
  					}
  				}
  			})[0],
  			outDrag = Draggable.create(outPoint, {
  				type: "x",
  				cursor: "ew-resize",
  				allowNativeTouchScrolling: false,
  				allowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem "stuck" to the mouse.
  				zIndexBoost: false,
  				onPress: onPressTimeline(outPoint, 0, true),
  				onDoubleClick: resetInOut,
  				onDrag: function() {
  					outProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;
  					linkedAnimation.progress(outProgress / 100);
  					updateProgress(true);
  				},
  				onRelease: function() {
  					if (outProgress > 100) {
  						outProgress = 100;
  					}
  					_clearSelection();
  					//for responsiveness, convert the px-based transform into %-based left position.
  					outPoint.style.left = outProgress + "%";
  					record("out", outProgress);
  					gsap$5.set(outPoint, {x:0, data:"root", display:"block"}); //set display:block so that it remains visible even when the minimal skin is enabled.
  					if (!pausedWhenDragStarted) {
  						play();
  						linkedAnimation.resume();
  					}
  				}
  			})[0],
  			updateProgress = function(force) { // NOTE: "force" is actually the "time" when this method gets called by the gsap.ticker!
  				if (progressDrag.isPressed && force !== true) {
  					return;
  				}
  				let p = (!loopEnabled && selectedAnimation._repeat === -1) ? selectedAnimation.totalTime() / selectedAnimation.duration() * 100 : (linkedAnimation.progress() * 100) || 0,
  					repeatDelayPhase = (selectedAnimation._repeat && selectedAnimation._rDelay && selectedAnimation.totalTime() % (selectedAnimation.duration() + selectedAnimation._rDelay) > selectedAnimation.duration()),
  					target;
  				if (p > 100) {
  					p = 100;
  				}
  				if (p >= outProgress) {
  					if (loopEnabled && !linkedAnimation.paused() && !progressDrag.isDragging) {
  						if (!repeatDelayPhase) {
  							p = inProgress;
  							target = linkedAnimation._targets && linkedAnimation._targets[0];
  							if (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.
  								target.seek(startTime + ((endTime - startTime) * inProgress / 100));
  							}
  							if (selectedAnimation._repeat > 0 && !inProgress && outProgress === 100) {
  								if (selectedAnimation.totalProgress() === 1) {
  									linkedAnimation.totalProgress(0, true).resume();
  								}
  							} else {
  								linkedAnimation.progress(p / 100, true).resume();
  							}
  						}
  					} else {
  						if (p !== outProgress || selectedAnimation._repeat === -1) {
  							p = outProgress;
  							linkedAnimation.progress(p / 100);
  						}
  						if (!paused && (outProgress < 100 || selectedAnimation.totalProgress() === 1 || selectedAnimation._repeat === -1)) {
  							pause();
  						}
  					}

  				} else if (p < inProgress) {
  					p = inProgress;
  					linkedAnimation.progress(p / 100, true);
  				}
  				if (p !== progress || force === true) {
  					progressBar.style.left = inProgress + "%";
  					progressBar.style.width = Math.max(0, p - inProgress) + "%";
  					playhead.style.left = p + "%";
  					timeLabel.innerHTML = linkedAnimation._time.toFixed(2);
  					durationLabel.innerHTML = linkedAnimation._dur.toFixed(2);
  					if (dragged) {
  						playhead.style.transform = "translate(-50%,0)";
  						playhead._gsap.x = "0px";
  						playhead._gsap.xPercent = -50;
  						dragged = false;
  					}
  					progress = p;
  				} else if (linkedAnimation.paused() !== paused) { //like if the user has an addPause() in the middle of the animation.
  					togglePlayPause();
  				}
  			},
  			onPressSeekBar = function(e) {
  				if (progressDrag.isPressed) {
  					return;
  				}
  				let bounds = e.target.getBoundingClientRect(),
  					x = (e.changedTouches ? e.changedTouches[0] : e).clientX,
  					p = ((x - bounds.left) / bounds.width) * 100;
  				if (p < inProgress) {
  					inProgress = p = Math.max(0, p);
  					inPoint.style.left = inProgress + "%";
  					inDrag.startDrag(e);
  					return;
  				} else if (p > outProgress) {
  					outProgress = p = Math.min(100, p);
  					outPoint.style.left = outProgress + "%";
  					outDrag.startDrag(e);
  					return;
  				}
  				linkedAnimation.progress(p / 100).pause();
  				updateProgress(true);
  				progressDrag.startDrag(e);
  			},



  			//PLAY/PAUSE button
  			play = () => {
  				if (linkedAnimation.progress() >= outProgress / 100) {
  					_checkIndependence(linkedAnimation, vars);
  					let target = linkedAnimation._targets && linkedAnimation._targets[0];
  					if (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.
  						target.seek(startTime + ((endTime - startTime) * inProgress / 100));
  					}
  					if (linkedAnimation._repeat && !inProgress) {
  						linkedAnimation.totalProgress(0, true); //for repeating animations, don't get stuck in the last iteration - jump all the way back to the start.
  					} else if (!linkedAnimation.reversed()) {
  						linkedAnimation.progress(inProgress / 100, true);
  					}
  				}
  				playPauseMorph.play();
  				linkedAnimation.resume();
  				if (paused) {
  					_self.update();
  				}
  				paused = false;
  			},
  			pause = () => {
  				playPauseMorph.reverse();
  				if (linkedAnimation) {
  					linkedAnimation.pause();
  				}
  				paused = true;
  			},
  			togglePlayPause = () => {
  				if (paused) {
  					play();
  				} else {
  					pause();
  				}
  			},



  			//REWIND button
  			onPressRewind = e => {
  				if (progressDrag.isPressed) {
  					return;
  				}
  				//_self.update();
  				_checkIndependence(linkedAnimation, vars);
  				let target = linkedAnimation._targets && linkedAnimation._targets[0];
  				if (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.
  					target.seek(startTime + ((endTime - startTime) * inProgress / 100));
  				}
  				linkedAnimation.progress(inProgress / 100, true);
  				if (!paused) {
  					linkedAnimation.resume();
  				}
  			},



  			//LOOP button
  			loop = value => {
  				loopEnabled = value;
  				record("loop", loopEnabled);
  				if (loopEnabled) {
  					loopAnimation.play();
  					if (linkedAnimation.progress() >= outProgress / 100) {
  						let target = linkedAnimation._targets && linkedAnimation._targets[0];
  						if (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.
  							target.seek(startTime + ((endTime - startTime) * inProgress / 100));
  						}
  						if (selectedAnimation._repeat && !inProgress && outProgress === 100) {
  							linkedAnimation.totalProgress(0, true);
  						} else {
  							linkedAnimation.progress(inProgress / 100, true);
  						}
  						play();
  					}
  				} else {
  					loopAnimation.reverse();
  				}
  			},

  			toggleLoop = () => loop(!loopEnabled),



  			//ANIMATIONS list
  			updateList = () => {
  				let animations = _getChildrenOf((declaredAnimation && !vars.globalSync) ? declaredAnimation : _recordedRoot, true),
  					options = list.children,
  					matches = 0,
  					option,	i;
  				if (declaredAnimation && !vars.globalSync) {
  					animations.unshift(declaredAnimation);
  				} else if (!vars.hideGlobalTimeline) {
  					animations.unshift(_recordedRoot);
  				}
  				for (i = 0; i < animations.length; i++) {
  					option = options[i] || _createElement$2("option", list);
  					option.animation = animations[i];
  					matches = (i && animations[i].vars.id === animations[i-1].vars.id) ? matches + 1 : 0;
  					option.setAttribute("value", (option.innerHTML = animations[i].vars.id + (matches ? " [" + matches + "]" : (animations[i+1] && animations[i+1].vars.id === animations[i].vars.id) ? " [0]" : "")));
  				}
  				for (; i < options.length; i++) {
  					list.removeChild(options[i]);
  				}
  			},
  			animation = function(anim) {
  				let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,
  					tl, maxDuration;
  				if (!arguments.length) {
  					return selectedAnimation;
  				}
  				if (_isString$3(anim)) {
  					anim = _getAnimationById(anim);
  				}
  				//console.log("animation() ", anim.vars.id);
  				if (!(anim instanceof Animation$1)) {
  					console.warn("GSDevTools error: invalid animation.");
  				}
  				if (anim === selectedAnimation) {
  					return;
  				}
  				if (selectedAnimation) {
  					selectedAnimation._inProgress = inProgress;
  					selectedAnimation._outProgress = outProgress;
  				}
  				selectedAnimation = anim;
  				if (linkedAnimation) {
  					ts = linkedAnimation.timeScale();
  					if (linkedAnimation._targets && linkedAnimation._targets[0] === declaredAnimation) {
  						declaredAnimation.resume();
  						linkedAnimation.kill();
  					}
  				}
  				inProgress = selectedAnimation._inProgress || 0;
  				outProgress = selectedAnimation._outProgress || 100;
  				inPoint.style.left = inProgress + "%";
  				outPoint.style.left = outProgress + "%";
  				if (_fullyInitialized) { //don't record inProgress/outProgress unless we're fully instantiated because people may call GSDevTools.create() before creating/defining their animations, thus the inTime/outTime may not exist yet.
  					record("animation", selectedAnimation.vars.id);
  					record("in", inProgress);
  					record("out", outProgress);
  				}
  				startTime = 0;
  				maxDuration = vars.maxDuration || Math.min(1000, _getClippedDuration(selectedAnimation));
  				if (selectedAnimation === _recordedRoot || vars.globalSync) {
  					_merge$1();
  					linkedAnimation = _rootTween;
  					_rootInstance && _rootInstance !== _self && console.warn("Error: GSDevTools can only have one instance that's globally synchronized.");
  					_rootInstance = _self;
  					//_recording = true;
  					if (selectedAnimation !== _recordedRoot) {
  						tl = selectedAnimation;
  						endTime = tl.totalDuration();
  						if (endTime > 99999999) { //in the case of an infinitely repeating animation, just use a single iteration's duration instead.
  							endTime = tl.duration();
  						}
  						while (tl.parent.parent) {
  							startTime = (startTime / tl._ts) + tl._start;
  							endTime = (endTime / tl._ts) + tl._start;
  							tl = tl.parent;
  						}
  					} else {
  						endTime = _recordedRoot.duration();
  					}
  					if (endTime - startTime > maxDuration) { //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.
  						endTime = startTime + maxDuration;
  					}
  					_recordedRoot.pause(startTime);
  					_rootTween.vars.time = endTime;
  					_rootTween.invalidate();
  					_rootTween.duration(endTime - startTime).timeScale(ts);
  					//wait for a tick before starting because some browsers freeze things immediately following a <select> selection, like on MacOS it flashes a few times before disappearing, so this prevents a "jump".
  					if (paused) {
  						//jump forward and then back in order to make sure the start/end values are recorded internally right away and don't drift outside this tween.
  						_rootTween.progress(1).pause(0);
  					} else {
  						_delayedCall(0.01, () => {
  							_rootTween.resume().progress(inProgress / 100);
  							if (paused) {
  								play();
  							}
  						});
  					}

  				} else {
  					if (_rootInstance === _self) {
  						_rootInstance = null;
  					}
  					if (selectedAnimation === declaredAnimation || !declaredAnimation) {
  						linkedAnimation = selectedAnimation;
  						if (!loopEnabled && linkedAnimation._repeat) {
  							loop(true);
  						}
  					} else { //if an animation is declared in the config object, and the user chooses a sub-animation (nested), we tween the playhead of the declaredAnimation to keep everything synchronized even though globalSync isn't true.
  						tl = selectedAnimation;
  						endTime = tl.totalDuration();
  						if (endTime > 99999999) { //in the case of an infinitely repeating animation, just use a single iteration's duration instead.
  							endTime = tl.duration();
  						}
  						while (tl.parent.parent && tl !== declaredAnimation) {
  							startTime = (startTime / (tl._ts || tl._pauseTS)) + tl._start;
  							endTime = (endTime / (tl._ts || tl._pauseTS)) + tl._start;
  							tl = tl.parent;
  						}
  						if (endTime - startTime > maxDuration) { //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.
  							endTime = startTime + maxDuration;
  						}
  						declaredAnimation.pause(startTime);
  						linkedAnimation = gsap$5.to(declaredAnimation, {duration: endTime - startTime, time:endTime, ease:"none", data:"root", parent:_independentRoot});
  					}
  					linkedAnimation.timeScale(ts);
  					_rootTween.pause();
  					_recordedRoot.resume();
  					linkedAnimation.seek(0);
  				}

  				durationLabel.innerHTML = linkedAnimation.duration().toFixed(2);
  				_selectValue(list, selectedAnimation.vars.id, animationLabel);
  			},
  			updateRootDuration = () => {
  				let time, ratio, duration;
  				if (selectedAnimation === _recordedRoot) {
  					time = _recordedRoot._time;
  					_recordedRoot.progress(1, true).time(time, true); //jump to the end and back again because sometimes a tween that hasn't rendered yet will affect duration, like a TimelineMax.tweenTo() where the duration gets set in the onStart.
  					time = (_rootTween._dp._time - _rootTween._start) * _rootTween._ts;
  					duration = Math.min(1000, _recordedRoot.duration());
  					if (duration === 1000) {
  						duration = Math.min(1000, _getClippedDuration(_recordedRoot));
  					}
  					ratio = _rootTween.duration() / duration;
  					if (ratio !== 1 && duration) {
  						inProgress *= ratio;
  						if (outProgress < 100) {
  							outProgress *= ratio;
  						}
  						_rootTween.seek(0);
  						_rootTween.vars.time = duration;
  						_rootTween.invalidate();
  						_rootTween.duration(duration);
  						_rootTween.time(time);
  						durationLabel.innerHTML = duration.toFixed(2);
  						inPoint.style.left = inProgress + "%";
  						outPoint.style.left = outProgress + "%";
  						updateProgress(true);
  					}
  				}
  			},
  			onChangeAnimation = e => {
  				animation(list.options[list.selectedIndex].animation);
  				if (e.target && e.target.blur) { //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.
  					e.target.blur();
  				}
  				paused && play();
  			},



  			//TIMESCALE button
  			onChangeTimeScale = e => {
  				let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,
  					target;
  				linkedAnimation.timeScale(ts);
  				record("timeScale", ts);
  				if (!paused) {
  					if (linkedAnimation.progress() >= outProgress / 100) {
  						target = linkedAnimation._targets && linkedAnimation._targets[0];
  						if (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.
  							target.seek(startTime + ((endTime - startTime) * inProgress / 100));
  						}
  						linkedAnimation.progress(inProgress / 100, true).pause();
  					} else {
  						linkedAnimation.pause();
  					}
  					_delayedCall(0.01, () => linkedAnimation.resume());
  				}
  				timeScaleLabel.innerHTML = ts + "x";
  				if (timeScale.blur) { //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.
  					timeScale.blur();
  				}
  			},



  			//AUTOHIDE
  			autoHideTween = gsap$5.to([find(".gs-bottom"), find(".gs-top")], {duration:0.3, autoAlpha:0, y:50, ease:"power2.in", data:"root", paused:true, parent:_independentRoot}),
  			hidden = false,
  			onMouseOut = e => {
  				if (!Draggable.hitTest(e, root) && !progressDrag.isDragging && !inDrag.isDragging && !outDrag.isDragging) {
  					autoHideDelayedCall.restart(true);
  				}
  			},
  			hide = () => {
  				if (!hidden) {
  					autoHideTween.play();
  					autoHideDelayedCall.pause();
  					hidden = true;
  				}
  			},
  			show = () => {
  				autoHideDelayedCall.pause();
  				if (hidden) {
  					autoHideTween.reverse();
  					hidden = false;
  				}
  			},
  			toggleHide = () => {
  				if (hidden) {
  					show();
  				} else {
  					hide();
  				}
  			},
  			autoHideDelayedCall = _delayedCall(1.3, hide).pause(),
  			initialize = preliminary => {
  				//if on startup, someone does a timeline.seek(), we must honor it, so when initialize() is called, we record _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).
  				if (_startupPhase && !_globalStartTime) {
  					_globalStartTime = _recordedRoot._start;
  				}
  				_fullyInitialized = !preliminary;
  				declaredAnimation = _parseAnimation(vars.animation);
  				if (declaredAnimation && !declaredAnimation.vars.id) {
  					declaredAnimation.vars.id = "[no id]";
  				}
  				_merge$1();
  				updateList();
  				let savedAnimation = _getAnimationById(recall("animation"));
  				if (savedAnimation) {
  					savedAnimation._inProgress = recall("in") || 0;
  					savedAnimation._outProgress = recall("out") || 100;
  				}
  				vars.paused && pause();
  				selectedAnimation = null;
  				animation(declaredAnimation || savedAnimation || _recordedRoot);
  				let ts = vars.timeScale || recall("timeScale"),
  					savedInOut = (savedAnimation === selectedAnimation);
  				if (ts) {
  					_selectValue(timeScale, ts, timeScaleLabel, ts + "x");
  					linkedAnimation.timeScale(ts);
  				}
  				inProgress = (("inTime" in vars) ? _timeToProgress(vars.inTime, selectedAnimation, 0, 0) : savedInOut ? savedAnimation._inProgress : 0) || 0;
  				if (inProgress === 100 && !vars.animation && savedAnimation) { //in case there's a recorded animation (sessionStorage) and then the user defines an inTime that exceeds that animation's duration, just default back to the Global Timeline. Otherwise the in/out point will be at the very end and it'd be weird.
  					animation(_recordedRoot);
  					inProgress = _timeToProgress(vars.inTime, selectedAnimation, 0, 0) || 0;
  				}
  				if (inProgress) {
  					inPoint.style.left = inProgress + "%";
  					inPoint.style.display = outPoint.style.display = "block"; //set display:block so that it remains visible even when the minimal skin is enabled.
  				}
  				outProgress = (("outTime" in vars) ? _timeToProgress(vars.outTime, selectedAnimation, 100, inProgress) : savedInOut ? savedAnimation._outProgress : 0) || 100;
  				if (outProgress < inProgress) {
  					outProgress = 100;
  				}
  				if (outProgress !== 100) {
  					outPoint.style.left = outProgress + "%";
  					inPoint.style.display = outPoint.style.display = "block"; //set display:block so that it remains visible even when the minimal skin is enabled.
  				}
  				loopEnabled = ("loop" in vars) ? vars.loop : recall("loop");
  				loopEnabled && loop(true);
  				vars.paused && linkedAnimation.progress(inProgress / 100, true).pause();
  				if (_startupPhase && selectedAnimation === _recordedRoot && _globalStartTime && vars.globalSync && !paused) {
  					linkedAnimation.time(-_globalStartTime, true);
  				}
  				updateProgress(true);
  			};



  		//INITIALIZATION TASKS
  		_addListener$1(list, "change", onChangeAnimation);
  		_addListener$1(list, "mousedown", updateList);
  		_addListener$1(playPauseButton, "mousedown", togglePlayPause);
  		_addListener$1(find(".seek-bar"), "mousedown", onPressSeekBar);
  		_addListener$1(find(".rewind"), "mousedown", onPressRewind);
  		_addListener$1(loopButton, "mousedown", toggleLoop);
  		_addListener$1(timeScale, "change", onChangeTimeScale);

  		if (vars.visibility === "auto") {
  			_addListener$1(root, "mouseout", onMouseOut);
  			//_addListener(find(".gs-hit-area"), "mouseover", show);
  			_addListener$1(root, "mouseover", show);

  		} else if (vars.visibility === "hidden") {
  			hidden = true;
  			autoHideTween.progress(1);
  		}

  		if (vars.keyboard !== false) {
  			if (_keyboardInstance && vars.keyboard) {
  				console.warn("[GSDevTools warning] only one instance can be affected by keyboard shortcuts. There is already one active.");
  			} else {
  				_keyboardInstance = _self; //we can't have multiple instances all affected by the keyboard.
  				keyboardHandler = e => { //window.parent allows things to work inside of an iframe, like on codepen.
  					let key = e.keyCode ? e.keyCode : e.which,
  						ts;
  					if (key === 32) { //spacebar
  						togglePlayPause();
  					} else if (key === 38) { //up arrow
  						ts = parseFloat(_shiftSelectedValue(timeScale, -1, timeScaleLabel));
  						linkedAnimation.timeScale(ts);
  						record("timeScale", ts);
  					} else if (key === 40) { //down arrow
  						ts = parseFloat(_shiftSelectedValue(timeScale, 1, timeScaleLabel));
  						linkedAnimation.timeScale(ts);
  						record("timeScale", ts);
  					} else if (key === 37) { //left arrow
  						onPressRewind();
  					} else if (key === 39) { //right arrow
  						linkedAnimation.progress(outProgress / 100);
  					} else if (key === 76) { //"L" key
  						toggleLoop();
  					} else if (key === 72) { //"H" key
  						toggleHide();
  					} else if (key === 73) { //"I" key
  						inProgress = linkedAnimation.progress() * 100;
  						record("in", inProgress);
  						inPoint.style.left = inProgress + "%";
  						updateProgress(true);
  					} else if (key === 79) { //"O" key
  						outProgress = linkedAnimation.progress() * 100;
  						record("out", outProgress);
  						outPoint.style.left = outProgress + "%";
  						updateProgress(true);
  					}
  				};
  				_addListener$1(_docEl, "keydown", keyboardHandler);
  			}
  		}


  		gsap$5.set(playhead, {xPercent:-50, x:0, data:"root"}); //so that when we drag, x is properly discerned (browsers report in pure pixels rather than percents)
  		gsap$5.set(inPoint, {xPercent:-100, x:0, data:"root"});
  		inPoint._gsIgnore = outPoint._gsIgnore = playhead._gsIgnore = playPauseButton._gsIgnore = loopButton._gsIgnore = true;

  		//Draggable fires off a TweenLite.set() that affects the transforms, and we don't want them to get into the _recordedRoot, so kill those tweens.
  		gsap$5.killTweensOf([inPoint, outPoint, playhead]);


  		initialize(_startupPhase);
  		if (_startupPhase) {
  			//developers may call GSDevTools.create() before they even create some of their animations, so the inTime/outTime or animation values may not exist, thus we wait for 1 tick and initialize again, just in case.
  			_delayedCall(0.0001, initialize, [false], this);
  		}
  		gsap$5.ticker.add(updateProgress);

  		this.update = forceMerge => {
  			if (_rootInstance === _self) {
  				if (!_rootTween.paused() || forceMerge) {
  					_merge$1();
  				}
  				updateRootDuration();
  			}
  		};

  		this.kill = () => {
  			_removeListener$1(list, "change", onChangeAnimation);
  			_removeListener$1(list, "mousedown", updateList);
  			_removeListener$1(playPauseButton, "mousedown", togglePlayPause);
  			_removeListener$1(find(".seek-bar"), "mousedown", onPressSeekBar);
  			_removeListener$1(find(".rewind"), "mousedown", onPressRewind);
  			_removeListener$1(loopButton, "mousedown", toggleLoop);
  			_removeListener$1(timeScale, "change", onChangeTimeScale);
  			progressDrag.disable();
  			inDrag.disable();
  			outDrag.disable();
  			gsap$5.ticker.remove(updateProgress);
  			_removeListener$1(root, "mouseout", onMouseOut);
  			_removeListener$1(root, "mouseover", show);
  			_removeListener$1(_docEl, "keydown", keyboardHandler);
  			root.parentNode.removeChild(root);
  			if (_rootInstance === _self) {
  				_rootInstance = null;
  			}
  			delete _lookup$1[vars.id + ""];
  		};

  		this.minimal = function(value) {
  			let isMinimal = root.classList.contains("minimal"),
  				p;
  			if (!arguments.length || isMinimal === value) {
  				return isMinimal;
  			}
  			if (value) {
  				root.classList.add("minimal");
  			} else {
  				root.classList.remove("minimal");
  			}
  			if (vars.container) {
  				root.style.top = value ? "calc(100% - 42px)" : "calc(100% - 51px)";
  			}
  			if (progressDrag.isPressed) {
  				skipDragUpdates = true; //just in case there's actually a tween/timeline in the linkedAnimation that is altering this GSDevTool instance's "minimal()" value, it could trigger a recursive loop in the drag handlers, like if they update linkedAnimation's time/progress which in turn triggers this minimal() function which in turn dues the same, and so on.
  				progressDrag.endDrag(progressDrag.pointerEvent);
  				skipDragUpdates = false;

  				p = linkedAnimation.progress() * 100;
  				progressBar.style.width = Math.max(0, p - inProgress) + "%";
  				playhead.style.left = p + "%";
  				playhead.style.transform = "translate(-50%,0)";
  				playhead._gsap.x = "0px";
  				playhead._gsap.xPercent = -50;

  				progressDrag.startDrag(progressDrag.pointerEvent, true);
  			}
  		};

  		//expose methods:
  		this.animation = animation;
  		this.updateList = updateList;

  	}; //if on startup, someone does a timeline.seek(), we need to honor it, so when initialize() is called, it'll check the _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).



  GSDevTools.version = "3.4.0";
  GSDevTools.globalRecordingTime = 2;

  GSDevTools.getById = id => id ? _lookup$1[id] : _rootInstance;

  GSDevTools.getByAnimation = animation => {
  	if (_isString$3(animation)) {
  		animation = gsap$5.getById(animation);
  	}
  	for (let p in _lookup$1) {
  		if (_lookup$1[p].animation() === animation) {
  			return _lookup$1[p];
  		}
  	}
  };

  GSDevTools.create = vars => new GSDevTools(vars);

  GSDevTools.register = _initCore$5;

  _getGSAP$4() && gsap$5.registerPlugin(GSDevTools);

  /*!
   * ScrollTrigger 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /* eslint-disable */

  let gsap$6, _coreInitted$6, _win$6, _doc$5, _docEl$1, _body$2, _root, _resizeDelay, _raf, _request, _toArray$4, _clamp$1, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp$3, _i, _prevWidth, _prevHeight, _autoRefresh,
  	_limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
  	_startup = 1,
  	_proxies = [],
  	_scrollers = [],
  	_getTime$1 = Date.now,
  	_time1 = _getTime$1(),
  	_lastScrollTime = 0,
  	_enabled = 1,
  	_passThrough$1 = v => v,
  	_windowExists$5 = () => typeof(window) !== "undefined",
  	_getGSAP$5 = () => gsap$6 || (_windowExists$5() && (gsap$6 = window.gsap) && gsap$6.registerPlugin && gsap$6),
  	_isViewport = e => !!~_root.indexOf(e),
  	_getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],
  	_getScrollFunc = (element, {s, sc}) => {
  		let i = _scrollers.indexOf(element),
  			func = ~i ? _scrollers[i+1] : _getProxyProp(element, s) || (_isViewport(element) ? sc : function(value) { return arguments.length ? (element[s] = value) : element[s]; });
  		!~i && _scrollers.push(element, func);
  		return func;
  	},
  	_getBoundsFunc = element => _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? () => {_winOffsets.width = _win$6.innerWidth; _winOffsets.height = _win$6.innerHeight; return _winOffsets;} : () => _getBounds$1(element)),
  	_getSizeFunc = (scroller, isViewport, {d, d2, a}) => (a = _getProxyProp(scroller, "getBoundingClientRect")) ? () => a()[d] : () => (isViewport ? _win$6["inner" + d2] : scroller["client" + d2]) || 0,
  	_getOffsetsFunc = (element, isViewport) => !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : () => _winOffsets,
  	_maxScroll = (element, {s, d2, d, a}) => (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl$1[s], _body$2[s]) - (_win$6["inner" + d2] || _docEl$1["client" + d2] || _body$2["client" + d2]) : element[s] - element["offset" + d2],
  	_iterateAutoRefresh = (func, events) => {
  		for (let i = 0; i < _autoRefresh.length; i += 3) {
  			(!events || ~events.indexOf(_autoRefresh[i+1])) && func(_autoRefresh[i], _autoRefresh[i+1], _autoRefresh[i+2]);
  		}
  	},
  	_isString$4 = value => typeof(value) === "string",
  	_isFunction$5 = value => typeof(value) === "function",
  	_isNumber$3 = value => typeof(value) === "number",
  	_isObject$3 = value => typeof(value) === "object",
  	_abs$2 = Math.abs,
  	_scrollLeft = "scrollLeft",
  	_scrollTop = "scrollTop",
  	_left = "left",
  	_top = "top",
  	_right = "right",
  	_bottom = "bottom",
  	_width = "width",
  	_height = "height",
  	_Right = "Right",
  	_Left = "Left",
  	_Top = "Top",
  	_Bottom = "Bottom",
  	_padding = "padding",
  	_margin = "margin",
  	_Width = "Width",
  	_Height = "Height",
  	_px = "px",
  	_horizontal = {s: _scrollLeft, p: _left, p2: _Left, os: _right, os2: _Right, d: _width, d2: _Width, a: "x", sc: function(value) { return arguments.length ? _win$6.scrollTo(value, _vertical.sc()) : _win$6.pageXOffset || _doc$5[_scrollLeft] || _docEl$1[_scrollLeft] || _body$2[_scrollLeft] || 0}},
  	_vertical = {s: _scrollTop, p: _top, p2: _Top, os: _bottom, os2: _Bottom, d: _height, d2: _Height, a: "y", op: _horizontal, sc: function(value) { return arguments.length ? _win$6.scrollTo(_horizontal.sc(), value) : _win$6.pageYOffset || _doc$5[_scrollTop] || _docEl$1[_scrollTop] || _body$2[_scrollTop] || 0}},
  	_getComputedStyle$1 = element => _win$6.getComputedStyle(element),
  	_makePositionable = element => element.style.position = (_getComputedStyle$1(element).position === "absolute") ? "absolute" : "relative", // if the element already has position: absolute, leave that, otherwise make it position: relative
  	_setDefaults$2 = (obj, defaults) => {
  		for (let p in defaults) {
  			(p in obj) || (obj[p] = defaults[p]);
  		}
  		return obj;
  	},
  	//_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,
  	_getBounds$1 = (element, withoutTransforms) => {
  		let tween = withoutTransforms && _getComputedStyle$1(element)[_transformProp$3] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$6.to(element, {x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0}).progress(1),
  			bounds = element.getBoundingClientRect();
  		tween && tween.progress(0).kill();
  		return bounds;
  	},
  	_getSize$2 = (element, {d2}) => element["offset" + d2] || element["client" + d2] || 0,
  	_getLabels = animation => {
  		return value => {
  			let a = [],
  				labels = animation.labels,
  				duration = animation.duration(),
  				p;
  			for (p in labels) {
  				a.push(labels[p] / duration);
  			}
  			return gsap$6.utils.snap(a, value);
  		};
  	},
  	_multiListener = (func, element, types, callback) => types.split(",").forEach(type => func(element, type, callback)),
  	_addListener$2 = (element, type, func) => element.addEventListener(type, func, {passive: true}),
  	_removeListener$2 = (element, type, func) => element.removeEventListener(type, func),
  	_markerDefaults = {startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight:"normal"},
  	_defaults$1 = {toggleActions: "play", anticipatePin: 0},
  	_keywords = {top: 0, left: 0, center: 0.5, bottom: 1, right: 1},
  	_offsetToPx = (value, size) => {
  		if (_isString$4(value)) {
  			let eqIndex = value.indexOf("="),
  				relative = ~eqIndex ? +(value.charAt(eqIndex-1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
  			if (relative) {
  				(value.indexOf("%") > eqIndex) && (relative *= size / 100);
  				value = value.substr(0, eqIndex-1);
  			}
  			value = relative + ((value in _keywords) ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
  		}
  		return value;
  	},
  	_createMarker = (type, name, container, direction, {startColor, endColor, fontSize, indent, fontWeight}, offset, matchWidthEl) => {
  		let e = _doc$5.createElement("div"),
  			useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
  			isScroller = type.indexOf("scroller") !== -1,
  			parent = useFixedPosition ? _body$2 : container,
  			isStart = type.indexOf("start") !== -1,
  			color = isStart ? startColor : endColor,
  			css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  		css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");
  		(isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
  		matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
  		e._isStart = isStart;
  		e.setAttribute("class", "gsap-marker-" + type);
  		e.style.cssText = css;
  		e.innerText = name || name === 0 ? type + "-" + name : type;
  		parent.insertBefore(e, parent.children[0]);
  		e._offset = e["offset" + direction.op.d2];
  		_positionMarker(e, 0, direction, isStart);
  		return e;
  	},
  	_positionMarker = (marker, start, direction, flipped) => {
  		let vars = {display: "block"},
  			side = direction[flipped ? "os2" : "p2"],
  			oppositeSide = direction[flipped ? "p2" : "os2"];
  		marker._isFlipped = flipped;
  		vars[direction.a + "Percent"] = flipped ? -100 : 0;
  		vars[direction.a] = flipped ? 1 : 0;
  		vars["border" + side + _Width] = 1;
  		vars["border" + oppositeSide + _Width] = 0;
  		vars[direction.p] = start;
  		gsap$6.set(marker, vars);
  	},
  	_triggers = [],
  	_ids = {},
  	_sync = () => _request || (_request = _raf(_updateAll)),
  	_onScroll = () => {
  		if (!_request) {
  			_request = _raf(_updateAll);
  			_lastScrollTime || _dispatch("scrollStart");
  			_lastScrollTime = _getTime$1();
  		}
  	},
  	_onResize = () => !_refreshing && _resizeDelay.restart(true), // ignore resizes triggered by refresh()
  	_listeners = {},
  	_emptyArray = [],
  	_media = [],
  	_creatingMedia, // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
  	_lastMediaTick,
  	_onMediaChange = e => {
  		let tick = gsap$6.ticker.frame,
  			matches = [],
  			i = 0;
  		if (_lastMediaTick !== tick) {
  			_revertAll();
  			for (; i < _media.length; i+=2) {
  				_win$6.matchMedia(_media[i]).matches ? matches.push(i) : _revertAll(1, _media[i]); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
  			}
  			_revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.
  			for (i = 0; i < matches.length; i++) {
  				_creatingMedia = _media[matches[i]];
  				_media[matches[i]+1](e);
  			}
  			_creatingMedia = 0;
  			_refreshAll(0, 1);
  			_lastMediaTick = tick;
  		}
  	},
  	_softRefresh = () => _removeListener$2(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true),
  	_dispatch = type => (_listeners[type] && _listeners[type].map(f => f())) || _emptyArray,
  	_savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
  	_revertRecorded = media => {
  		for (let i = 0; i < _savedStyles.length; i+=4) {
  			if (!media || _savedStyles[i+3] === media) {
  				_savedStyles[i].style.cssText = _savedStyles[i+1];
  				_savedStyles[i+2].uncache = 1;
  			}
  		}
  	},
  	_revertAll = (kill, media) => {
  		let trigger;
  		for (_i = 0; _i < _triggers.length; _i++) {
  			trigger = _triggers[_i];
  			if (!media || trigger.media === media) {
  				if (kill) {
  					trigger.kill(1);
  				} else {
  					trigger.scroll.rec || (trigger.scroll.rec = trigger.scroll()); // record the scroll positions so that in each refresh() we can ensure that it doesn't shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times. If one was already recorded, don't re-record because unpinning may have occurred and made it shorter.
  					trigger.revert();
  				}
  			}
  		}
  		_revertRecorded(media);
  		media || _dispatch("revert");
  	},
  	_refreshAll = (force, skipRevert) => {
  		if (_lastScrollTime && !force) {
  			_addListener$2(ScrollTrigger, "scrollEnd", _softRefresh);
  			return;
  		}
  		let refreshInits = _dispatch("refreshInit");
  		skipRevert || _revertAll();
  		for (_i = 0; _i < _triggers.length; _i++) {
  			_triggers[_i].refresh();
  		}
  		refreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.
  		_i = _triggers.length;
  		while (_i--) {
  			_triggers[_i].scroll.rec = 0;
  		}
  		_dispatch("refresh");
  	},
  	_updateAll = () => {
  		let l = _triggers.length,
  			time = _getTime$1(),
  			recordVelocity = time - _time1 >= 50;
  		if (recordVelocity) {
  			if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
  				_lastScrollTime = 0;
  				_dispatch("scrollEnd");
  			}
  			_time2 = _time1;
  			_time1 = time;
  		}
  		for (_i = 0; _i < l; _i++) {
  			_triggers[_i] && _triggers[_i].update(0, recordVelocity);
  		}
  		_request = 0;
  	},
  	_propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink"],
  	_stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
  	_swapPinOut = (pin, spacer, state) => {
  		_setState(state);
  		if (pin.parentNode === spacer) {
  			let parent = spacer.parentNode;
  			if (parent) {
  				parent.insertBefore(pin, spacer);
  				parent.removeChild(spacer);
  			}
  		}
  	},
  	_swapPinIn = (pin, spacer, cs) => {
  		if (pin.parentNode !== spacer) {
  			let i = _propNamesToCopy.length,
  				spacerStyle = spacer.style,
  				pinStyle = pin.style,
  				p;
  			while (i--) {
  				p = _propNamesToCopy[i];
  				spacerStyle[p] = cs[p];
  			}
  			spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
  			(cs.display === "inline") && (spacerStyle.display = "inline-block");
  			pinStyle[_bottom] = pinStyle[_right] = "auto";
  			spacerStyle.overflow = "visible";
  			spacerStyle.boxSizing = "border-box";
  			spacerStyle[_width] = _getSize$2(pin, _horizontal) + _px;
  			spacerStyle[_height] = _getSize$2(pin, _vertical) + _px;
  			spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
  			pinStyle[_width] = cs[_width];
  			pinStyle[_height] = cs[_height];
  			pinStyle[_padding] = cs[_padding];
  			pin.parentNode.insertBefore(spacer, pin);
  			spacer.appendChild(pin);
  		}
  	},
  	_capsExp$1 = /([A-Z])/g,
  	_setState = state => {
  		if (state) {
  			let style = state.t.style,
  				l = state.length,
  				i = 0,
  				p, value;
  			for (; i < l; i +=2) {
  				value = state[i+1];
  				p = state[i];
  				if (value) {
  					style[p] = value;
  				} else if (style[p]) {
  					style.removeProperty(p.replace(_capsExp$1, "-$1").toLowerCase());
  				}
  			}
  		}
  	},
  	_getState = element => { // returns an array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
  		let l = _stateProps.length,
  			style = element.style,
  			state = [],
  			i = 0;
  		for (; i < l; i++) {
  			state.push(_stateProps[i], style[_stateProps[i]]);
  		}
  		state.t = element;
  		return state;
  	},
  	_copyState = (state, override, omitOffsets) => {
  		let result = [],
  			l = state.length,
  			i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true
  			p;
  		for (; i < l; i += 2) {
  			p = state[i];
  			result.push(p, (p in override) ? override[p] : state[i+1]);
  		}
  		result.t = state.t;
  		return result;
  	},
  	_winOffsets = {left:0, top:0},
  	_parsePosition$1 = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) => {
  		_isFunction$5(value) && (value = value(self));
  		if (_isString$4(value) && value.substr(0,3) === "max") {
  			value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
  		}
  		if (!_isNumber$3(value)) {
  			_isFunction$5(trigger) && (trigger = trigger(self));
  			let element = _toArray$4(trigger)[0] || _body$2,
  				bounds = _getBounds$1(element) || {},
  				offsets = value.split(" "),
  				localOffset, globalOffset, display;
  			if ((!bounds || (!bounds.left && !bounds.top)) && _getComputedStyle$1(element).display === "none") { // if display is "none", it won't report getBoundingClientRect() properly
  				display = element.style.display;
  				element.style.display = "block";
  				bounds = _getBounds$1(element);
  				display ? (element.style.display = display) : element.style.removeProperty("display");
  			}
  			localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
  			globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
  			value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
  			markerScroller && _positionMarker(markerScroller, globalOffset, direction, (scrollerSize - globalOffset < 20 || (markerScroller._isStart && globalOffset > 20)));
  			scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
  		} else if (markerScroller) {
  			_positionMarker(markerScroller, scrollerSize, direction, true);
  		}
  		if (marker) {
  			let position = value + scrollerSize,
  				isStart = marker._isStart;
  			scrollerMax = "scroll" + direction.d2;
  			_positionMarker(marker, position, direction, (isStart && position > 20) || (!isStart && (useFixedPosition ? Math.max(_body$2[scrollerMax], _docEl$1[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1));
  			if (useFixedPosition) {
  				scrollerBounds = _getBounds$1(markerScroller);
  				useFixedPosition && (marker.style[direction.op.p] = (scrollerBounds[direction.op.p] - direction.op.m - marker._offset) + _px);
  			}
  		}
  		return Math.round(value);
  	},
  	_prefixExp = /(?:webkit|moz|length)/i,
  	_reparent = (element, parent) => {
  		if (element.parentNode !== parent) {
  			let style = element.style,
  				p, cs;
  			if (parent === _body$2) {
  				element._stOrig = style.cssText; // record original inline styles so we can revert them later
  				cs = _getComputedStyle$1(element);
  				for (p in cs) { // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
  					if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
  						style[p] = cs[p];
  					}
  				}
  			} else {
  				style.cssText = element._stOrig;
  			}
  			parent.appendChild(element);
  		}
  	},
  	// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
  	_getTweenCreator = (scroller, direction) => {
  		let getScroll = _getScrollFunc(scroller, direction),
  			prop = "_scroll" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
  			lastScroll,
  			getTween = (scrollTo, vars, initialValue, change1, change2) => {
  				let tween = getTween.tween,
  					onComplete = vars.onComplete,
  					modifiers = {};
  				tween && tween.kill();
  				lastScroll = getScroll();
  				vars[prop] = scrollTo;
  				vars.modifiers = modifiers;
  				modifiers[prop] = value => {
  					if (Math.abs(getScroll() - lastScroll) > 7) { // if the user scrolls, kill the tween. Need a margin of error because some browsers like iOS Safari misreport the scroll position!
  						tween.kill();
  						getTween.tween = 0;
  						value = getScroll();
  					} else if (change1) {
  						value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
  					}
  					return (lastScroll = Math.round(value));
  				};
  				vars.onComplete = () => {
  					getTween.tween = 0;
  					onComplete && onComplete.call(tween);
  				};
  				tween = getTween.tween = gsap$6.to(scroller, vars);
  				return tween;
  			};
  		scroller[prop] = getScroll;
  		return getTween;
  	};

  _horizontal.op = _vertical;



  class ScrollTrigger {

  	constructor(vars, animation) {
  		_coreInitted$6 || ScrollTrigger.register(gsap$6) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
  		this.init(vars, animation);
  	}

  	init(vars, animation) {
  		this.progress = 0;
  		this.vars && this.kill(1); // in case it's being initted again
  		if (!_enabled) {
  			this.update = this.refresh = this.kill = _passThrough$1;
  			return;
  		}
  		vars = _setDefaults$2((_isString$4(vars) || _isNumber$3(vars) || vars.nodeType) ? {trigger: vars} : vars, _defaults$1);
  		let direction = vars.horizontal ? _horizontal : _vertical,
  			{onUpdate, toggleClass, id, onToggle, onRefresh, scrub, trigger, pin, pinSpacing, invalidateOnRefresh, anticipatePin, onScrubComplete, onSnapComplete, once, snap, pinReparent} = vars,
  			isToggle = !scrub && scrub !== 0,
  			scroller = _toArray$4(vars.scroller || _win$6)[0],
  			scrollerCache = gsap$6.core.getCache(scroller),
  			isViewport = _isViewport(scroller),
  			useFixedPosition = isViewport || _getProxyProp(scroller, "pinType") === "fixed",
  			callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
  			toggleActions = isToggle && (once ? "play" : vars.toggleActions).split(" "),
  			markers = "markers" in vars ? vars.markers : _defaults$1.markers,
  			borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle$1(scroller)["border" + direction.p2 + _Width]) || 0,
  			self = this,
  			onRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),
  			getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
  			getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
  			tweenTo, pinCache, snapFunc, isReverted, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars,
  			change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacingActive, markerStartSetter,
  			markerEndSetter, cs, snap1, snap2, scrubScrollTime, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, enabled, prevProgress, prevScroll, prevAnimProgress;

  		self.media = _creatingMedia;
  		anticipatePin *= 45;
  		_triggers.push(self);
  		self.scroller = scroller;
  		self.scroll = _getScrollFunc(scroller, direction);
  		scroll1 = self.scroll();
  		self.vars = vars;
  		animation = animation || vars.animation;
  		scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
  			top: _getTweenCreator(scroller, _vertical),
  			left: _getTweenCreator(scroller, _horizontal)
  		};
  		self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
  		if (animation) {
  			animation.vars.lazy = false;
  			animation._initted || (animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true));
  			self.animation = animation.pause();
  			animation.scrollTrigger = self;
  			scrubSmooth = _isNumber$3(scrub) && scrub;
  			scrubSmooth && (scrubTween = gsap$6.to(animation, {ease: "power3", duration: scrubSmooth, onComplete: () => onScrubComplete && onScrubComplete(self)}));
  			snap1 = 0;
  			id || (id = animation.vars.id);
  		}
  		if (snap) {
  			_isObject$3(snap) || (snap = {snapTo: snap});
  			gsap$6.set(isViewport ? [_body$2, _docEl$1] : scroller, {scrollBehavior: "auto"}); // smooth scrolling doesn't work with snap.
  			snapFunc = _isFunction$5(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getLabels(animation) : gsap$6.utils.snap(snap.snapTo);
  			snapDurClamp = snap.duration || {min: 0.1, max: 2};
  			snapDurClamp = _isObject$3(snapDurClamp) ? _clamp$1(snapDurClamp.min, snapDurClamp.max) : _clamp$1(snapDurClamp, snapDurClamp);
  			snapDelayedCall = gsap$6.delayedCall(snap.delay || (scrubSmooth / 2) || 0.1, () => {
  				if (!_lastScrollTime || (_lastScrollTime === scrubScrollTime && !_pointerIsDown)) {
  					let totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,
  						velocity = ((totalProgress - snap2) / (_getTime$1() - _time2) * 1000) || 0,
  						change1 = _abs$2(velocity / 2) * velocity / 0.185,
  						naturalEnd = totalProgress + change1,
  						endValue = _clamp$1(0, 1, snapFunc(naturalEnd, self)),
  						change2 = endValue - totalProgress - change1,
  						scroll = self.scroll(),
  						endScroll = Math.round(start + endValue * change),
  						tween = tweenTo.tween;
  					if (scroll <= end && scroll >= start) {
  						if (tween && !tween._initted) { // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
  							if (tween.data <= Math.abs(endScroll - scroll)) {
  								return;
  							}
  							tween.kill();
  						}
  						tweenTo(endScroll, {
  							duration: snapDurClamp(_abs$2( (Math.max(_abs$2(naturalEnd - totalProgress), _abs$2(endValue - totalProgress)) * 0.185 / velocity / 0.05) || 0)),
  							ease: snap.ease || "power3",
  							data: Math.abs(endScroll - scroll), // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
  							onComplete: () => {
  								snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
  								onSnapComplete && onSnapComplete(self);
  							}
  						}, start + totalProgress * change, change1 * change, change2 * change);
  					}
  				} else {
  					snapDelayedCall.restart(true);
  				}
  			}).pause();
  		}
  		id && (_ids[id] = self);
  		trigger = self.trigger = _toArray$4(trigger || pin)[0];
  		pin = pin === true ? trigger : _toArray$4(pin)[0];
  		_isString$4(toggleClass) && (toggleClass = {targets: trigger, className: toggleClass});
  		if (pin) {
  			(pinSpacing === false || pinSpacing === _margin) || (pinSpacing = _getComputedStyle$1(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.
  			self.pin = pin;
  			vars.force3D !== false && gsap$6.set(pin, {force3D: true});
  			pinCache = gsap$6.core.getCache(pin);
  			if (!pinCache.spacer) { // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
  				pinCache.spacer = spacer = _doc$5.createElement("div");
  				spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));
  				pinCache.pinState = pinOriginalState = _getState(pin);
  			} else {
  				pinOriginalState = pinCache.pinState;
  			}
  			self.spacer = spacer = pinCache.spacer;
  			cs = _getComputedStyle$1(pin);
  			spacingStart = cs[pinSpacing + direction.os2];
  			pinGetter = gsap$6.getProperty(pin);
  			pinSetter = gsap$6.quickSetter(pin, direction.a, _px);
  			_swapPinIn(pin, spacer, cs);
  			pinState = _getState(pin);
  		}
  		if (markers) {
  			markerVars = _isObject$3(markers) ? _setDefaults$2(markers, _markerDefaults) : _markerDefaults;
  			markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
  			markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
  			offset = markerStartTrigger["offset" + direction.op.d2];
  			markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);
  			markerEnd =_createMarker("end", id, scroller, direction, markerVars, offset);
  			if (!useFixedPosition) {
  				_makePositionable(scroller);
  				gsap$6.set([markerStartTrigger, markerEndTrigger], {force3D: true});
  				markerStartSetter = gsap$6.quickSetter(markerStartTrigger, direction.a, _px);
  				markerEndSetter = gsap$6.quickSetter(markerEndTrigger, direction.a, _px);
  			}
  		}

  		self.revert = revert => {
  			let r = revert !== false,
  				prevRefreshing = _refreshing;
  			if (r !== isReverted) {
  				if (r) {
  					prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.
  					prevProgress = self.progress;
  					prevAnimProgress = animation && animation.progress();
  					markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.style.display = "none");
  				}

  				_refreshing = 1;
  				self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.
  				_refreshing = prevRefreshing;
  				pin && r && _swapPinOut(pin, spacer, pinOriginalState);
  				isReverted = r;
  			}
  		};


  		self.refresh = soft => {
  			if (_refreshing || !enabled) {
  				return;
  			}
  			if (pin && soft && _lastScrollTime) {
  				_addListener$2(ScrollTrigger, "scrollEnd", _softRefresh);
  				return;
  			}

  			_refreshing = 1;
  			scrubTween && scrubTween.kill();
  			invalidateOnRefresh && animation && animation.progress(0).invalidate();
  			isReverted || self.revert();
  			let size = getScrollerSize(),
  				scrollerBounds = getScrollerOffsets(),
  				max = _maxScroll(scroller, direction),
  				offset = 0,
  				otherPinOffset = 0,
  				parsedEnd = vars.end,
  				parsedEndTrigger = vars.endTrigger || trigger,
  				parsedStart = vars.start || (pin || !trigger ? "0 0" : "0 100%"),
  				pinIndex = pin && Math.max(0, _triggers.indexOf(self)) || 0,
  				cs, bounds, scroll, isVertical, override, i, curTrigger;
  			if (pinIndex) { // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
  				i = pinIndex;
  				while (i--) {
  					_triggers[i].pin === pin && _triggers[i].revert();
  				}
  			}
  			start = _parsePosition$1(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);
  			_isFunction$5(parsedEnd) && (parsedEnd = parsedEnd(self));
  			if (_isString$4(parsedEnd) && !parsedEnd.indexOf("+=")) {
  				if (~parsedEnd.indexOf(" ")) {
  					parsedEnd = (_isString$4(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
  				} else {
  					offset = _offsetToPx(parsedEnd.substr(2), size);
  					parsedEnd = _isString$4(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.
  					parsedEndTrigger = trigger;
  				}
  			}
  			end = Math.max(start, _parsePosition$1(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;
  			change = (end - start) || ((start -= 0.01) && 0.001);
  			if (pin) {
  				i = pinIndex;
  				while (i--) {
  					curTrigger = _triggers[i];
  					if (curTrigger.pin === pin && curTrigger.start - curTrigger._pinPush < start) {
  						otherPinOffset += curTrigger.end - curTrigger.start;
  					}
  				}
  				start += otherPinOffset;
  				end += otherPinOffset;
  				self._pinPush = otherPinOffset;
  				if (markerStart && otherPinOffset) { // offset the markers if necessary
  					cs = {};
  					cs[direction.a] = "+=" + otherPinOffset;
  					gsap$6.set([markerStart, markerEnd], cs);
  				}
  				cs = _getComputedStyle$1(pin);
  				isVertical = (direction === _vertical);
  				scroll = self.scroll(); // recalculate because the triggers can affect the scroll
  				pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
  				_swapPinIn(pin, spacer, cs);
  				pinState = _getState(pin);
  				// transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.
  				bounds = _getBounds$1(pin, true);
  				if (pinSpacing) {
  					spacer.style[pinSpacing + direction.os2] = change + otherPinOffset + _px;
  					spacingActive = (pinSpacing === _padding) ? _getSize$2(pin, direction) + change + otherPinOffset : 0;
  					spacingActive && (spacer.style[direction.d] = spacingActive + _px); // for box-sizing: border-box (must include padding).
  					useFixedPosition && self.scroll(prevScroll);
  				}
  				if (useFixedPosition) {
  					override = {
  						top: (bounds.top + (isVertical ? scroll - start : 0)) + _px,
  						left: (bounds.left + (isVertical ? 0 : scroll - start)) + _px,
  						boxSizing: "border-box",
  						position: "fixed"
  					};
  					override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
  					override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
  					override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
  					override[_padding] = cs[_padding];
  					override[_padding + _Top] = cs[_padding + _Top];
  					override[_padding + _Right] = cs[_padding + _Right];
  					override[_padding + _Bottom] = cs[_padding + _Bottom];
  					override[_padding + _Left] = cs[_padding + _Left];
  					pinActiveState = _copyState(pinOriginalState, override, pinReparent);
  				}
  				if (animation) { // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
  					animation.progress(1, true);
  					pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
  					change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.
  					animation.progress(0, true);
  				} else {
  					pinChange = change;
  				}
  				if (pinIndex) { // make sure we revert from first to last to make sure things reach their end state properly
  					for (i = 0; i < pinIndex; i++) {
  						_triggers[i].pin === pin && _triggers[i].revert(false);
  					}
  				}
  			} else if (trigger && self.scroll()) { // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
  				bounds = trigger.parentNode;
  				while (bounds && bounds !== _body$2) {
  					if (bounds._pinOffset) {
  						start -= bounds._pinOffset;
  						end -= bounds._pinOffset;
  					}
  					bounds = bounds.parentNode;
  				}
  			}
  			self.start = start;
  			self.end = end;
  			scroll1 = scroll2 = self.scroll(); // reset velocity
  			scroll1 < prevScroll && self.scroll(prevScroll);
  			self.revert(false);
  			_refreshing = 0;
  			prevAnimProgress && isToggle && animation.progress(prevAnimProgress, true);
  			if (prevProgress !== self.progress) { // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
  				scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.
  				self.progress = prevProgress;
  				self.update();
  			}
  			pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
  			onRefresh && onRefresh(self);
  		};

  		self.getVelocity = () => ((self.scroll() - scroll2) / (_getTime$1() - _time2) * 1000) || 0;

  		self.update = (reset, recordVelocity) => {
  			let scroll = self.scroll(),
  				p = reset ? 0 : (scroll - start) / change,
  				clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
  				prevProgress = self.progress,
  				isActive, wasActive, toggleState, action, stateChanged, toggled;
  			if (recordVelocity) {
  				scroll2 = scroll1;
  				scroll1 = scroll;
  				if (snap) {
  					snap2 = snap1;
  					snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
  				}
  			}
  			// anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).
  			(anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + ((scroll - scroll2) / (_getTime$1() - _time2)) * anticipatePin) && (clipped = 0.0001);
  			if (clipped !== prevProgress && enabled) {
  				isActive = self.isActive = !!clipped && clipped < 1;
  				wasActive = !!prevProgress && prevProgress < 1;
  				toggled = isActive !== wasActive;
  				stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)
  				self.direction = clipped > prevProgress ? 1 : -1;
  				self.progress = clipped;
  				if (!isToggle) {
  					if (scrubTween && !_refreshing && !_startup) {
  						scrubTween.vars.totalProgress = clipped;
  						scrubTween.invalidate().restart();
  					} else if (animation) {
  						animation.totalProgress(clipped, !!_refreshing);
  					}
  				}
  				if (pin) {
  					reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
  					if (!useFixedPosition) {
  						pinSetter(pinStart + pinChange * clipped);
  					} else if (stateChanged) {
  						action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)
  						if (pinReparent) {
  							if (!_refreshing && (isActive || action)) {
  								let bounds = _getBounds$1(pin, true),
  									offset = scroll - start;
  								pin.style.top = (bounds.top + (direction === _vertical ? offset : 0)) + _px;
  								pin.style.left = (bounds.left + (direction === _vertical ? 0 : offset)) + _px;
  							}
  							_reparent(pin, !_refreshing && (isActive || action) ? _body$2 : spacer);
  						}
  						_setState(isActive || action ? pinActiveState : pinState);
  						(pinChange !== change && clipped < 1 && isActive) || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));
  					}
  				}
  				if (snap && !tweenTo.tween && !_refreshing && !_startup) {
  					scrubScrollTime = _lastScrollTime;
  					snapDelayedCall.restart(true);
  				}
  				toggleClass && toggled && (!once || isActive) && _toArray$4(toggleClass.targets).forEach(el => el.classList[isActive ? "add" : "remove"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.
  				onUpdate && !isToggle && !reset && onUpdate(self);
  				if (stateChanged && !_refreshing) {
  					toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.
  					if (isToggle) {
  						action = (!toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1]) || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)
  						if (animation && (action === "complete" || action === "reset" || action in animation)) {
  							if (action === "complete") {
  								animation.pause().totalProgress(1);
  							} else if (action === "reset") {
  								animation.restart(true).pause();
  							} else {
  								animation[action]();
  							}
  						}
  						onUpdate && onUpdate(self);
  					}
  					if (toggled || !_limitCallbacks) { // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
  						onToggle && toggled && onToggle(self);
  						callbacks[toggleState] && callbacks[toggleState](self);
  						once && (clipped === 1 ? self.kill() : (callbacks[toggleState] = 0)); // a callback shouldn't be called again if once is true.
  						if (!toggled) { // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
  							toggleState = clipped === 1 ? 1 : 3;
  							callbacks[toggleState] && callbacks[toggleState](self);
  						}
  					}
  				} else if (isToggle && onUpdate && !_refreshing) {
  					onUpdate(self);
  				}
  			}
  			// update absolutely-positioned markers (only if the scroller isn't the viewport)
  			if (markerEndSetter) {
  				markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));
  				markerEndSetter(scroll);
  			}
  		};

  		self.enable = () => {
  			if (!enabled) {
  				enabled = true;
  				_addListener$2(scroller, "resize", _onResize);
  				_addListener$2(scroller, "scroll", _onScroll);
  				onRefreshInit && _addListener$2(ScrollTrigger, "refreshInit", onRefreshInit);
  				!animation || !animation.add ? self.refresh() : gsap$6.delayedCall(0.01, self.refresh) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick.
  			}
  		};

  		self.disable = reset => {
  			if (enabled) {
  				reset !== false && self.revert();
  				enabled = self.isActive = false;
  				scrubTween && scrubTween.pause();
  				pin && _swapPinOut(pin, spacer, pinOriginalState);
  				pinCache && (pinCache.uncache = 1);
  				onRefreshInit && _removeListener$2(ScrollTrigger, "refreshInit", onRefreshInit);
  				if (snapDelayedCall) {
  					snapDelayedCall.pause();
  					tweenTo.tween && tweenTo.tween.kill();
  				}
  				if (!isViewport) {
  					let i = _triggers.length;
  					while (i--) {
  						if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
  							return; //don't remove the listeners if there are still other triggers referencing it.
  						}
  					}
  					_removeListener$2(scroller, "resize", _onResize);
  					_removeListener$2(scroller, "scroll", _onScroll);
  				}
  			}
  		};

  		self.kill = revert => {
  			self.disable(revert);
  			id && (delete _ids[id]);
  			let i = _triggers.indexOf(self);
  			_triggers.splice(i, 1);
  			i === _i && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
  			if (animation) {
  				animation.scrollTrigger = null;
  				revert && animation.render(-1);
  				animation.kill();
  			}
  			markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.parentNode.removeChild(m));
  			pinCache && (pinCache.uncache = 1);
  		};

  		self.enable();
  	}


  	static register(core) {
  		if (!_coreInitted$6) {
  			gsap$6 = core || _getGSAP$5();
  			if (_windowExists$5() && window.document) {
  				_win$6 = window;
  				_doc$5 = document;
  				_docEl$1 = _doc$5.documentElement;
  				_body$2 = _doc$5.body;
  			}
  			if (gsap$6) {
  				_toArray$4 = gsap$6.utils.toArray;
  				_clamp$1 = gsap$6.utils.clamp;
  				gsap$6.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.
  				if (_body$2) {
  					_raf = _win$6.requestAnimationFrame || (f => setTimeout(f, 16));
  					_addListener$2(_win$6, "mousewheel", _onScroll);
  					_root = [_win$6, _doc$5, _docEl$1, _body$2];
  					_addListener$2(_doc$5, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!
  					let bodyStyle = _body$2.style,
  						border = bodyStyle.borderTop,
  						bounds;
  					bodyStyle.borderTop = "1px solid #000"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.
  					bounds = _getBounds$1(_body$2);
  					_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding
  					_horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
  					border ? (bodyStyle.borderTop = border) : bodyStyle.removeProperty("border-top");
  					_syncInterval = setInterval(_sync, 200);
  					gsap$6.delayedCall(0.5, () => _startup = 0);
  					_addListener$2(_doc$5, "touchcancel", _passThrough$1); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.
  					_addListener$2(_body$2, "touchstart", _passThrough$1); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
  					_multiListener(_addListener$2, _doc$5, "pointerdown,touchstart,mousedown", () => _pointerIsDown = 1);
  					_multiListener(_addListener$2, _doc$5, "pointerup,touchend,mouseup", () => _pointerIsDown = 0);
  					_transformProp$3 = gsap$6.utils.checkPrefix("transform");
  					_stateProps.push(_transformProp$3);
  					_coreInitted$6 = _getTime$1();
  					_resizeDelay = gsap$6.delayedCall(0.2, _refreshAll).pause();
  					_autoRefresh = [_doc$5, "visibilitychange", () => {
  						let w = _win$6.innerWidth,
  							h = _win$6.innerHeight;
  						if (_doc$5.hidden) {
  							_prevWidth = w;
  							_prevHeight = h;
  						} else if (_prevWidth !== w || _prevHeight !== h) {
  							_onResize();
  						}
  					}, _doc$5, "DOMContentLoaded", _refreshAll, _win$6, "load", () => _lastScrollTime || _refreshAll(), _win$6, "resize", _onResize];
  					_iterateAutoRefresh(_addListener$2);

  				}
  			}
  		}
  		return _coreInitted$6;
  	}

  	static defaults(config) {
  		for (let p in config) {
  			_defaults$1[p] = config[p];
  		}
  	}

  	static kill() {
  		_enabled = 0;
  		_triggers.slice(0).forEach(trigger => trigger.kill(1));
  	}

  	static config(vars) {
  		("limitCallbacks" in vars) && (_limitCallbacks = !!vars.limitCallbacks);
  		let ms = vars.syncInterval;
  		ms && clearInterval(_syncInterval) || ((_syncInterval = ms) && setInterval(_sync, ms));
  		("autoRefreshEvents" in vars) && (_iterateAutoRefresh(_removeListener$2) || _iterateAutoRefresh(_addListener$2, vars.autoRefreshEvents || "none"));
  	}

  	static scrollerProxy(target, vars) {
  		let t = _toArray$4(target)[0];
  		_isViewport(t) ? _proxies.unshift(_win$6, vars, _body$2, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
  	}

  	static matchMedia(vars) {
  		let mq, p;
  		for (p in vars) {
  			if (p === "all") {
  				_creatingMedia = p;
  				vars[p]();
  				_creatingMedia = 0;
  			} else {
  				mq = _win$6.matchMedia(p);
  				if (mq) {
  					_media.push(p, vars[p]);
  					mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
  				}
  			}
  		}
  		_onMediaChange();
  		return _media;
  	}

  }

  ScrollTrigger.version = "3.4.0";
  ScrollTrigger.saveStyles = targets => targets ? _toArray$4(targets).forEach(target => {
  	let i = _savedStyles.indexOf(target);
  	i >= 0 && _savedStyles.splice(i, 4);
  	_savedStyles.push(target, target.style.cssText, gsap$6.core.getCache(target), _creatingMedia);
  }) : _savedStyles;
  ScrollTrigger.revert = (soft, media) => _revertAll(!soft, media);
  ScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);
  ScrollTrigger.refresh = safe => safe ? _onResize() : _refreshAll(true);
  ScrollTrigger.update = _updateAll;
  ScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);
  ScrollTrigger.getScrollFunc = (element, horizontal) => _getScrollFunc(_toArray$4(element)[0], horizontal ? _horizontal : _vertical);
  ScrollTrigger.getById = id => _ids[id];
  ScrollTrigger.getAll = () => _triggers.slice(0);
  ScrollTrigger.isScrolling = () => !!_lastScrollTime;
  ScrollTrigger.addEventListener = (type, callback) => {
  	let a = _listeners[type] || (_listeners[type] = []);
  	~a.indexOf(callback) || a.push(callback);
  };
  ScrollTrigger.removeEventListener = (type, callback) => {
  	let a = _listeners[type],
  		i = a && a.indexOf(callback);
  	i >= 0 && a.splice(i, 1);
  };
  ScrollTrigger.batch = (targets, vars) => {
  	let result = [],
  		varsCopy = {},
  		interval = vars.interval || 0.016,
  		batchMax = vars.batchMax || 1e9,
  		proxyCallback = (type, callback) => {
  			let elements = [],
  				triggers = [],
  				delay = gsap$6.delayedCall(interval, () => {callback(elements, triggers); elements = []; triggers = [];}).pause();
  			return self => {
  				elements.length || delay.restart(true);
  				elements.push(self.trigger);
  				triggers.push(self);
  				batchMax <= elements.length && delay.progress(1);
  			};
  		},
  		p;
  	for (p in vars) {
  		varsCopy[p] = (p.substr(0, 2) === "on" && _isFunction$5(vars[p]) && p !== "onRefreshInit") ? proxyCallback(p, vars[p]) : vars[p];
  	}
  	if (_isFunction$5(batchMax)) {
  		batchMax = batchMax();
  		_addListener$2(ScrollTrigger, "refresh", () => batchMax = vars.batchMax());
  	}
  	_toArray$4(targets).forEach(target => {
  		let config = {};
  		for (p in varsCopy) {
  			config[p] = varsCopy[p];
  		}
  		config.trigger = target;
  		result.push(ScrollTrigger.create(config));
  	});
  	return result;
  };

  _getGSAP$5() && gsap$6.registerPlugin(ScrollTrigger);

  // Used in two objects below, hence declared out here.
  var baseStops = {
    stop0: '#4D4054',
    stop1: '#040509'
  };
  var state = {
    // General.
    width: null,
    height: null,
    tabletUp: 800,
    transform: {
      shape: null,
      scape: null,
      bottle: null,
      // all the animal transforms
      // are being added in `update`
      dataset: null
    },
    ctx: {
      scape: null,
      glassBottle: null,
      bottleText: null,
      bottleWave: null,
      chart: null,
      blackBox: null,
      globe: null
    },
    rough: {
      chart: null,
      globe: null,
      wave: null
    },
    // Tweens.
    tween: {
      wineScape: null,
      glassBottle: null,
      bottleText: null,
      bottleWave: null,
      lolliChart: null,
      lolliUpdate1: null,
      lolliUpdate2: null,
      lolliUpdate3: null,
      // blackbox/arrow tweens are being added in tween func.
      blackBox: null,
      cleanup: null,
      bottleEmpty: null,
      bottleTextOut: null,
      // animal tweens are being added in tween func.
      bottleFill: null,
      // bottle colour tweens are being added in tween func.
      bottleGrid: null,
      bottleGridColour: null,
      bottleGridSort: null,
      bottleGridOut: null,
      // dataset tweens are being added in tween func.
      globe: null,
      importance: null,
      importanceRemove: null,
      modelBottleIn: null,
      modelBottleOut: null,
      modelWaveInit: null
    },
    scape: {
      image: null,
      alpha: null,
      alphaTarget: 0.2
    },
    glassBottle: {
      bottleBox: null,
      bottleTop: null,
      // % of bottle's top position
      bottleLeft: null,
      // % of bottle's top position
      path: null,
      colour: null,
      alpha: 0
    },
    bottleText: {
      paths: null,
      maxLength: null,
      dashOffset: null,
      colour: null
    },
    bottleColour: {
      base: _objectSpread2({}, baseStops),
      good: {
        // stop0: '#88BFF2',
        // stop1: '#4D8ECA',
        stop0: '#98A5DA',
        stop1: '#5566aa',
        // dot: '#5566aa', // ezplan blue
        dot: '#1773C9' // original

      },
      bad: {
        stop0: '#CE6A8C',
        stop1: '#993355',
        // vinoez bordeaux
        // dot: '#E5A0BF', // original
        dot: 'rgba(229, 160, 191, 0.7)' // original light
        // dot: 'rgba(153, 51, 85, 0.4)', // transparent stop1

      }
    },
    bottleWave: {
      bottlePath: null,
      wavePoints: null,
      lift: null,
      liftTarget: null,
      r: null,
      n: 20,
      xWaveScale: null,
      waveLine: null,
      waveAlpha: null
    },
    lolli: {
      data: null,
      values: null,
      radiusTarget: null,
      area: null,
      x: null,
      y: null
    },
    blackBox: {
      box: null,
      boxDims: null,
      model: null,
      xOffset: null
    },
    animals: {
      data: null // box info for each animal added in `init`.

    },
    bottleGrid: {
      baseData: null,
      dataOrigin: null,
      dataTarget: null,
      dataSorted: null,
      dataOut: null,
      colour: {
        // initially base colours.
        good: _objectSpread2({}, baseStops),
        bad: _objectSpread2({}, baseStops)
      }
    },
    dataset: {
      info: null,
      box: null // all the column path data
      // are being added in `init`

    },
    globe: {
      data: null,
      scroll: {
        progress: null,
        direction: null
      }
    },
    stats: {
      data: null,
      links: null,
      current: [],
      alpha: {
        value: 1
      },
      colourDots: false,
      lr: false,
      // linear regression
      progress: {
        draw: 0,
        extend: 0,
        point: 0,
        logistic: 0
      },
      pointTickInfo: null
    },
    varImp: {
      data: null
    },
    model: {
      intercept: null,
      weights: null,
      values: null,
      ranges: null,
      probability: 0
    },
    modelBottle: {
      paths: null,
      maxLength: null,
      dashOffset: null,
      alpha: 0,
      points: false,
      info: [''],
      infoColour: '#777'
    },
    modelWave: {
      alpha: 0
    }
  };

  /*!
   * CustomWiggle 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  /* eslint-disable */

  let gsap$7, _coreInitted$7, createCustomEase,
  	_getGSAP$6 = () => gsap$7 || (typeof(window) !== "undefined" && (gsap$7 = window.gsap) && gsap$7.registerPlugin && gsap$7),
  	_eases = {
  		easeOut: "M0,1,C0.7,1,0.6,0,1,0",
  		easeInOut: "M0,0,C0.1,0,0.24,1,0.444,1,0.644,1,0.6,0,1,0",
  		anticipate: "M0,0,C0,0.222,0.024,0.386,0,0.4,0.18,0.455,0.65,0.646,0.7,0.67,0.9,0.76,1,0.846,1,1",
  		uniform: "M0,0,C0,0.95,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0"
  	},
  	_linearEase = p => p,
  	_initCore$6 = required => {
  		if (!_coreInitted$7) {
  			gsap$7 = _getGSAP$6();
  			createCustomEase = gsap$7 && gsap$7.parseEase("_CE");
  			if (createCustomEase) {
  				for (let p in _eases) {
  					_eases[p] = createCustomEase("", _eases[p]);
  				}
  				_coreInitted$7 = 1;
  				_create("wiggle").config = vars => typeof(vars) === "object" ? _create("", vars) : _create("wiggle(" + vars + ")", {wiggles:+vars});
  			} else {
  				required && console.warn("Please gsap.registerPlugin(CustomEase, CustomWiggle)");
  			}
  		}
  	},
  	_parseEase$1 = (ease, invertNonCustomEases) => {
  		if (typeof(ease) !== "function") {
  			ease = gsap$7.parseEase(ease) || createCustomEase("", ease);
  		}
  		return (ease.custom || !invertNonCustomEases) ? ease : p => 1 - ease(p);
  	},
  	_create = (id, vars) => {
  		if (!_coreInitted$7) {
  			_initCore$6(1);
  		}
  		vars = vars || {};
  		let wiggles = (vars.wiggles || 10) | 0,
  			inc = 1 / wiggles,
  			x = inc / 2,
  			anticipate = (vars.type === "anticipate"),
  			yEase = _eases[vars.type] || _eases.easeOut,
  			xEase = _linearEase,
  			rnd = 1000,
  			nextX, nextY, angle, handleX, handleY, easedX, y, path, i;
  		{
  			if (anticipate) { //the anticipate ease is actually applied on the x-axis (timing) and uses easeOut for amplitude.
  				xEase = yEase;
  				yEase = _eases.easeOut;
  			}
  			if (vars.timingEase) {
  				xEase = _parseEase$1(vars.timingEase);
  			}
  			if (vars.amplitudeEase) {
  				yEase = _parseEase$1(vars.amplitudeEase, true);
  			}
  			easedX = xEase(x);
  			y = anticipate ? -yEase(x) : yEase(x);
  			path = [0, 0, easedX / 4, 0, easedX / 2, y, easedX, y];

  			if (vars.type === "random") { //if we just select random values on the y-axis and plug them into the "normal" algorithm, since the control points are always straight horizontal, it creates a bit of a slowdown at each anchor which just didn't seem as desirable, so we switched to an algorithm that bends the control points to be more in line with their context.
  				path.length = 4;
  				nextX = xEase(inc);
  				nextY = Math.random() * 2 - 1;
  				for (i = 2; i < wiggles; i++) {
  					x = nextX;
  					y = nextY;
  					nextX = xEase(inc * i);
  					nextY = Math.random() * 2 - 1;
  					angle = Math.atan2(nextY - path[path.length - 3], nextX - path[path.length - 4]);
  					handleX = Math.cos(angle) * inc;
  					handleY = Math.sin(angle) * inc;
  					path.push(x - handleX, y - handleY, x, y, x + handleX, y + handleY);
  				}
  				path.push(nextX, 0, 1, 0);
  			} else {
  				for (i = 1; i < wiggles; i++) {
  					path.push(xEase(x + inc / 2), y);
  					x += inc;
  					y = ((y > 0) ? -1 : 1) * (yEase(i * inc));
  					easedX = xEase(x);
  					path.push(xEase(x - inc / 2), y, easedX, y);
  				}
  				path.push(xEase(x + inc / 4), y, xEase(x + inc / 4), 0, 1, 0);
  			}
  			i = path.length;
  			while (--i > -1) {
  				path[i] = ~~(path[i] * rnd) / rnd; //round values to avoid odd strings for super tiny values
  			}
  			path[2] = "C" + path[2];
  			return createCustomEase(id, "M" + path.join(","));
  		}
  	};

  class CustomWiggle {

  	constructor(id, vars) {
  		this.ease = _create(id, vars);
  	}

  	static create(id, vars) {
  		return _create(id, vars);
  	}

  	static register(core) {
  		gsap$7 = core;
  		_initCore$6();
  	}

  }

  _getGSAP$6() && gsap$7.registerPlugin(CustomWiggle);

  CustomWiggle.version = "3.4.0";

  /*!
   * CustomEase 3.4.0
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  let gsap$8, _coreInitted$8,
  	_getGSAP$7 = () => gsap$8 || (typeof(window) !== "undefined" && (gsap$8 = window.gsap) && gsap$8.registerPlugin && gsap$8),
  	_initCore$7 = () => {
  		gsap$8 = _getGSAP$7();
  		if (gsap$8) {
  			gsap$8.registerEase("_CE", CustomEase.create);
  			_coreInitted$8 = 1;
  		} else {
  			console.warn("Please gsap.registerPlugin(CustomEase)");
  		}
  	},
  	_bigNum$5 = 1e20,
  	_round$5 = value => ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000,
  	_numExp$4 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  	_needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,
  	_findMinimum = values => {
  		let l = values.length,
  			min = _bigNum$5,
  			i;
  		for (i = 1; i < l; i += 6) {
  			if (+values[i] < min) {
  				min = +values[i];
  			}
  		}
  		return min;
  	},
  	//takes all the points and translates/scales them so that the x starts at 0 and ends at 1.
  	_normalize = (values, height, originY) => {
  		if (!originY && originY !== 0) {
  			originY = Math.max(+values[values.length-1], +values[1]);
  		}
  		let tx = +values[0] * -1,
  			ty = -originY,
  			l = values.length,
  			sx = 1 / (+values[l - 2] + tx),
  			sy = -height || ((Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0])) ? _findMinimum(values) + ty : +values[l - 1] + ty),
  			i;
  		if (sy) { //typically y ends at 1 (so that the end values are reached)
  			sy = 1 / sy;
  		} else { //in case the ease returns to its beginning value, scale everything proportionally
  			sy = -sx;
  		}
  		for (i = 0; i < l; i += 2) {
  			values[i] = (+values[i] + tx) * sx;
  			values[i + 1] = (+values[i + 1] + ty) * sy;
  		}
  	},
  	//note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js
  	_bezierToPoints = function (x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  		let x12 = (x1 + x2) / 2,
  			y12 = (y1 + y2) / 2,
  			x23 = (x2 + x3) / 2,
  			y23 = (y2 + y3) / 2,
  			x34 = (x3 + x4) / 2,
  			y34 = (y3 + y4) / 2,
  			x123 = (x12 + x23) / 2,
  			y123 = (y12 + y23) / 2,
  			x234 = (x23 + x34) / 2,
  			y234 = (y23 + y34) / 2,
  			x1234 = (x123 + x234) / 2,
  			y1234 = (y123 + y234) / 2,
  			dx = x4 - x1,
  			dy = y4 - y1,
  			d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),
  			d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),
  			length;
  		if (!points) {
  			points = [{x: x1, y: y1}, {x: x4, y: y4}];
  			index = 1;
  		}
  		points.splice(index || points.length - 1, 0, {x: x1234, y: y1234});
  		if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
  			length = points.length;
  			_bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
  			_bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
  		}
  		return points;
  	};

  class CustomEase {

  	constructor(id, data, config) {
  		if (!_coreInitted$8) {
  			_initCore$7();
  		}
  		this.id = id;
  		{
  			this.setData(data, config);
  		}
  	}

  	setData(data, config) {
  		config = config || {};
  		data = data || "0,0,1,1";
  		let values = data.match(_numExp$4),
  			closest = 1,
  			points = [],
  			lookup = [],
  			precision = config.precision || 1,
  			fast = (precision <= 1),
  			l, a1, a2, i, inc, j, point, prevPoint, p;
  		this.data = data;
  		if (_needsParsingExp.test(data) || (~data.indexOf("M") && data.indexOf("C") < 0)) {
  			values = stringToRawPath$1(data)[0];
  		}
  		l = values.length;
  		if (l === 4) {
  			values.unshift(0, 0);
  			values.push(1, 1);
  			l = 8;
  		} else if ((l - 2) % 6) {
  			throw "Invalid CustomEase";
  		}
  		if (+values[0] !== 0 || +values[l - 2] !== 1) {
  			_normalize(values, config.height, config.originY);
  		}
  		this.segment = values;
  		for (i = 2; i < l; i += 6) {
  			a1 = {x: +values[i - 2], y: +values[i - 1]};
  			a2 = {x: +values[i + 4], y: +values[i + 5]};
  			points.push(a1, a2);
  			_bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);
  		}
  		l = points.length;
  		for (i = 0; i < l; i++) {
  			point = points[i];
  			prevPoint = points[i - 1] || point;
  			if (point.x > prevPoint.x || (prevPoint.y !== point.y && prevPoint.x === point.x) || point === prevPoint) { //if a point goes BACKWARD in time or is a duplicate, just drop it.
  				prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)
  				prevPoint.cy = point.y - prevPoint.y;
  				prevPoint.n = point;
  				prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)
  				if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) { //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.
  					fast = 0;
  				}
  				if (prevPoint.cx < closest) {
  					if (!prevPoint.cx) {
  						prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)
  						if (i === l - 1) { //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.
  							prevPoint.x -= 0.001;
  							closest = Math.min(closest, 0.001);
  							fast = 0;
  						}
  					} else {
  						closest = prevPoint.cx;
  					}
  				}
  			} else {
  				points.splice(i--, 1);
  				l--;
  			}
  		}
  		l = (1 / closest + 1) | 0;
  		inc = 1 / l;
  		j = 0;
  		point = points[0];
  		if (fast) {
  			for (i = 0; i < l; i++) { //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).
  				p = i * inc;
  				if (point.nx < p) {
  					point = points[++j];
  				}
  				a1 = point.y + ((p - point.x) / point.cx) * point.cy;
  				lookup[i] = {x: p, cx: inc, y: a1, cy: 0, nx: 9};
  				if (i) {
  					lookup[i - 1].cy = a1 - lookup[i - 1].y;
  				}
  			}
  			lookup[l - 1].cy = points[points.length - 1].y - a1;
  		} else { //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.
  			for (i = 0; i < l; i++) { //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]
  				if (point.nx < i * inc) {
  					point = points[++j];
  				}
  				lookup[i] = point;
  			}

  			if (j < points.length - 1) {
  				lookup[i-1] = points[points.length-2];
  			}
  		}
  		//this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.

  		this.ease = p => {
  			let point = lookup[(p * l) | 0] || lookup[l - 1];
  			if (point.nx < p) {
  				point = point.n;
  			}
  			return point.y + ((p - point.x) / point.cx) * point.cy;
  		};

  		this.ease.custom = this;

  		if (this.id) {
  			gsap$8.registerEase(this.id, this.ease);
  		}

  		return this;
  	}

  	getSVGData(config) {
  		return CustomEase.getSVGData(this, config);
  	}

  	static create(id, data, config) {
  		return (new CustomEase(id, data, config)).ease;
  	}

  	static register(core) {
  		gsap$8 = core;
  		_initCore$7();
  	}

  	static get(id) {
  		return gsap$8.parseEase(id);
  	}

  	static getSVGData(ease, config) {
  		config = config || {};
  		let width = config.width || 100,
  			height = config.height || 100,
  			x = config.x || 0,
  			y = (config.y || 0) + height,
  			e = gsap$8.utils.toArray(config.path)[0],
  			a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;
  		if (config.invert) {
  			height = -height;
  			y = 0;
  		}
  		if (typeof(ease) === "string") {
  			ease = gsap$8.parseEase(ease);
  		}
  		if (ease.custom) {
  			ease = ease.custom;
  		}
  		if (ease instanceof CustomEase) {
  			a = rawPathToString$1(transformRawPath([ease.segment], width, 0, 0, -height, x, y));
  		} else {
  			a = [x, y];
  			precision = Math.max(5, (config.precision || 1) * 200);
  			inc = 1 / precision;
  			precision += 2;
  			threshold = 5 / precision;
  			prevX = _round$5(x + inc * width);
  			prevY = _round$5(y + ease(inc) * -height);
  			slope = (prevY - y) / (prevX - x);
  			for (i = 2; i < precision; i++) {
  				tx = _round$5(x + i * inc * width);
  				ty = _round$5(y + ease(i * inc) * -height);
  				if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) { //only add points when the slope changes beyond the threshold
  					a.push(prevX, prevY);
  					slope = (ty - prevY) / (tx - prevX);
  				}
  				prevX = tx;
  				prevY = ty;
  			}
  			a = "M" + a.join(",");
  		}
  		if (e) {
  			e.setAttribute("d", a);
  		}
  		return a;
  	}

  }

  _getGSAP$7() && gsap$8.registerPlugin(CustomEase);

  CustomEase.version = "3.4.0";

  function initRange(domain, range) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.range(domain); break;
      default: this.range(range).domain(domain); break;
    }
    return this;
  }

  var array = Array.prototype;

  var map$1 = array.map;
  var slice = array.slice;

  var implicit = {name: "implicit"};

  function ordinal() {
    var index = map(),
        domain = [],
        range = [],
        unknown = implicit;

    function scale(d) {
      var key = d + "", i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = map();
      var i = -1, n = _.length, d, key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), scale) : range.slice();
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function() {
      return ordinal(domain, range).unknown(unknown);
    };

    initRange.apply(scale, arguments);

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range$1 = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range$1[1] < range$1[0],
          start = range$1[reverse - 0],
          stop = range$1[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = range(n).map(function(i) { return start + step * i; });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function(_) {
      return arguments.length ? (range$1 = [+_[0], +_[1]], rescale()) : range$1.slice();
    };

    scale.rangeRound = function(_) {
      return range$1 = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function() {
      return bandwidth;
    };

    scale.step = function() {
      return step;
    };

    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };

    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };

    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };

    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function() {
      return band(domain(), range$1)
          .round(round)
          .paddingInner(paddingInner)
          .paddingOuter(paddingOuter)
          .align(align);
    };

    return initRange.apply(rescale(), arguments);
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function() {
      return pointish(copy());
    };

    return scale;
  }

  function point$1() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  function constant$2(x) {
    return function() {
      return x;
    };
  }

  function number$1(x) {
    return +x;
  }

  var unit = [0, 1];

  function identity$1(x) {
    return x;
  }

  function normalize$1(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constant$2(isNaN(b) ? NaN : 0.5);
  }

  function clamper(domain) {
    var a = domain[0], b = domain[domain.length - 1], t;
    if (a > b) t = a, a = b, b = t;
    return function(x) { return Math.max(a, Math.min(b, x)); };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize$1(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize$1(d0, d1), r0 = interpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = normalize$1(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function transformer() {
    var domain = unit,
        range = unit,
        interpolate = interpolateValue,
        transform,
        untransform,
        unknown,
        clamp = identity$1,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }

    scale.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = map$1.call(_, number$1), clamp === identity$1 || (clamp = clamper(domain)), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = slice.call(_), interpolate = interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? clamper(domain) : identity$1, scale) : clamp !== identity$1;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }

  function continuous(transform, untransform) {
    return transformer()(transform, untransform);
  }

  function formatDecimal(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": formatDecimal,
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$2(x) {
    return x;
  }

  var map$2 = Array.prototype.map,
      prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$2 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$2 : formatNumerals(map$2.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "-" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    minus: "-"
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain(),
          i0 = 0,
          i1 = d.length - 1,
          start = d[i0],
          stop = d[i1],
          step;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }

      step = tickIncrement(start, stop, count);

      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }

      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear$1() {
    var scale = continuous(identity$1, identity$1);

    scale.copy = function() {
      return copy(scale, linear$1());
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  /* eslint-disable no-useless-escape */

  function prettyLabel(string) {
    var capitals = string.charAt(0).toUpperCase() + string.slice(1);
    return capitals.replace(/_/g, ' ');
  }

  function isSelection(el) {
    if (typeof el === 'string') return false;
    if (el instanceof selection) return true;
    return false;
  }
  /**
   * Get the bounding box of either a DOM element, a D3 selection
   *  or a path string. Either `el` or `path` needs to be falsey.
   * @param { node|selection } el either a DOM node or a D3 selection
   * @param { string } path an svg path
   * @return An SVG rect with (most importantly) width and height
   */


  function getBox(el, path) {
    var box;

    if (el) {
      var sel = isSelection(el) ? el : select(el);
      box = sel.node().getBBox();
    } else if (path) {
      var domPath = select('body').append('svg').attr('class', 'svg-temp').append('path').attr('d', path);
      box = domPath.node().getBBox();
      domPath.remove();
    } else {
      throw Error('Either el or path must be defined');
    }

    return box;
  } // Update functions.


  function resizeCanvas(canvas, width, height) {
    var context = canvas.getContext('2d'); // Give each device pixel an element and drawing surface pixel.
    // This should make it bigger for retina displays for example.

    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio; // Scale only the element's size down to the given width on the site.

    canvas.style.width = "".concat(width, "px");
    canvas.style.height = "".concat(height, "px"); // Scale the drawing surface (up).

    context.scale(window.devicePixelRatio, window.devicePixelRatio);
  }
  /**
   * This fn calculates the translate and scale values for the object based on the parent visual's
   * dimensions. `fit` decides how big in relation to width or height it should be (width: 1 would
   * be full width). Note, it can only fit towards one measure as skewing is not worked in.
   * `pos` decides which x, y place it should have. Leave this empty if you want to centre the image.
   * @param { SVGRect|Object } object The object's bounding box - at least with width and height. Required.
   * @param { Object } fit  { width: 0-1, height: 0-1 } The percentage of the width or height the
   *                        object should fit with. One must be 0! Required.
   * @param { Object } pos  { x: 0-1, y: 0-1 } The percentage of the full width or height
   *                        x or y should be at. 1 represents the centre. Optional.
   * @returns { Object }    { x, y, scale } The translate and scale values to be used for positioning.
   */


  function getTransform(object, fit, nudge) {
    if (fit.width !== 0 && fit.height !== 0) throw Error('One fit value must be 0'); // Get the parent visual.

    var frame = document.querySelector('#canvas-main-container');
    var visual = {
      width: frame.clientWidth,
      height: frame.clientHeight
    }; // Establish the object scale. fit.width and fit.height decide the scale
    // in relation to either the height or the width. You can't have both,
    // becasue we don't skew. These two terms ↓ don't become a sum, but one
    // will be 0 when the other one is not.

    var scale = visual.width / object.width * fit.width + visual.height / object.height * fit.height; // Establish the object's position. The default value is the centre:

    var position = {
      x: visual.width / 2 - object.width * scale / 2,
      y: visual.height / 2 - object.height * scale / 2
    }; // If `nudge` is defined, then `nudge.x` and `nudge.y` are both
    // expressed  as % of width and/or height. 1 would be full width/height,
    // 0.5 would be the (default) centre and 0.25 half the centre (25% width).

    if (nudge && nudge.x) position.x *= nudge.x * 2; // *2 as the default position

    if (nudge && nudge.y) position.y *= nudge.y * 2; // is the centre (see above).
    // Nice all the values up.

    return {
      x: Math.round(position.x),
      y: Math.round(position.y),
      scale: Math.round(scale * 100) / 100
    };
  }
  /**
   * Splits the path at the M commands.
   * Much more readable than reduce 🥂.
   * @param { String } path
   * @returns { Array } an array of paths
   */


  function splitPath(path) {
    return path.split('M').filter(function (d) {
      return d;
    }).map(function (d) {
      return "M".concat(d);
    });
  }

  function getPathDims(pathData) {
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    var domPath = select('#stage-group').append('path').attr('class', 'remove').attr('d', pathData);
    var dims = domPath.node().getBBox();
    var pathDims = {
      x: Math.round(dims.x),
      y: Math.round(dims.y),
      width: Math.round(dims.width),
      height: Math.round(dims.height),
      length: Math.round(path.getTotalLength() || 0)
    };
    domPath.remove();
    return pathDims;
  }

  function getPathData(path) {
    var splitPaths = splitPath(path);
    var paths = splitPaths.map(function (p) {
      return new Path2D(p);
    });
    var dims = splitPaths.map(getPathDims);
    var length = max(dims, function (d) {
      return d.length;
    });
    var offset = length;
    return {
      paths: paths,
      dims: dims,
      length: length,
      offset: offset
    };
  }
  /**
   * Drwa canvas arrows. From:
   * (https://riptutorial.com/html5-canvas/example/18138/cubic---quadratic-bezier-curve-with-arrowheads)
   * @param { objecr } ctx Canvas context to draw on.
   * @param { object } p0 {x, y} control point - start
   * @param { object } p1 {x, y} control point - control quadratic
   * @param { object } p2 {x, y} control point - end
   * @param { object } p3 {x, y} control point - control cubic if defined
   * @param { number } arrowLength Length of arrow head
   * @param { boolean } hasStartArrow Add start arrow
   * @param { boolean } hasEndArrow Add end arrow
   */


  function bezWithArrowheads(ctx, p0, p1, p2, p3, arrowLength, hasStartArrow, hasEndArrow) {
    var x;
    var y;
    var norm;
    var ex;
    var ey;

    function pointsToNormalisedVec(p, pp) {
      norm.y = pp.x - p.x;
      norm.x = -(pp.y - p.y);
      var len = Math.sqrt(norm.x * norm.x + norm.y * norm.y);
      norm.x /= len;
      norm.y /= len;
      return norm;
    }

    var arrowWidth = arrowLength / 2;
    norm = {}; // defaults to true for both arrows if arguments not included

    hasStartArrow = hasStartArrow === undefined || hasStartArrow === null ? true : hasStartArrow;
    hasEndArrow = hasEndArrow === undefined || hasEndArrow === null ? true : hasEndArrow;
    ctx.beginPath();
    ctx.moveTo(p0.x, p0.y);

    if (p3 === undefined) {
      ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
      ex = p2.x; // get end point

      ey = p2.y;
      norm = pointsToNormalisedVec(p1, p2);
    } else {
      ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      ex = p3.x; // get end point

      ey = p3.y;
      norm = pointsToNormalisedVec(p2, p3);
    }

    if (hasEndArrow) {
      x = arrowWidth * norm.x + arrowLength * -norm.y;
      y = arrowWidth * norm.y + arrowLength * norm.x;
      ctx.moveTo(ex + x, ey + y);
      ctx.lineTo(ex, ey);
      x = arrowWidth * -norm.x + arrowLength * -norm.y;
      y = arrowWidth * -norm.y + arrowLength * norm.x;
      ctx.lineTo(ex + x, ey + y);
    }

    if (hasStartArrow) {
      norm = pointsToNormalisedVec(p0, p1);
      x = arrowWidth * norm.x - arrowLength * -norm.y;
      y = arrowWidth * norm.y - arrowLength * norm.x;
      ctx.moveTo(p0.x + x, p0.y + y);
      ctx.lineTo(p0.x, p0.y);
      x = arrowWidth * -norm.x - arrowLength * -norm.y;
      y = arrowWidth * -norm.y - arrowLength * norm.x;
      ctx.lineTo(p0.x + x, p0.y + y);
    }

    ctx.stroke();
  }

  function getLinearScale(variable) {
    return linear$1().domain(extent(state.stats.data, function (d) {
      return d[variable];
    }));
  }
  /**
   * Calculate Euclidean distance between two points.
   * @param {Array<number>} left First N-dimensional point.
   * @param {Array<number>} right Second N-dimensional point.
   * @returns {number} Distance.
   */


  function euclideanDistance(left, right) {
    var sum = 0;

    for (var i = 0; i < left.length; i++) {
      var diff = left[i] - right[i];
      sum += diff * diff;
    }

    return Math.sqrt(sum);
  }


  function getGradient(stops) {
    var gradient = state.ctx.bottleWave.createLinearGradient(0, state.glassBottle.bottleBox.height / 2, state.glassBottle.bottleBox.width, state.glassBottle.bottleBox.height / 2);
    gradient.addColorStop(0, stops.stop0);
    gradient.addColorStop(0.7, stops.stop1);
    return gradient;
  }

  function clear(ctx) {
    ctx.clearRect(0, 0, state.width, state.height);
  }

  function isMobile() {
    return window.innerWidth < state.tabletUp;
  }

  /* eslint-disable no-multi-assign */
  state.lolli.area = {
    top: undefined,
    right: undefined,
    bottom: undefined,
    left: undefined,
    height: undefined,
    width: undefined
  }; // Utils.

  function setDimensions() {
    // Set the lolli area.
    var bottle = state.glassBottle; // Just for shortness.
    // Horizontal dims.

    state.lolli.area.left = Math.floor(bottle.bottleBox.width * 1.05);
    state.lolli.area.width = Math.floor(state.width / state.transform.bottle.scale * bottle.bottleLeft + bottle.bottleBox.width);
    state.lolli.area.right = Math.floor(state.lolli.area.left + state.lolli.area.width); // Vertical dims.

    state.lolli.area.top = Math.floor(bottle.bottleBox.height * 0.5);
    state.lolli.area.bottom = Math.floor(bottle.bottleBox.height * 0.9);
    state.lolli.area.height = Math.floor(state.lolli.area.bottom - state.lolli.area.top); // Set the lolli radius' target value.

    state.lolli.radiusTarget = 5 / state.transform.bottle.scale; // Set the lolly scales.

    state.lolli.x = linear$1([0, 1], [state.lolli.area.left, state.lolli.area.right]);
    state.lolli.y = point$1().domain(state.lolli.keys).range([state.lolli.area.top, state.lolli.area.bottom]);
  }

  var colScale = linear$1().range(['#CE6A8C', '#1773C9']); // Canvas draw function.

  function drawLolliChart(ctx, t) {
    var rough = state.rough.chart;
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    state.lolli.keys.forEach(function (d, i) {
      var datapoint = state.lolli.data[d];
      var xValue = datapoint.value;
      var length = datapoint.text.length;
      var offset = datapoint.text.offset;
      var paths = datapoint.text.paths;
      ctx.save();

      if (d === 'quality') {
        ctx.strokeStyle = ctx.fillStyle = colScale(xValue);
      } else {
        ctx.strokeStyle = ctx.fillStyle = 'black';
      } // Line.


      ctx.beginPath();
      rough.line(state.lolli.x(0), state.lolli.y(d), state.lolli.x(xValue), state.lolli.y(d), {
        seed: i + 1,
        roughness: 0.5
      });
      ctx.stroke(); // Circle.

      ctx.beginPath();
      ctx.arc(state.lolli.x(xValue), state.lolli.y(d), datapoint.radius, 0, 2 * Math.PI);
      ctx.fill(); // Text.
      // ctx.strokeStyle = ctx.fillStyle = 'black';

      ctx.translate(state.lolli.x(0), state.lolli.y(d) + 2);
      ctx.lineWidth = 0.5;
      ctx.setLineDash([length - offset, offset]);
      paths.forEach(function (path) {
        return ctx.stroke(path);
      });
      ctx.restore();
    });
    ctx.restore();
  }

  function renderLolliChart() {
    requestAnimationFrame(function () {
      return drawLolliChart(state.ctx.chart, state.transform.bottle);
    });
  } // As tweenLolliUpdate and blackbox are set later, it seems to change
  // all initial values (.values[0]) as set by this tweenLolliChart. 🤷‍♂️


  function forceInitialValues() {
    Object.keys(state.lolli.data).forEach(function (d) {
      var datapoint = state.lolli.data[d];
      datapoint.value = datapoint.values[0];
      datapoint.radius = 0;
      datapoint.text.offset = datapoint.text.length;
    });
  }

  function defineTweenLolliChart() {
    setDimensions(); // Things to tween.

    var tl = gsapWithCSS.timeline({
      onStart: forceInitialValues,
      onUpdate: renderLolliChart
    }); // Loop through all lolli-data (which is an object).

    Object.keys(state.lolli.data).forEach(function (d) {
      // Datapoint to tween around with.
      var datapoint = state.lolli.data[d]; // Set up the tweens.

      var valueTween = gsapWithCSS.fromTo(datapoint, {
        value: datapoint.values[0]
      }, {
        value: datapoint.values[1]
      });
      var radiusTween = gsapWithCSS.fromTo(datapoint, {
        radius: 0
      }, {
        radius: state.lolli.radiusTarget
      });
      var offsetTween = gsapWithCSS.fromTo(datapoint.text, {
        offset: datapoint.text.length
      }, {
        offset: 0
      }); // Add the tweens to the timeline.
      // "<" start or ">" end of previous tween.

      tl.add(valueTween, '>').add(radiusTween, '<').add(offsetTween, '>');
    });
    return tl;
  }

  function tweenLolliChart() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('lolliChart');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.lolliChart) state.tween.lolliChart.kill();
    state.tween.lolliChart = defineTweenLolliChart();
    state.tween.lolliChart.totalProgress(progress);
  }

  var lodash_isequal = createCommonjsModule(function (module, exports) {
  /**
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright JS Foundation and other contributors <https://js.foundation/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  module.exports = isEqual;
  });

  /**
   * Calculates the Logistic Regression probability for the
   * given values based on the given model parameters.
   * @param { map } values map of the values
   * @param { map } weights map of the weights
   * @param { number } intercept the model intercept
   */

  function getProbability(values, weights, intercept) {
    var check = lodash_isequal(values.keys(), weights.keys());
    if (!check) throw Error('values and weights are not equal.');
    var logOdds = intercept;
    values.keys().forEach(function (variable) {
      logOdds += values.get(variable) * weights.get(variable);
    });
    var odds = Math.exp(logOdds);
    var prob = odds / (1 + odds);
    return prob;
  }

  /* eslint-disable prefer-destructuring */

  var intercept = 0;
  var weights = map();
  weights.set('acids', -3);
  weights.set('sugars', 1.5);
  weights.set('alcohol', 3); // The model values.

  var values = map();

  function updateValues() {
    values.set('acids', state.lolli.data.acids.value);
    values.set('sugars', state.lolli.data.sugars.value);
    values.set('alcohol', state.lolli.data.alcohol.value);
  }

  function slide() {
    var name = this.name,
        value = this.value; // Set input values.

    state.lolli.data[name].value = +value;
    state.lolli.data[name].values[3] = +value; // Set quality values.

    updateValues();
    var quality = getProbability(values, weights, intercept);
    state.lolli.data.quality.value = +quality;
    state.lolli.data.quality.values[3] = quality; // render chart

    renderLolliChart();
  }

  function setupLolliSlider() {
    select('#slider-tool').selectAll('input').each(function () {
      // Set initial value.
      var name = this.name;
      this.value = state.lolli.data[name].values[3];
    }).on('input', slide);
  }

  function nopropagation() {
    event.stopImmediatePropagation();
  }

  function noevent() {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  function nodrag(view) {
    var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", noevent, true);
    if ("onselectstart" in root) {
      selection.on("selectstart.drag", noevent, true);
    } else {
      root.__noselect = root.style.MozUserSelect;
      root.style.MozUserSelect = "none";
    }
  }

  function yesdrag(view, noclick) {
    var root = view.document.documentElement,
        selection = select(view).on("dragstart.drag", null);
    if (noclick) {
      selection.on("click.drag", noevent, true);
      setTimeout(function() { selection.on("click.drag", null); }, 0);
    }
    if ("onselectstart" in root) {
      selection.on("selectstart.drag", null);
    } else {
      root.style.MozUserSelect = root.__noselect;
      delete root.__noselect;
    }
  }

  function constant$3(x) {
    return function() {
      return x;
    };
  }

  function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
    this.target = target;
    this.type = type;
    this.subject = subject;
    this.identifier = id;
    this.active = active;
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this._ = dispatch;
  }

  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // Ignore right-click, since that should open the context menu.
  function defaultFilter() {
    return !event.ctrlKey && !event.button;
  }

  function defaultContainer() {
    return this.parentNode;
  }

  function defaultSubject(d) {
    return d == null ? {x: event.x, y: event.y} : d;
  }

  function defaultTouchable() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
  }

  function drag() {
    var filter = defaultFilter,
        container = defaultContainer,
        subject = defaultSubject,
        touchable = defaultTouchable,
        gestures = {},
        listeners = dispatch("start", "drag", "end"),
        active = 0,
        mousedownx,
        mousedowny,
        mousemoving,
        touchending,
        clickDistance2 = 0;

    function drag(selection) {
      selection
          .on("mousedown.drag", mousedowned)
        .filter(touchable)
          .on("touchstart.drag", touchstarted)
          .on("touchmove.drag", touchmoved)
          .on("touchend.drag touchcancel.drag", touchended)
          .style("touch-action", "none")
          .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }

    function mousedowned() {
      if (touchending || !filter.apply(this, arguments)) return;
      var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
      if (!gesture) return;
      select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
      nodrag(event.view);
      nopropagation();
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start");
    }

    function mousemoved() {
      noevent();
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag");
    }

    function mouseupped() {
      select(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent();
      gestures.mouse("end");
    }

    function touchstarted() {
      if (!filter.apply(this, arguments)) return;
      var touches = event.changedTouches,
          c = container.apply(this, arguments),
          n = touches.length, i, gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
          nopropagation();
          gesture("start");
        }
      }
    }

    function touchmoved() {
      var touches = event.changedTouches,
          n = touches.length, i, gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          noevent();
          gesture("drag");
        }
      }
    }

    function touchended() {
      var touches = event.changedTouches,
          n = touches.length, i, gesture;

      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          nopropagation();
          gesture("end");
        }
      }
    }

    function beforestart(id, container, point, that, args) {
      var p = point(container, id), s, dx, dy,
          sublisteners = listeners.copy();

      if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
        if ((event.subject = s = subject.apply(that, args)) == null) return false;
        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;
        return true;
      })) return;

      return function gesture(type) {
        var p0 = p, n;
        switch (type) {
          case "start": gestures[id] = gesture, n = active++; break;
          case "end": delete gestures[id], --active; // nobreak
          case "drag": p = point(container, id), n = active; break;
        }
        customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
      };
    }

    drag.filter = function(_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$3(!!_), drag) : filter;
    };

    drag.container = function(_) {
      return arguments.length ? (container = typeof _ === "function" ? _ : constant$3(_), drag) : container;
    };

    drag.subject = function(_) {
      return arguments.length ? (subject = typeof _ === "function" ? _ : constant$3(_), drag) : subject;
    };

    drag.touchable = function(_) {
      return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$3(!!_), drag) : touchable;
    };

    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };

    drag.clickDistance = function(_) {
      return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
    };

    return drag;
  }

  var pi = Math.PI,
      tau = 2 * pi,
      epsilon = 1e-6,
      tauEpsilon = tau - epsilon;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path;
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau + tau;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  function constant$4(x) {
    return function constant() {
      return x;
    };
  }

  function Linear(context) {
    this._context = context;
  }

  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; // proceed
        default: this._context.lineTo(x, y); break;
      }
    }
  };

  function curveLinear(context) {
    return new Linear(context);
  }

  function x$1(p) {
    return p[0];
  }

  function y$1(p) {
    return p[1];
  }

  function line() {
    var x = x$1,
        y = y$1,
        defined = constant$4(true),
        context = null,
        curve = curveLinear,
        output = null;

    function line(data) {
      var i,
          n = data.length,
          d,
          defined0 = false,
          buffer;

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x(d, i, data), +y(d, i, data));
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    line.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), line) : x;
    };

    line.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), line) : y;
    };

    line.defined = function(_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), line) : defined;
    };

    line.curve = function(_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };

    line.context = function(_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };

    return line;
  }

  function point$2(that, x, y) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x) / 6,
      (that._y0 + 4 * that._y1 + y) / 6
    );
  }

  function Basis(context) {
    this._context = context;
  }

  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3: point$2(this, this._x1, this._y1); // proceed
        case 2: this._context.lineTo(this._x1, this._y1); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
        default: point$2(this, x, y); break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  function curveBasis(context) {
    return new Basis(context);
  }

  // moves a variable value across a defined threshold.
  // This info (and a good/bad/neutral colour) will be
  // picked up by the marker draw function to add the info text.

  var info = [{
    variable: 'alcohol',
    operator: '>',
    threshold: 13,
    info: ['our model likes alcohol!'],
    infoColour: state.bottleColour.good.stop1
  }, {
    variable: 'volatile_acidity',
    operator: '>',
    threshold: 0.9,
    info: ['careful, your wine might', 'get too acid-reach'],
    infoColour: state.bottleColour.bad.stop1
  }, {
    variable: 'sulphates',
    operator: '<',
    threshold: 0.5,
    info: [''],
    infoColour: state.bottleColour.bad.stop1
  }, {
    variable: 'density',
    operator: '',
    threshold: null,
    info: [''],
    infoColour: ''
  }, {
    variable: 'citric_acid',
    operator: '>',
    threshold: 0.35,
    info: [''],
    infoColour: state.bottleColour.good.stop1
  }, {
    variable: 'chlorides',
    operator: '>',
    threshold: 0.1,
    info: ["don't oversalt it"],
    infoColour: state.bottleColour.bad.stop1
  }, {
    variable: 'total_sulfur_dioxide',
    operator: '',
    threshold: null,
    info: [''],
    infoColour: ''
  }, {
    variable: 'fixed_acidity',
    operator: '>',
    threshold: 8.5,
    info: [''],
    infoColour: state.bottleColour.bad.stop1
  }, {
    variable: 'ph',
    operator: '',
    threshold: null,
    info: [''],
    infoColour: ''
  }, {
    variable: 'residual_sugar',
    operator: '>',
    threshold: 3.8,
    info: ['getting on the sweater', 'side for a red wine now'],
    infoColour: '#777'
  }, {
    variable: 'free_sulfur_dioxide',
    operator: '',
    threshold: null,
    info: [''],
    infoColour: ''
  }];
  var infoMap = map(info, function (d) {
    return d.variable;
  });

  function getConditional(value, operator, threshold) {
    if (operator === '' || !operator) return false;
    if (operator === '>') return value > threshold;
    if (operator === '<') return value < threshold;
  }
  /**
   * Return info for that variable  based on the given value.
   * @param { string } variable property at question
   * @param { number } value the current value
   */


  function setPropertyInfo(variable, value) {
    state.modelBottle.info = [''];
    state.modelBottle.infoColour = '';
    var current = infoMap.get(variable);
    var conditional = getConditional(value, current.operator, current.threshold);

    if (conditional) {
      state.modelBottle.info = current.info;
      state.modelBottle.infoColour = current.infoColour;
    }
  }

  /* eslint-disable no-use-before-define */
  var gradient; // Utils.

  /**
   * Calculate wave point coordinates.
   * @param { Number } r the base circle radius
   * @param { Number } alpha circle rotation delay
   * @param { Number } beta circle rotation speed
   * @param { Number } x0 initial x position
   * @param { Number } y0 initial y position
   * @param { Number } t time
   * @return { Array } wave point coordinates
   */

  function getWavePoints(r, alpha, beta, x0, y0, t) {
    var arg = alpha * x0 + beta * t;
    var x = x0 + r * Math.cos(arg);
    var y = y0 + r * Math.sin(arg);
    return [x, y];
  }
  /**
   * Makes the wave points and draws the wine.
   * @param { Number } time time ideally at each tick.
   * @returns { Array } 2d array of x, y coordinates.
   */


  function makeWave(time) {
    // 1) We get an array of n wave points and save it in state
    // for the draw function to feed from.
    state.bottleWave.wavePoints = range(state.bottleWave.n).map(function (d, i) {
      // For each point (indexed from 0 to n), we add
      // a few parameters. x0 and y0 decide the position.
      var x0 = state.bottleWave.xWaveScale(d);
      var y0 = (1 - state.bottleWave.lift) * state.glassBottle.bottleBox.height; // The main point generation function, which sets x and y
      // based on the time passed in.

      var xy = getWavePoints(state.bottleWave.r, state.bottleWave.waveAlpha, 1.5, x0, y0, time * 5); // The first and the last point are pinned to the sides.

      if (i === 0) xy[0] = state.glassBottle.bottleBox.x;
      if (i === state.bottleWave.n - 1) xy[0] = state.glassBottle.bottleBox.width;
      return xy;
    }); // 2) Kick off the rendering at each tick.

    renderBottleWave();
  }
  /**
   * Kicks of the wine wave draw on each tick.
   * Passes in the time at each tick implicitly.
   */


  function startWave() {
    // Throttle the ticker if necessary.
    // gsap.ticker.fps(30);
    gsapWithCSS.ticker.add(makeWave);
  }

  function stopWave() {
    gsapWithCSS.ticker.remove(makeWave);
  }
  /**
   * Little additional tween every time the user scrolls
   * to kickstart and slowly decay the wave.
   */


  function decayWave() {
    gsapWithCSS.timeline().to(state.bottleWave, {
      r: 10,
      duration: 0.2
    }).to(state.bottleWave, {
      r: 1,
      duration: 2
    });
  } // Tween and draw.


  function drawBottleWave(ctx, path, t) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale); // Clip path.

    ctx.beginPath();
    state.bottleWave.waveLine.context(ctx)(state.bottleWave.wavePoints);
    ctx.lineTo(state.width, state.height);
    ctx.lineTo(0, state.height);
    ctx.closePath();
    ctx.clip(); // Background.

    ctx.fill(path);
    ctx.restore();
  }

  function renderBottleWave() {
    requestAnimationFrame(function () {
      state.ctx.bottleWave.save();
      state.ctx.bottleWave.fillStyle = gradient;
      drawBottleWave(state.ctx.bottleWave, state.bottleWave.bottlePath, state.transform.shape);
      state.ctx.bottleWave.restore();
    });
  }

  function defineTweenBottleWave(liftStart, liftTarget) {
    // The wave's x scale and line generator.
    state.bottleWave.xWaveScale = point$1().domain(range(state.bottleWave.n)).range([0, state.width]);
    state.bottleWave.waveLine = line().x(function (d) {
      return d[0];
    }).y(function (d) {
      return d[1];
    }).curve(curveBasis);
    state.bottleWave.waveAlpha = state.width / state.height < 0.5 ? 1 : 5; // The bottle's fill.

    gradient = getGradient(state.bottleColour.base); // Set up timeline.
    // On scroll the lift gets updated, which startWave's
    // canvas draw function picks up to lift the waving wave.
    // Note the lift's start and target are arguments as this tween is being
    // built in two situations.

    var tl = gsapWithCSS.timeline({
      onStart: startWave,
      onUpdate: decayWave
    });
    var lift = gsapWithCSS.fromTo(state.bottleWave, {
      lift: liftStart
    }, {
      lift: liftTarget
    });
    return tl.add(lift);
  }

  function tweenBottleWave() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleWave');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleWave) state.tween.bottleWave.kill();
    state.tween.bottleWave = defineTweenBottleWave(-0.1, 0.6);
    state.tween.bottleWave.totalProgress(progress);
  }

  /* eslint-disable no-nested-ternary */

  var margin = {
    top: 20,
    right: 20,
    bottom: 30,
    left: 20
  }; // Function to compute density

  function kernelDensityEstimator(kernel, X) {
    return function (V) {
      return X.map(function (x) {
        return [x, mean(V, function (v) {
          return kernel(x - v);
        })];
      });
    };
  }

  function kernelEpanechnikov(k) {
    return function (v) {
      return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
    };
  } // Control build function.


  function buildControl(datapoint, i) {
    // Get the datum's values.
    var variable = datapoint.key;
    var value = datapoint.value; // Identify # of decimals to show.

    var valueRange = state.model.ranges.get(variable);
    var rangeDelta = valueRange[1] - valueRange[0];
    var decimals = rangeDelta > 0.09 ? 2 : 3; // Set up.

    var sel = select(this);
    sel.select('svg').remove(); // No join mechanics here - let's be deterministic.

    var svg = sel.append('svg').attr('class', 'control');
    var rs = st.svg(svg.node()); // SVG is defined as 100% width/height in CSS.

    var width = parseInt(svg.style('width'), 10) - margin.left - margin.right;
    var height = parseInt(svg.style('height'), 10) - margin.top - margin.bottom; // Clip path for the marker.

    var clippy = svg.append('defs').append('clipPath').attr('id', "clippy-".concat(variable)).append('path'); // The chart g.

    var g = svg.append('g').attr('transform', "translate(".concat(margin.left, ", ").concat(margin.top, ")")); // x Scale.

    var xScale = linear$1().domain(state.model.ranges.get(variable)).range([0, width]); // Label.

    var labelText = variable === 'ph' ? 'pH' : prettyLabel(variable);
    g.append('text').attr('x', width).attr('y', -margin.top / 2).attr('dy', '0.35em').attr('text-anchor', 'end').style('font-family', 'Signika').style('font-size', 12).text(labelText); // Axis.

    g.append('line').attr('y1', height).attr('x2', width).attr('y2', height).style('stroke-width', 1).style('stroke', '#000'); // Build axis labels only for first chart.

    if (i === 0) {
      var axisLabel = g.append('g').attr('class', 'axis-label').style('font-family', 'Signika').style('font-size', 12).style('fill', '#555');
      axisLabel.append('text').text('less').attr('x', 0).attr('y', height).attr('dy', '1em').style('text-anchor', 'start');
      axisLabel.append('text').text('more').attr('x', width).attr('y', height).attr('dy', '1em').style('text-anchor', 'end');
    } // Density data.


    var k = (state.model.ranges.get(variable)[1] - state.model.ranges.get(variable)[0]) * 0.05;
    var kde = kernelDensityEstimator(kernelEpanechnikov(k), xScale.ticks(40));
    var density = kde(state.stats.data.map(function (d) {
      return d[variable];
    })); // Add a start and an end point at x = 0 to the mix.

    density.unshift([density[0][0], 0]);
    density.push([density[density.length - 1][0], 0]); // y Scale.

    var yScale = linear$1().domain([0, max(density.map(function (d) {
      return d[1];
    }))]).range([height, 0]); // Line generator.

    var lineGen = line().curve(curveBasis).x(function (d) {
      return xScale(d[0]);
    }).y(function (d) {
      return yScale(d[1]);
    }); // Get density path.

    var densityPath = lineGen(density); // Density chart.

    var fill = rs.path(densityPath, {
      fill: '#555',
      stroke: 'rgba(0, 0, 0, 0.7)'
    });
    g.node().appendChild(fill);
    g.select('path').attr('class', "density ".concat(variable)); // Clip path data.

    clippy.attr('d', densityPath); // Position data for the drag subjects.

    var position = {
      x: xScale(value),
      y: height,
      width: 30,
      height: height + margin.bottom
    }; // Marker.

    g.append('line').datum(position).attr('x1', function (d) {
      return d.x;
    }).attr('y1', function (d) {
      return d.y;
    }).attr('x2', function (d) {
      return d.x;
    }).attr('y2', 0).attr('class', 'marker').attr('clip-path', "url(#clippy-".concat(variable, ")")).style('stroke-width', 1).style('stroke', 'black'); // Handle.

    g.append('circle').datum(position).attr('cx', function (d) {
      return d.x;
    }).attr('cy', function (d) {
      return d.y;
    }).attr('r', 5).attr('class', 'handle').style('fill', '#000'); // Number.

    g.append('text').datum(position).attr('x', function (d) {
      return d.x;
    }).attr('y', function (d) {
      return d.y;
    }).attr('class', 'label').attr('dy', i ? '0.7em' : '0.9em').attr('text-anchor', 'middle').attr('dominant-baseline', 'hanging').style('font-family', 'Signika').style('font-size', 12).text(value.toFixed(decimals)); // Drag handler.

    function handleDrag(datum) {
      // Clamp the x value.
      var x = event.x > width ? width : event.x < 0 ? 0 : event.x; // Update the data.

      value = xScale.invert(x);
      state.model.values.set(variable, value);
      state.model.probability = getProbability(state.model.values, state.model.weights, state.model.intercept); // Operate the bottle wave on change.

      decayWave();
      state.bottleWave.lift = state.model.probability; // Update DOM.

      var dragrect = select(this);
      var circle = select(this.parentNode).select('circle.handle');
      var marker = select(this.parentNode).select('line.marker');
      var label = select(this.parentNode).select('text.label');
      dragrect.attr('x', function () {
        datum.x = x;
        return datum.x - datum.width / 2;
      });
      circle.attr('cx', datum.x = x);
      marker.attr('x1', datum.x = x).attr('x2', datum.x = x);
      label.attr('x', datum.x = x).text(value.toFixed(decimals)); // Add some wine making tips to the canvas indirectly.

      setPropertyInfo(variable, value);
    } // Drag rectangle.


    g.append('rect').datum(position).attr('x', function (d) {
      return d.x - d.width / 2;
    }).attr('y', 0).attr('width', function (d) {
      return d.width;
    }).attr('height', function (d) {
      return d.height;
    }).style('opacity', 0) // can't see it - no no.
    .call(drag().on('drag', handleDrag));
  }

  function buildModelControls() {
    // Sort the controls by their variable importance.
    var order = state.varImp.data.map(function (d) {
      return d.variable;
    });
    var controlData = state.model.values.entries();
    controlData.sort(function (a, b) {
      return order.indexOf(a.key) - order.indexOf(b.key);
    }); // Mount the app.

    select('#model-app-wrap').selectAll('.model-value-control').data(controlData).join('div').attr('class', 'model-value-control').each(buildControl);
  }

  function drawScape(ctx, img, t, alpha) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.drawImage(img, 0, 0, img.width, img.height);
    ctx.restore();
  }

  function renderScape() {
    requestAnimationFrame(function () {
      return drawScape(state.ctx.scape, state.scape.image, state.transform.scape, state.scape.alpha);
    });
  }

  function defineTweenWineScape() {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderScape
    });
    var imagealpha = gsapWithCSS.fromTo(state.scape, {
      alpha: 0
    }, {
      alpha: 1
    });
    return tl.add(imagealpha, 0);
  }

  function tweenWineScape() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('wineScape');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.wineScape) state.tween.wineScape.kill();
    state.tween.wineScape = defineTweenWineScape();
    state.tween.wineScape.totalProgress(progress);
  }

  function drawBottle(ctx, path, t) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.beginPath();

    for (var i = 0; i < path.length; i++) {
      var segment = path[i];
      var l = segment.length;
      ctx.moveTo(segment[0], segment[1]);

      for (var j = 2; j < l; j += 6) {
        ctx.bezierCurveTo(segment[j], segment[j + 1], segment[j + 2], segment[j + 3], segment[j + 4], segment[j + 5]);
      }

      if (segment.closed) {
        ctx.closePath();
      }
    }

    ctx.stroke();
    ctx.restore();
  }

  function renderBottle() {
    requestAnimationFrame(function () {
      // We need to draw on both contexts here, as the tween doesn't only cover
      // paramaters for the glassBottle but also the alpha for the scape context.
      drawScape(state.ctx.scape, state.scape.image, state.transform.scape, state.scape.alpha);
      state.ctx.glassBottle.save();
      state.ctx.glassBottle.strokeStyle = state.glassBottle.colour;
      drawBottle(state.ctx.glassBottle, state.glassBottle.path, state.transform.shape);
      state.ctx.glassBottle.restore();
    });
  }

  function defineTweenGlassBottle() {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottle
    });
    var morph = gsapWithCSS.to('#glass-path', {
      morphSVG: {
        shape: '#bottle-path',
        map: 'complexity',
        updateTarget: false,
        render: function render(path) {
          state.glassBottle.path = path;
        }
      }
    });
    var colourvalue = gsapWithCSS.fromTo(state.glassBottle, {
      colour: 'rgba(0, 0, 0, 0)'
    }, {
      colour: 'rgba(0, 0, 0, 1)',
      ease: 'circ.out'
    });
    var retransform = gsapWithCSS.fromTo(state.transform.shape, {
      x: state.transform.scape.x,
      y: state.transform.scape.y,
      scale: state.transform.scape.scale
    }, {
      x: state.transform.bottle.x,
      y: state.transform.bottle.y,
      scale: state.transform.bottle.scale,
      ease: 'none'
    });
    var imagealpha = gsapWithCSS.fromTo(state.scape, {
      alpha: 1
    }, {
      alpha: state.scape.alphaTarget
    });
    return tl.add(retransform, 0).add(colourvalue, 0).add(morph, 0).add(imagealpha, 0);
  }

  function tweenGlassBottle() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('glassBottle');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.glassBottle) state.tween.glassBottle.kill();
    state.tween.glassBottle = defineTweenGlassBottle();
    state.tween.glassBottle.totalProgress(progress);
  }

  /**
   * Draws a path at a certain offset of its full length.
   * Can nicely be used to animate a path.
   * @param { Object } ctx Context to draw on
   * @param { Array|String} paths Path(s) to draw
   * @param { Object } t transform to apply to context
   * @param { Number } length Max length of the (longest) path
   * @param { Number } offset Length of the path to draw (ideally animated)
   */

  function drawTextPath(ctx, paths, t, length, offset) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    state.ctx.bottleText.strokeStyle = state.bottleText.colour;
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.setLineDash([length - offset, offset]); // eslint-disable-next-line no-unused-expressions

    Array.isArray(paths) ? paths.forEach(function (path) {
      return ctx.stroke(path);
    }) : ctx.stroke(paths);
    ctx.restore();
  }

  function renderBottleText() {
    requestAnimationFrame(function () {
      state.ctx.bottleText.save();
      state.ctx.bottleText.lineWidth = 0.7;
      drawTextPath(state.ctx.bottleText, state.bottleText.paths, state.transform.shape, state.bottleText.maxLength, state.bottleText.dashOffset);
      state.ctx.bottleText.restore();
    });
  }

  function defineTweenBottleText(offsetDraw, alphaStart, alphaTarget) {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleText
    });
    var offsetIn = gsapWithCSS.fromTo(state.bottleText, {
      dashOffset: state.bottleText.maxLength
    }, {
      dashOffset: 0
    });
    var offsetOut = gsapWithCSS.fromTo(state.bottleText, {
      dashOffset: 0
    }, {
      dashOffset: state.bottleText.maxLength
    });
    var colourvalue = gsapWithCSS.fromTo(state.bottleText, {
      colour: "rgba(0, 0, 0, ".concat(alphaStart, ")")
    }, {
      colour: "rgba(0, 0, 0, ".concat(alphaTarget, ")"),
      ease: 'circ.out'
    });
    return tl.add(offsetDraw ? offsetIn : offsetOut).add(colourvalue, 0);
  }

  function tweenBottleText() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleText');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleText) state.tween.bottleText.kill();
    state.tween.bottleText = defineTweenBottleText(true, 0, 1);
    state.tween.bottleText.totalProgress(progress);
  }

  /* eslint-disable no-param-reassign */

  var inputProperties = ['alcohol', 'acids', 'sugars'];
  var outputProperties = ['quality'];
  var letterHeight;
  var bottleWidth;
  var input = {
    p1: {
      x: 0
    },
    p2: {
      x: 0
    },
    yEndAdd: [0, 0, 0],
    arrow: {
      size: 0
    }
  };
  var output = {
    p1: {
      x: 0
    },
    p2: {
      x: 0
    },
    y: {
      y: 0
    },
    arrow: {
      size: 0
    },
    yAdd: undefined
  }; // Canvas draw function.

  function drawBlackBox(ctx, t) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save(); // Scaling and translating with some added "pulse" to
    // suck up the predictors and spit out the dependent.

    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale); // Draw box (animate)

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 0.1;
    state.blackBox.box.paths.forEach(function (path) {
      ctx.setLineDash([state.blackBox.box.length - state.blackBox.box.offset, state.blackBox.box.offset]);
      ctx.stroke(path);
    }); // Draw text (don't animate).

    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    state.blackBox.model.paths.forEach(function (path) {
      ctx.stroke(path);
    });
    ctx.restore();
  }

  function drawProperties(ctx, t, inputVars, outputVars) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale); // Draw input properties.

    inputVars.forEach(function (d, i) {
      var paths = state.lolli.data[d].text.paths;
      ctx.save();
      ctx.translate(state.lolli.x(0), state.lolli.y(d) + 2); // Draw text

      ctx.lineWidth = 0.5;
      paths.forEach(function (path) {
        return ctx.stroke(path);
      }); // Draw line

      ctx.lineWidth = 1.25;
      var p0 = {
        x: 0,
        y: letterHeight * 0.5
      };
      var p1 = {
        x: input.p1.x,
        y: letterHeight * 0.5
      };
      var p2 = {
        x: input.p2.x,
        y: letterHeight * 0.5 + input.yEndAdd[i]
      };
      ctx.strokeStyle = 'white';
      bezWithArrowheads(ctx, p0, p1, p2, undefined, input.arrow.size, false, true);
      ctx.restore();
    }); // Draw output property (or properties).

    outputVars.forEach(function (d) {
      var length = state.lolli.data[d].text.length;
      var offset = state.lolli.data[d].text.offset;
      var paths = state.lolli.data[d].text.paths;
      ctx.save();
      ctx.translate(state.lolli.x(0), state.lolli.y(d) + 2); // Draw text

      ctx.lineWidth = 0.5;
      ctx.setLineDash([length - offset, offset]);
      paths.forEach(function (path) {
        return ctx.stroke(path);
      }); // Draw line

      ctx.lineWidth = 1.25;
      var p0 = {
        x: -bottleWidth * 0.33,
        y: -letterHeight * 0.5 + output.yAdd
      };
      var p1 = {
        x: output.p1.x,
        y: output.y.y
      };
      var p2 = {
        x: output.p2.x,
        y: output.y.y
      };
      ctx.strokeStyle = 'white';
      bezWithArrowheads(ctx, p0, p1, p2, undefined, output.arrow.size, false, true);
      ctx.restore();
    });
    ctx.restore();
  }

  function renderBlackBox() {
    requestAnimationFrame(function () {
      drawBlackBox(state.ctx.blackBox, state.transform.bottle);
      drawProperties(state.ctx.chart, state.transform.bottle, inputProperties, outputProperties);
    });
  } // Tween function.


  function defineTweenBlackBox(type) {
    // Things to tween.
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBlackBox
    }); // Arrow data.

    bottleWidth = state.glassBottle.bottleBox.width;
    letterHeight = max(state.lolli.data[outputProperties[0]].text.dims, function (d) {
      return d.height;
    });
    output.yAdd = -state.lolli.y.step() * 0.1;

    if (type === 'arrowIn') {
      // Box path.
      var boxoffset = gsapWithCSS.fromTo(state.blackBox.box, {
        offset: state.blackBox.box.length
      }, {
        offset: 0
      }); // Tween add.

      tl.add(boxoffset); // Input arrow tweens.

      var p1tween = gsapWithCSS.fromTo(input.p1, {
        x: 0
      }, {
        x: -bottleWidth * 0.125
      });
      var p2tween = gsapWithCSS.fromTo(input.p2, {
        x: 0
      }, {
        x: -bottleWidth * 0.33
      });
      var yEndTween = gsapWithCSS.fromTo(input.yEndAdd, [0, 0, 0], [+state.lolli.y.step() * 0.6, +state.lolli.y.step() * 0.1, -state.lolli.y.step() * 0.33]);
      var arrowtween = gsapWithCSS.fromTo(input.arrow, {
        size: 0
      }, {
        size: 5
      }); // Tween add.

      tl.add(p1tween, '>');
      tl.add(p2tween, '<');
      tl.add(yEndTween, '<');
      tl.add(arrowtween, '<');
    }

    if (type === 'arrowOut') {
      // Output arrow tweens.
      var p1outtween = gsapWithCSS.fromTo(output.p1, {
        x: -bottleWidth * 0.33
      }, {
        x: -bottleWidth * 0.2
      });
      var p2outtween = gsapWithCSS.fromTo(output.p2, {
        x: -bottleWidth * 0.33
      }, {
        x: -5
      });
      var ytween = gsapWithCSS.fromTo(output.y, {
        y: -letterHeight * 0.5 + output.yAdd
      }, {
        y: letterHeight * 0.5
      });
      var arrowOutTween = gsapWithCSS.fromTo(output.arrow, {
        size: 0
      }, {
        size: 5
      }); // Tween add.

      tl.add(p1outtween, '>');
      tl.add(p2outtween, '<');
      tl.add(ytween, '<');
      tl.add(arrowOutTween, '<'); // Path dash offset.

      var datapoint = state.lolli.data.quality;
      var offsettween = gsapWithCSS.fromTo(datapoint.text, {
        offset: datapoint.text.length
      }, {
        offset: 0
      }); // Tween add.

      tl.add(offsettween, '<');
    }

    return tl;
  }

  var arrows = ['arrowIn', 'arrowOut'];

  function tweenBlackBox() {
    arrows.forEach(function (d) {
      // Capture current progress.
      var scroll = ScrollTrigger.getById(d);
      var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

      if (state.tween[d]) state.tween[d].kill();
      state.tween[d] = defineTweenBlackBox(d);
      state.tween[d].totalProgress(progress);
    });
  }

  /* eslint-disable no-param-reassign */

  var inputProperties$1 = ['alcohol', 'acids', 'sugars'];
  var outputProperties$1 = ['quality'];
  var letterHeight$1;
  var bottleWidth$1;
  var input$1 = {
    p1: {
      x: 0
    },
    p2: {
      x: 0
    },
    yEndAdd: [0, 0, 0],
    arrow: {
      size: 0
    },
    paths: {
      length: 0,
      offset: 0
    }
  };
  var output$1 = {
    p1: {
      x: 0
    },
    p2: {
      x: 0
    },
    y: {
      y: 0
    },
    arrow: {
      size: 0
    },
    yAdd: undefined
  }; // Utils.

  function bezWithArrowheads$1(ctx, p0, p1, p2, p3, arrowLength, hasStartArrow, hasEndArrow) {
    var x;
    var y;
    var norm;
    var ex;
    var ey;

    function pointsToNormalisedVec(p, pp) {
      norm.y = pp.x - p.x;
      norm.x = -(pp.y - p.y);
      var len = Math.sqrt(norm.x * norm.x + norm.y * norm.y);
      norm.x /= len;
      norm.y /= len;
      return norm;
    }

    var arrowWidth = arrowLength / 2;
    norm = {}; // defaults to true for both arrows if arguments not included

    hasStartArrow = hasStartArrow === undefined || hasStartArrow === null ? true : hasStartArrow;
    hasEndArrow = hasEndArrow === undefined || hasEndArrow === null ? true : hasEndArrow;
    ctx.beginPath();
    ctx.moveTo(p0.x, p0.y);

    if (p3 === undefined) {
      ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
      ex = p2.x; // get end point

      ey = p2.y;
      norm = pointsToNormalisedVec(p1, p2);
    } else {
      ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      ex = p3.x; // get end point

      ey = p3.y;
      norm = pointsToNormalisedVec(p2, p3);
    }

    if (hasEndArrow) {
      x = arrowWidth * norm.x + arrowLength * -norm.y;
      y = arrowWidth * norm.y + arrowLength * norm.x;
      ctx.moveTo(ex + x, ey + y);
      ctx.lineTo(ex, ey);
      x = arrowWidth * -norm.x + arrowLength * -norm.y;
      y = arrowWidth * -norm.y + arrowLength * norm.x;
      ctx.lineTo(ex + x, ey + y);
    }

    if (hasStartArrow) {
      norm = pointsToNormalisedVec(p0, p1);
      x = arrowWidth * norm.x - arrowLength * -norm.y;
      y = arrowWidth * norm.y - arrowLength * norm.x;
      ctx.moveTo(p0.x + x, p0.y + y);
      ctx.lineTo(p0.x, p0.y);
      x = arrowWidth * -norm.x - arrowLength * -norm.y;
      y = arrowWidth * -norm.y - arrowLength * norm.x;
      ctx.lineTo(p0.x + x, p0.y + y);
    }

    ctx.stroke();
  }

  function drawProperties$1(ctx, t, inputVars, outputVars) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale); // Draw input properties.

    inputVars.forEach(function (d, i) {
      var paths = state.lolli.data[d].text.paths;
      ctx.save();
      ctx.translate(state.lolli.x(0), state.lolli.y(d) + 2); // Draw text

      ctx.lineWidth = 0.5;
      ctx.setLineDash([input$1.paths.length - input$1.paths.offset, input$1.paths.offset]);
      paths.forEach(function (path) {
        return ctx.stroke(path);
      }); // Draw line

      ctx.lineWidth = 1.25;
      var p0 = {
        x: 0,
        y: letterHeight$1 * 0.5
      };
      var p1 = {
        x: input$1.p1.x,
        y: letterHeight$1 * 0.5
      };
      var p2 = {
        x: input$1.p2.x,
        y: letterHeight$1 * 0.5 + input$1.yEndAdd[i]
      };
      ctx.strokeStyle = 'white';
      bezWithArrowheads$1(ctx, p0, p1, p2, undefined, input$1.arrow.size, false, true);
      ctx.restore();
    }); // Draw output property (or properties).

    outputVars.forEach(function (d) {
      var length = state.lolli.data[d].text.length;
      var offset = state.lolli.data[d].text.offset;
      var paths = state.lolli.data[d].text.paths;
      ctx.save();
      ctx.translate(state.lolli.x(0), state.lolli.y(d) + 2); // Draw text

      ctx.lineWidth = 0.5;
      ctx.setLineDash([length - offset, offset]);
      paths.forEach(function (path) {
        return ctx.stroke(path);
      }); // Draw line

      ctx.lineWidth = 1.25;
      var p0 = {
        x: -bottleWidth$1 * 0.33,
        y: -letterHeight$1 * 0.5 + output$1.yAdd
      };
      var p1 = {
        x: output$1.p1.x,
        y: output$1.y.y
      };
      var p2 = {
        x: output$1.p2.x,
        y: output$1.y.y
      };
      ctx.strokeStyle = 'white';
      bezWithArrowheads$1(ctx, p0, p1, p2, undefined, 5, false, true);
      ctx.restore();
    });
    ctx.restore();
  }

  function renderCleanup() {
    requestAnimationFrame(function () {
      drawBlackBox(state.ctx.blackBox, state.transform.bottle);
      drawProperties$1(state.ctx.chart, state.transform.bottle, inputProperties$1, outputProperties$1);
    });
  } // Tween function.


  function defineTweenCleanup() {
    // Things to tween.
    var tl = gsapWithCSS.timeline({
      onUpdate: renderCleanup
    }); // Arrow tweens.

    bottleWidth$1 = state.glassBottle.bottleBox.width;
    letterHeight$1 = max(state.lolli.data[outputProperties$1[0]].text.dims, function (d) {
      return d.height;
    });
    output$1.yAdd = -state.lolli.y.step() * 0.1; // Input arrow tweens.

    var p1tween = gsapWithCSS.fromTo(input$1.p1, {
      x: -bottleWidth$1 * 0.125
    }, {
      x: 0
    });
    var p2tween = gsapWithCSS.fromTo(input$1.p2, {
      x: -bottleWidth$1 * 0.33
    }, {
      x: 0
    });
    var yEndTween = gsapWithCSS.fromTo(input$1.yEndAdd, [+state.lolli.y.step() * 0.6, +state.lolli.y.step() * 0.1, -state.lolli.y.step() * 0.33], [0, 0, 0]);
    var arrowtween = gsapWithCSS.fromTo(input$1.arrow, {
      size: 5
    }, {
      size: 0
    }); // Path dash offset.

    input$1.paths.length = max(inputProperties$1.map(function (d) {
      return state.lolli.data[d].text.length;
    }));
    var offsettween1 = gsapWithCSS.fromTo(input$1.paths, {
      offset: 0
    }, {
      offset: input$1.paths.length
    });
    tl.add(offsettween1, '<'); // Tween add.

    tl.add(p1tween, '<');
    tl.add(p2tween, '<');
    tl.add(yEndTween, '<');
    tl.add(arrowtween, '<'); // Output arrow tweens.

    var p1outtween = gsapWithCSS.fromTo(output$1.p1, {
      x: -bottleWidth$1 * 0.2
    }, {
      x: -bottleWidth$1 * 0.33
    });
    var p2outtween = gsapWithCSS.fromTo(output$1.p2, {
      x: -5
    }, {
      x: -bottleWidth$1 * 0.33
    });
    var ytween = gsapWithCSS.fromTo(output$1.y, {
      y: letterHeight$1 * 0.5
    }, {
      y: -letterHeight$1 * 0.5 + output$1.yAdd
    });
    var arrowOutTween = gsapWithCSS.fromTo(output$1.arrow, {
      size: 5
    }, {
      size: 0
    }); // Tween add.

    tl.add(p1outtween, '<');
    tl.add(p2outtween, '<');
    tl.add(ytween, '<');
    tl.add(arrowOutTween, '<'); // Path dash offset.

    var datapoint = state.lolli.data.quality;
    var offsettween = gsapWithCSS.fromTo(datapoint.text, {
      offset: 0
    }, {
      offset: datapoint.text.length
    }); // Tween add.

    tl.add(offsettween, '<'); // Box path.

    var boxoffset = gsapWithCSS.fromTo(state.blackBox.box, {
      offset: 0
    }, {
      offset: state.blackBox.box.length
    }); // Tween add.

    tl.add(boxoffset, '<');
    return tl;
  }

  function tweenCleanup() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('cleanup');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.cleanup) state.tween.cleanup.kill();
    state.tween.cleanup = defineTweenCleanup();
    state.tween.cleanup.totalProgress(progress);
  }

  /* eslint-disable no-use-before-define */

  function tweenBottleEmpty() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleEmpty');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleEmpty) state.tween.bottleEmpty.kill();
    state.tween.bottleEmpty = defineTweenBottleWave(0.6, -0.1);
    state.tween.bottleEmpty.totalProgress(progress);
  }

  /* eslint-disable no-use-before-define */

  function tweenBottleTextOut() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleTextOut');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleTextOut) state.tween.bottleTextOut.kill();
    state.tween.bottleTextOut = defineTweenBottleText(false, 1, 0);
    state.tween.bottleTextOut.totalProgress(progress);
  }

  // in the update function to set up the scroll triggers).

  var animalPaths = [{
    id: '#bottle-path',
    name: 'bottle'
  }, {
    id: '#animalPig',
    name: 'animalPig'
  }, {
    id: '#animalCroc',
    name: 'animalCroc'
  }, {
    id: '#animalGiraffe',
    name: 'animalGiraffe'
  }, {
    id: '#animalSloth1',
    name: 'animalSloth1'
  }, {
    id: '#animalWhale',
    name: 'animalWhale'
  }, {
    id: '#animalBird',
    name: 'animalBird'
  }, {
    id: '#animalSloth2a',
    name: 'animalSloth2a'
  }, {
    id: '#bottle-path',
    name: 'bottle'
  }];

  function drawAnimals(ctx, path, t) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.strokeStyle = state.glassBottle.colour;
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.beginPath();

    for (var i = 0; i < path.length; i++) {
      var segment = path[i];
      var l = segment.length;
      ctx.moveTo(segment[0], segment[1]);

      for (var j = 2; j < l; j += 6) {
        ctx.bezierCurveTo(segment[j], segment[j + 1], segment[j + 2], segment[j + 3], segment[j + 4], segment[j + 5]);
      }

      if (segment.closed) {
        ctx.closePath();
      }
    }

    ctx.stroke();
    ctx.restore();
  }

  function renderAnimals() {
    requestAnimationFrame(function () {
      drawAnimals(state.ctx.glassBottle, state.glassBottle.path, state.transform.shape);
    });
  }

  function defineTweenAnimals(from, to) {
    // The timeline.
    var tl = gsapWithCSS.timeline({
      onUpdate: renderAnimals
    }); // The path morph.

    var morph = gsapWithCSS.to(from.id, {
      morphSVG: {
        shape: to.id,
        map: 'complexity',
        updateTarget: false,
        render: function render(path) {
          state.glassBottle.path = path;
        }
      }
    }); // The path's transforms.

    var trans = gsapWithCSS.fromTo(state.transform.shape, {
      x: state.transform[from.name].x,
      y: state.transform[from.name].y,
      scale: state.transform[from.name].scale
    }, {
      x: state.transform[to.name].x,
      y: state.transform[to.name].y,
      scale: state.transform[to.name].scale,
      ease: 'none'
    });
    tl.add(morph, from.pos).add(trans, '<');
    return tl;
  }

  function tweenAnimals() {
    // Build a tween for each path transition (1 less than
    // the array as each tween has a from and a to path).
    for (var i = 0; i < animalPaths.length - 1; i++) {
      // Get the from and the to element.
      var from = animalPaths[i];
      var to = animalPaths[i + 1]; // Capture current progress.

      var scroll = ScrollTrigger.getById(from.name);
      var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

      if (state.tween[from.name]) state.tween[from.name].kill();
      state.tween[from.name] = defineTweenAnimals(from, to);
      state.tween[from.name].totalProgress(progress);
    }
  }

  /* eslint-disable no-use-before-define */

  function tweenBottleFill() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleFill');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleFill) state.tween.bottleFill.kill();
    state.tween.bottleFill = defineTweenBottleWave(-0.1, 1.05);
    state.tween.bottleFill.totalProgress(progress);
  }

  /* eslint-disable camelcase */

  var colours = state.bottleColour;
  var bottleColours = [{
    name: 'colourGood',
    fromStop0: colours.base.stop0,
    toStop0: colours.good.stop0,
    fromStop1: colours.base.stop1,
    toStop1: colours.good.stop1
  }, {
    name: 'colourBad',
    fromStop0: colours.good.stop0,
    toStop0: colours.bad.stop0,
    fromStop1: colours.good.stop1,
    toStop1: colours.bad.stop1
  }, {
    name: 'colourBase',
    fromStop0: colours.bad.stop0,
    toStop0: colours.base.stop0,
    fromStop1: colours.bad.stop1,
    toStop1: colours.base.stop1
  }]; // The object to tween to and from.

  var colourStops = {
    stop0: null,
    stop1: null
  }; // When scrolling back to start from the end of the story,
  // the bottle wave points are below the bottle from the model.
  // app. We simply set them to above the bottle neck.

  function fillUpBottleWave() {
    state.bottleWave.wavePoints = [[0, -20], [state.width, -20]];
  } // Render.


  function renderBottleColour() {
    requestAnimationFrame(function () {
      // Save contexts.
      state.ctx.bottleWave.save();
      state.ctx.glassBottle.save(); // Set context styles.

      var gradient = getGradient(colourStops);
      state.ctx.bottleWave.fillStyle = gradient;
      state.ctx.glassBottle.strokeStyle = gradient; // Set the bottle wave line to be above bottle.

      fillUpBottleWave(); // Draw.

      drawBottleWave(state.ctx.bottleWave, state.bottleWave.bottlePath, state.transform.shape);
      drawBottle(state.ctx.glassBottle, state.glassBottle.path, state.transform.bottle); // Restore contexts.

      state.ctx.bottleWave.restore();
      state.ctx.glassBottle.restore();
    });
  } // Tween set up.


  function defineTweenBottleColour(col) {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleColour
    });
    var stop0Tween = gsapWithCSS.fromTo(colourStops, {
      stop0: col.fromStop0
    }, {
      stop0: col.toStop0
    });
    var stop1Tween = gsapWithCSS.fromTo(colourStops, {
      stop1: col.fromStop1
    }, {
      stop1: col.toStop1
    });
    return tl.add(stop0Tween).add(stop1Tween, '<');
  }

  function tweenBottleColour() {
    bottleColours.forEach(function (d) {
      // Capture current progress.
      var scroll = ScrollTrigger.getById(d.name);
      var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

      if (state.tween[d.name]) state.tween[d.name].kill();
      state.tween[d.name] = defineTweenBottleColour(d);
      state.tween[d.name].totalProgress(progress);
    });
  }

  /* eslint-disable no-return-assign */

  function gridLayout() {
    var rows = 15;
    var cols = 15;
    var scale = 0.15;
    var points = []; // Add layout to original data.

    function augmentData(baseData, grid) {
      baseData.forEach(function (d, i) {
        d.layout = {
          x: grid[i].x,
          y: grid[i].y,
          scale: grid[i].scale
        };
      });
    } // Layout function.


    function layout(data) {
      // Test.
      if (rows * cols !== data.length) throw Error('data needs to have rows * col length'); // Build layout.

      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
          var point = {
            x: Math.round(c / (cols - 1) * 1e5) / 1e5,
            y: Math.round(r / (rows - 1) * 1e5) / 1e5,
            scale: scale
          };
          points.push(point);
        }
      } // Clone and augment original data.


      var dataCloned = data.map(function (d) {
        return lodash_clonedeep(d);
      });
      augmentData(dataCloned, points);
      return dataCloned;
    } // Getters|Setters.


    layout.rows = function (_) {
      return _ ? (rows = _, layout) : rows;
    };

    layout.cols = function (_) {
      return _ ? (cols = _, layout) : cols;
    };

    layout.scale = function (_) {
      return _ ? (scale = _, layout) : scale;
    };

    return layout;
  }

  /* eslint-disable no-param-reassign */
  var smallBottleScale = isMobile() ? 0.1 : 0.15;
  var xScale;
  var yScale;
  var gradientGood;
  var gradientBad; // Helper functions.

  function getBaseData(rows, cols) {
    return range(rows * cols).map(function (d, i) {
      return {
        quality: Math.random() < 0.3,
        index: i
      };
    });
  }

  function setScales() {
    // Get scales (also determining the space for our visual)
    var xBottleCorrection = state.glassBottle.bottleBox.width / 2 * smallBottleScale;
    var yBottleCorrection = state.glassBottle.bottleBox.height / 2 * smallBottleScale;
    var topFactor = isMobile() ? 0.2 : 0.1;
    xScale = linear$1().range([state.width * 0.1 - xBottleCorrection, state.width * 0.9 - xBottleCorrection]);
    yScale = linear$1().range([state.height * topFactor - yBottleCorrection, state.height * 0.9 - yBottleCorrection]);
  }

  function prepData() {
    // Base Data.
    var num = 10;
    state.bottleGrid.baseData = getBaseData(num, num); // Target data with layout.

    state.bottleGrid.dataTarget = gridLayout().rows(num).cols(num).scale(smallBottleScale)(state.bottleGrid.baseData); // Origin data with layout.

    state.bottleGrid.dataOrigin = state.bottleGrid.dataTarget.map(function (d) {
      return lodash_clonedeep(d);
    });
    state.bottleGrid.dataOrigin.forEach(function (d) {
      d.layout.y = -0.2;
      d.layout.scale = 0;
    }); // Add the initial position of the main bottle.

    state.bottleGrid.dataOrigin[0].layout.x = xScale.invert(state.transform.bottle.x);
    state.bottleGrid.dataOrigin[0].layout.y = yScale.invert(state.transform.bottle.y);
    state.bottleGrid.dataOrigin[0].layout.scale = state.transform.bottle.scale; // Sorted data (prep for sorted tween - this is complex!).
    // 1. Clone the base data and sort it by high - low quality.

    var sortedBaseData = state.bottleGrid.baseData.map(function (d) {
      return lodash_clonedeep(d);
    }).sort(function (a, b) {
      return b.quality - a.quality;
    }); // 2. Augment it with an updated layout.

    state.bottleGrid.dataSorted = gridLayout().rows(num).cols(num).scale(smallBottleScale)(sortedBaseData); // 3. Sort it into their original position.
    // Now we have the elements in orginal order
    // but the layout objects are sorted by quality.

    state.bottleGrid.dataSorted.sort(function (a, b) {
      return a.index - b.index;
    }); // Exit positions (out data).

    state.bottleGrid.dataOut = state.bottleGrid.dataTarget.map(function (d) {
      return lodash_clonedeep(d);
    });
    state.bottleGrid.dataOut.forEach(function (d) {
      d.layout.y = -0.2;
      d.layout.scale = 0;
    });
  } // Drawing functions.


  function drawBottles(ctx, path, points) {
    ctx.clearRect(0, 0, state.width, state.height);
    points.forEach(function (point) {
      var layout = point.layout;
      ctx.save();
      ctx.translate(xScale(layout.x), yScale(layout.y));
      ctx.scale(layout.scale, layout.scale);
      ctx.beginPath();

      for (var i = 0; i < path.length; i++) {
        var segment = path[i];
        var l = segment.length;
        ctx.moveTo(segment[0], segment[1]);

        for (var j = 2; j < l; j += 6) {
          ctx.bezierCurveTo(segment[j], segment[j + 1], segment[j + 2], segment[j + 3], segment[j + 4], segment[j + 5]);
        }

        if (segment.closed) {
          ctx.closePath();
        }
      }

      ctx.stroke();
      ctx.restore();
    });
  }

  function drawBottleWaves(ctx, path, points) {
    ctx.clearRect(0, 0, state.width, state.height);
    points.forEach(function (point) {
      var layout = point.layout;
      ctx.save();
      ctx.fillStyle = point.quality ? gradientGood : gradientBad;
      ctx.translate(xScale(layout.x), yScale(layout.y));
      ctx.scale(layout.scale, layout.scale); // Clip path.

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(state.width, 0);
      ctx.lineTo(state.width, state.height);
      ctx.lineTo(0, state.height);
      ctx.closePath();
      ctx.clip(); // Background.

      ctx.fill(path);
      ctx.restore();
    });
  }

  function renderBottleGrid() {
    requestAnimationFrame(function () {
      gradientGood = getGradient(state.bottleGrid.colour.good);
      gradientBad = getGradient(state.bottleGrid.colour.bad);
      drawBottleWaves(state.ctx.bottleWave, state.bottleWave.bottlePath, state.bottleGrid.dataOrigin);
      drawBottles(state.ctx.glassBottle, state.glassBottle.path, state.bottleGrid.dataOrigin);
    });
  } // Tweening functions.


  function defineTweenBottleGrid() {
    // Prep.
    setScales();
    prepData(); // Tween

    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleGrid
    });
    var pointtween = gsapWithCSS.to(state.bottleGrid.dataOrigin.map(function (d) {
      return d.layout;
    }), {
      x: function x(i) {
        return state.bottleGrid.dataTarget[i].layout.x;
      },
      y: function y(i) {
        return state.bottleGrid.dataTarget[i].layout.y;
      },
      scale: function scale(i) {
        return state.bottleGrid.dataTarget[i].layout.scale;
      },
      stagger: 0.01
    });
    return tl.add(pointtween);
  }

  function tweenBottleGrid() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleGrid');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleGrid) state.tween.bottleGrid.kill();
    state.tween.bottleGrid = defineTweenBottleGrid();
    state.tween.bottleGrid.totalProgress(progress);
  }

  /* eslint-disable no-use-before-define */

  function defineTweenBottleGridColour() {
    // Tween
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleGrid
    }); // For shortness.

    var colours = state.bottleColour; // Tween from the base to a good gradient.

    var colourGood0 = gsapWithCSS.fromTo(state.bottleGrid.colour.good, {
      stop0: colours.base.stop0
    }, {
      stop0: colours.good.stop0
    });
    var colourGood1 = gsapWithCSS.fromTo(state.bottleGrid.colour.good, {
      stop1: colours.base.stop1
    }, {
      stop1: colours.good.stop1
    }); // Tween from the base to a bad gradient.

    var colourBad0 = gsapWithCSS.fromTo(state.bottleGrid.colour.bad, {
      stop0: colours.base.stop0
    }, {
      stop0: colours.bad.stop0
    });
    var colourBad1 = gsapWithCSS.fromTo(state.bottleGrid.colour.bad, {
      stop1: colours.base.stop1
    }, {
      stop1: colours.bad.stop1
    });
    return tl.add(colourGood0).add(colourGood1, '<').add(colourBad0).add(colourBad1, '<');
  }

  function tweenBottleGridColour() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleGridColour');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleGridColour) state.tween.bottleGridColour.kill();
    state.tween.bottleGridColour = defineTweenBottleGridColour();
    state.tween.bottleGridColour.totalProgress(progress);
  }

  /* eslint-disable no-use-before-define */

  function renderBottleGridSorted() {
    requestAnimationFrame(function () {
      drawBottleWaves(state.ctx.bottleWave, state.bottleWave.bottlePath, state.bottleGrid.dataTarget);
      drawBottles(state.ctx.glassBottle, state.glassBottle.path, state.bottleGrid.dataTarget);
    });
  }

  function defineTweenBottleGridSort() {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleGridSorted
    });
    var pointtween = gsapWithCSS.to(state.bottleGrid.dataTarget.map(function (d) {
      return d.layout;
    }), {
      x: function x(i) {
        return state.bottleGrid.dataSorted[i].layout.x;
      },
      y: function y(i) {
        return state.bottleGrid.dataSorted[i].layout.y;
      },
      scale: function scale(i) {
        return state.bottleGrid.dataSorted[i].layout.scale;
      },
      stagger: 0.01
    });
    return tl.add(pointtween);
  }

  function tweenBottleGridSort() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleGridSort');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleGridSort) state.tween.bottleGridSort.kill();
    state.tween.bottleGridSort = defineTweenBottleGridSort();
    state.tween.bottleGridSort.totalProgress(progress);
  }

  /* eslint-disable no-use-before-define */

  function renderBottleGridSorted$1() {
    requestAnimationFrame(function () {
      drawBottleWaves(state.ctx.bottleWave, state.bottleWave.bottlePath, state.bottleGrid.dataSorted);
      drawBottles(state.ctx.glassBottle, state.glassBottle.path, state.bottleGrid.dataSorted);
    });
  }

  function defineTweenBottleGridOut() {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderBottleGridSorted$1
    });
    var pointtween = gsapWithCSS.to(state.bottleGrid.dataSorted.map(function (d) {
      return d.layout;
    }), {
      x: function x(i) {
        return state.bottleGrid.dataOut[i].layout.x;
      },
      y: function y(i) {
        return state.bottleGrid.dataOut[i].layout.y;
      },
      scale: function scale(i) {
        return state.bottleGrid.dataOut[i].layout.scale;
      },
      stagger: 0.01
    });
    return tl.add(pointtween);
  }

  function tweenBottleGridOut() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('bottleGridOut');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.bottleGridOut) state.tween.bottleGridOut.kill();
    state.tween.bottleGridOut = defineTweenBottleGridOut();
    state.tween.bottleGridOut.totalProgress(progress);
  }

  function drawPath(ctx, paths, t, length, offset) {
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.setLineDash([length - offset, offset]); // eslint-disable-next-line no-unused-expressions

    Array.isArray(paths) ? paths.forEach(function (path) {
      return ctx.stroke(path);
    }) : ctx.stroke(paths);
    ctx.restore();
  }

  function renderPath() {
    requestAnimationFrame(function () {
      // Change global styles savely.
      state.ctx.glassBottle.save();
      state.ctx.glassBottle.globalAlpha = state.glassBottle.alpha; // 1

      state.ctx.glassBottle.strokeStyle = '#000000';
      state.ctx.glassBottle.lineWidth = 1.2; // We clear the canvas before we draw each column (and the grid).

      state.ctx.glassBottle.clearRect(0, 0, state.width, state.height); // We draw the grid and each dataset column with their very own
      // path offsets, that are tweened one by one by the scrolltriggers.

      state.dataset.info.forEach(function (d) {
        drawPath(state.ctx.glassBottle, state.dataset[d.name].paths, state.transform.dataset, state.dataset[d.name].length, state.dataset[d.name].offset);
      });
      state.ctx.glassBottle.restore();
    });
  }

  function defineTweenDataset(pathInfo) {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderPath
    });
    var offset = gsapWithCSS.fromTo(pathInfo, {
      offset: pathInfo.length
    }, {
      offset: 0
    });
    return tl.add(offset);
  }

  function tweenDataset() {
    // We buld a tween for each dataset element (the grid and each column).
    state.dataset.info.forEach(function (d) {
      // Capture current progress.
      var scroll = ScrollTrigger.getById(d.tween);
      var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

      if (state.tween[d.tween]) state.tween[d.tween].kill();
      state.tween[d.tween] = defineTweenDataset(state.dataset[d.name]);
      state.tween[d.tween].totalProgress(progress);
    });
  }
  //    set the alpha value to 1 in the scrolltriggers when drawing the
  //    dataset as well as setting it to 0 and clearing it before and after.

  function identity$3(x) {
    return x;
  }

  function transform(transform) {
    if (transform == null) return identity$3;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2, n = input.length, output = new Array(n);
      output[0] = (x0 += input[0]) * kx + dx;
      output[1] = (y0 += input[1]) * ky + dy;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n;
    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function feature(topology, o) {
    if (typeof o === "string") o = topology.objects[o];
    return o.type === "GeometryCollection"
        ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
        : feature$1(topology, o);
  }

  function feature$1(topology, o) {
    var id = o.id,
        bbox = o.bbox,
        properties = o.properties == null ? {} : o.properties,
        geometry = object$1(topology, o);
    return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
        : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
        : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
  }

  function object$1(topology, o) {
    var transformPoint = transform(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
        points.push(transformPoint(a[k], k));
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      return transformPoint(p);
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var type = o.type, coordinates;
      switch (type) {
        case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
        case "Point": coordinates = point(o.coordinates); break;
        case "MultiPoint": coordinates = o.coordinates.map(point); break;
        case "LineString": coordinates = line(o.arcs); break;
        case "MultiLineString": coordinates = o.arcs.map(line); break;
        case "Polygon": coordinates = polygon(o.arcs); break;
        case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
        default: return null;
      }
      return {type: type, coordinates: coordinates};
    }

    return geometry(o);
  }

  // Adds floating point numbers with twice the normal precision.
  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
  // 305–363 (1997).
  // Code adapted from GeographicLib by Charles F. F. Karney,
  // http://geographiclib.sourceforge.net/

  function adder() {
    return new Adder;
  }

  function Adder() {
    this.reset();
  }

  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0; // exact error
    },
    add: function(y) {
      add(temp, y, this.t);
      add(this, temp.s, this.s);
      if (this.s) this.t += temp.t;
      else this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };

  var temp = new Adder;

  function add(adder, a, b) {
    var x = adder.s = a + b,
        bv = x - a,
        av = x - bv;
    adder.t = (a - av) + (b - bv);
  }

  var epsilon$1 = 1e-6;
  var pi$1 = Math.PI;
  var halfPi = pi$1 / 2;
  var quarterPi = pi$1 / 4;
  var tau$1 = pi$1 * 2;

  var degrees$1 = 180 / pi$1;
  var radians = pi$1 / 180;

  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var ceil = Math.ceil;
  var sin = Math.sin;
  var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
  var sqrt = Math.sqrt;

  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
  }

  function asin(x) {
    return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
  }

  function noop$1() {}

  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }

  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };

  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };

  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }

  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }

  function geoStream(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  function spherical(cartesian) {
    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
  }

  function cartesian(spherical) {
    var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }

  function cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }

  // TODO return a
  function cartesianAddInPlace(a, b) {
    a[0] += b[0], a[1] += b[1], a[2] += b[2];
  }

  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }

  // TODO return d
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  function compose(a, b) {

    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }

    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };

    return compose;
  }

  function rotationIdentity(lambda, phi) {
    return [abs(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
  }

  rotationIdentity.invert = rotationIdentity;

  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
      : rotationLambda(deltaLambda))
      : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
      : rotationIdentity);
  }

  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
    };
  }

  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }

  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos(deltaPhi),
        sinDeltaPhi = sin(deltaPhi),
        cosDeltaGamma = cos(deltaGamma),
        sinDeltaGamma = sin(deltaGamma);

    function rotation(lambda, phi) {
      var cosPhi = cos(phi),
          x = cos(lambda) * cosPhi,
          y = sin(lambda) * cosPhi,
          z = sin(phi),
          k = z * cosDeltaPhi + x * sinDeltaPhi;
      return [
        atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
        asin(k * cosDeltaGamma + y * sinDeltaGamma)
      ];
    }

    rotation.invert = function(lambda, phi) {
      var cosPhi = cos(phi),
          x = cos(lambda) * cosPhi,
          y = sin(lambda) * cosPhi,
          z = sin(phi),
          k = z * cosDeltaGamma - y * sinDeltaGamma;
      return [
        atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
        asin(k * cosDeltaPhi - x * sinDeltaPhi)
      ];
    };

    return rotation;
  }

  // Generates a circle centered at [0°, 0°], with a given radius and precision.
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta) return;
    var cosRadius = cos(radius),
        sinRadius = sin(radius),
        step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau$1;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
    }
    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
      point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
      stream.point(point[0], point[1]);
    }
  }

  // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
  function circleRadius(cosRadius, point) {
    point = cartesian(point), point[0] -= cosRadius;
    cartesianNormalizeInPlace(point);
    var radius = acos(-point[1]);
    return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
  }

  function clipBuffer() {
    var lines = [],
        line;
    return {
      point: function(x, y, m) {
        line.push([x, y, m]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop$1,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  function pointEqual(a, b) {
    return abs(a[0] - b[0]) < epsilon$1 && abs(a[1] - b[1]) < epsilon$1;
  }

  function Intersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other; // another intersection
    this.e = entry; // is an entry?
    this.v = false; // visited
    this.n = this.p = null; // next & previous
  }

  // A generalized polygon clipping algorithm: given a polygon that has been cut
  // into its visible line segments, and rejoins the segments by interpolating
  // along the clip edge.
  function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
    var subject = [],
        clip = [],
        i,
        n;

    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n], x;

      if (pointEqual(p0, p1)) {
        if (!p0[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }
        // handle degenerate cases by moving the point
        p1[0] += 2 * epsilon$1;
      }

      subject.push(x = new Intersection(p0, segment, null, true));
      clip.push(x.o = new Intersection(p0, null, x, false));
      subject.push(x = new Intersection(p1, segment, null, false));
      clip.push(x.o = new Intersection(p1, null, x, true));
    });

    if (!subject.length) return;

    clip.sort(compareIntersection);
    link(subject);
    link(clip);

    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }

    var start = subject[0],
        points,
        point;

    while (1) {
      // Find first unvisited intersection.
      var current = start,
          isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }

  function link(array) {
    if (!(n = array.length)) return;
    var n,
        i = 0,
        a = array[0],
        b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }

  var sum = adder();

  function longitude(point) {
    if (abs(point[0]) <= pi$1)
      return point[0];
    else
      return sign(point[0]) * ((abs(point[0]) + pi$1) % tau$1 - pi$1);
  }

  function polygonContains(polygon, point) {
    var lambda = longitude(point),
        phi = point[1],
        sinPhi = sin(phi),
        normal = [sin(lambda), -cos(lambda), 0],
        angle = 0,
        winding = 0;

    sum.reset();

    if (sinPhi === 1) phi = halfPi + epsilon$1;
    else if (sinPhi === -1) phi = -halfPi - epsilon$1;

    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m = (ring = polygon[i]).length)) continue;
      var ring,
          m,
          point0 = ring[m - 1],
          lambda0 = longitude(point0),
          phi0 = point0[1] / 2 + quarterPi,
          sinPhi0 = sin(phi0),
          cosPhi0 = cos(phi0);

      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j],
            lambda1 = longitude(point1),
            phi1 = point1[1] / 2 + quarterPi,
            sinPhi1 = sin(phi1),
            cosPhi1 = cos(phi1),
            delta = lambda1 - lambda0,
            sign = delta >= 0 ? 1 : -1,
            absDelta = sign * delta,
            antimeridian = absDelta > pi$1,
            k = sinPhi0 * sinPhi1;

        sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign * tau$1 : delta;

        // Are the longitudes either side of the point’s meridian (lambda),
        // and are the latitudes smaller than the parallel (phi)?
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }

    // First, determine whether the South pole is inside or outside:
    //
    // It is inside if:
    // * the polygon winds around it in a clockwise direction.
    // * the polygon does not (cumulatively) wind around it, but has a negative
    //   (counter-clockwise) area.
    //
    // Second, count the (signed) number of times a segment crosses a lambda
    // from the point to the South pole.  If it is zero, then the point is the
    // same side as the South pole.

    return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon$1) ^ (winding & 1);
  }

  function clip(pointVisible, clipLine, interpolate, start) {
    return function(sink) {
      var line = clipLine(sink),
          ringBuffer = clipBuffer(),
          ringSink = clipLine(ringBuffer),
          polygonStarted = false,
          polygon,
          segments,
          ring;

      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains(polygon, start);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };

      function point(lambda, phi) {
        if (pointVisible(lambda, phi)) sink.point(lambda, phi);
      }

      function pointLine(lambda, phi) {
        line.point(lambda, phi);
      }

      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }

      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }

      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        ringSink.point(lambda, phi);
      }

      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }

      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();

        var clean = ringSink.clean(),
            ringSegments = ringBuffer.result(),
            i, n = ringSegments.length, m,
            segment,
            point;

        ring.pop();
        polygon.push(ring);
        ring = null;

        if (!n) return;

        // No intersections.
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
            sink.lineEnd();
          }
          return;
        }

        // Rejoin connected segments.
        // TODO reuse ringBuffer.rejoin()?
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

        segments.push(ringSegments.filter(validSegment));
      }

      return clip;
    };
  }

  function validSegment(segment) {
    return segment.length > 1;
  }

  // Intersections are sorted along the clip edge. For both antimeridian cutting
  // and circle clipping, the same comparison is used.
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon$1 : halfPi - a[1])
         - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon$1 : halfPi - b[1]);
  }

  var clipAntimeridian = clip(
    function() { return true; },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi$1, -halfPi]
  );

  // Takes a line and cuts into visible segments. Return values: 0 - there were
  // intersections or the line was empty; 1 - no intersections; 2 - there were
  // intersections, and the first and last segments should be rejoined.
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN,
        phi0 = NaN,
        sign0 = NaN,
        clean; // no intersections

    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
            delta = abs(lambda1 - lambda0);
        if (abs(delta - pi$1) < epsilon$1) { // line crosses a pole
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
          if (abs(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
          if (abs(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean; // if intersections, rejoin first and last segments
      }
    };
  }

  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0,
        cosPhi1,
        sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon$1
        ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
            - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
            / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
        : (phi0 + phi1) / 2;
  }

  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi$1, phi);
      stream.point(0, phi);
      stream.point(pi$1, phi);
      stream.point(pi$1, 0);
      stream.point(pi$1, -phi);
      stream.point(0, -phi);
      stream.point(-pi$1, -phi);
      stream.point(-pi$1, 0);
      stream.point(-pi$1, phi);
    } else if (abs(from[0] - to[0]) > epsilon$1) {
      var lambda = from[0] < to[0] ? pi$1 : -pi$1;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function clipCircle(radius) {
    var cr = cos(radius),
        delta = 6 * radians,
        smallRadius = cr > 0,
        notHemisphere = abs(cr) > epsilon$1; // TODO optimise for this common case

    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }

    function visible(lambda, phi) {
      return cos(lambda) * cos(phi) > cr;
    }

    // Takes a line and cuts into visible segments. Return values used for polygon
    // clipping: 0 - there were intersections or the line was empty; 1 - no
    // intersections 2 - there were intersections, and the first and last segments
    // should be rejoined.
    function clipLine(stream) {
      var point0, // previous point
          c0, // code for previous point
          v0, // visibility of previous point
          v00, // visibility of first point
          clean; // no intersections
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi],
              point2,
              v = visible(lambda, phi),
              c = smallRadius
                ? v ? 0 : code(lambda, phi)
                : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
              point1[2] = 1;
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              // outside going in
              stream.lineStart();
              point2 = intersect(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              // inside going out
              point2 = intersect(point0, point1);
              stream.point(point2[0], point2[1], 2);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            // If the codes for two points are different, or are both zero,
            // and there this segment intersects with the small circle.
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v && (!point0 || !pointEqual(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | ((v00 && v0) << 1);
        }
      };
    }

    // Intersects the great circle between a and b with the clip circle.
    function intersect(a, b, two) {
      var pa = cartesian(a),
          pb = cartesian(b);

      // We have two planes, n1.p = d1 and n2.p = d2.
      // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
      var n1 = [1, 0, 0], // normal
          n2 = cartesianCross(pa, pb),
          n2n2 = cartesianDot(n2, n2),
          n1n2 = n2[0], // cartesianDot(n1, n2),
          determinant = n2n2 - n1n2 * n1n2;

      // Two polar points.
      if (!determinant) return !two && a;

      var c1 =  cr * n2n2 / determinant,
          c2 = -cr * n1n2 / determinant,
          n1xn2 = cartesianCross(n1, n2),
          A = cartesianScale(n1, c1),
          B = cartesianScale(n2, c2);
      cartesianAddInPlace(A, B);

      // Solve |p(t)|^2 = 1.
      var u = n1xn2,
          w = cartesianDot(A, u),
          uu = cartesianDot(u, u),
          t2 = w * w - uu * (cartesianDot(A, A) - 1);

      if (t2 < 0) return;

      var t = sqrt(t2),
          q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A);
      q = spherical(q);

      if (!two) return q;

      // Two intersection points.
      var lambda0 = a[0],
          lambda1 = b[0],
          phi0 = a[1],
          phi1 = b[1],
          z;

      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

      var delta = lambda1 - lambda0,
          polar = abs(delta - pi$1) < epsilon$1,
          meridian = polar || delta < epsilon$1;

      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

      // Check that the first point is between a and b.
      if (meridian
          ? polar
            ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
            : phi0 <= q[1] && q[1] <= phi1
          : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q1, A);
        return [q, spherical(q1)];
      }
    }

    // Generates a 4-bit vector representing the location of a point relative to
    // the small circle's bounding box.
    function code(lambda, phi) {
      var r = smallRadius ? radius : pi$1 - radius,
          code = 0;
      if (lambda < -r) code |= 1; // left
      else if (lambda > r) code |= 2; // right
      if (phi < -r) code |= 4; // below
      else if (phi > r) code |= 8; // above
      return code;
    }

    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
  }

  function clipLine(a, b, x0, y0, x1, y1) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1],
        t0 = 0,
        t1 = 1,
        dx = bx - ax,
        dy = by - ay,
        r;

    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  var clipMax = 1e9, clipMin = -clipMax;

  // TODO Use d3-polygon’s polygonContains here for the ring check?
  // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

  function clipRectangle(x0, y0, x1, y1) {

    function visible(x, y) {
      return x0 <= x && x <= x1 && y0 <= y && y <= y1;
    }

    function interpolate(from, to, direction, stream) {
      var a = 0, a1 = 0;
      if (from == null
          || (a = corner(from, direction)) !== (a1 = corner(to, direction))
          || comparePoint(from, to) < 0 ^ direction > 0) {
        do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
        while ((a = (a + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function corner(p, direction) {
      return abs(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
          : abs(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
          : abs(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
          : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
    }

    function compareIntersection(a, b) {
      return comparePoint(a.x, b.x);
    }

    function comparePoint(a, b) {
      var ca = corner(a, 1),
          cb = corner(b, 1);
      return ca !== cb ? ca - cb
          : ca === 0 ? b[1] - a[1]
          : ca === 1 ? a[0] - b[0]
          : ca === 2 ? a[1] - b[1]
          : b[0] - a[0];
    }

    return function(stream) {
      var activeStream = stream,
          bufferStream = clipBuffer(),
          segments,
          polygon,
          ring,
          x__, y__, v__, // first point
          x_, y_, v_, // previous point
          first,
          clean;

      var clipStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: polygonStart,
        polygonEnd: polygonEnd
      };

      function point(x, y) {
        if (visible(x, y)) activeStream.point(x, y);
      }

      function polygonInside() {
        var winding = 0;

        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
            if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
            else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
          }
        }

        return winding;
      }

      // Buffer geometry within a polygon and then clip it en masse.
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }

      function polygonEnd() {
        var startInside = polygonInside(),
            cleanInside = clean && startInside,
            visible = (segments = merge(segments)).length;
        if (cleanInside || visible) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible) {
            clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }

      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }

      // TODO rather than special-case polygons, simply handle them separately.
      // Ideally, coincident intersection points should be jittered to avoid
      // clipping issues.
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point;
        if (v_) activeStream.lineEnd();
      }

      function linePoint(x, y) {
        var v = visible(x, y);
        if (polygon) ring.push([x, y]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
          }
        } else {
          if (v && v_) activeStream.point(x, y);
          else {
            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
            if (clipLine(a, b, x0, y0, x1, y1)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a[0], a[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }

      return clipStream;
    };
  }

  function graticuleX(y0, y1, dy) {
    var y = range(y0, y1 - epsilon$1, dy).concat(y1);
    return function(x) { return y.map(function(y) { return [x, y]; }); };
  }

  function graticuleY(x0, x1, dx) {
    var x = range(x0, x1 - epsilon$1, dx).concat(x1);
    return function(y) { return x.map(function(x) { return [x, y]; }); };
  }

  function graticule() {
    var x1, x0, X1, X0,
        y1, y0, Y1, Y0,
        dx = 10, dy = dx, DX = 90, DY = 360,
        x, y, X, Y,
        precision = 2.5;

    function graticule() {
      return {type: "MultiLineString", coordinates: lines()};
    }

    function lines() {
      return range(ceil(X0 / DX) * DX, X1, DX).map(X)
          .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
          .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$1; }).map(x))
          .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$1; }).map(y));
    }

    graticule.lines = function() {
      return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
    };

    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X(X0).concat(
          Y(Y1).slice(1),
          X(X1).reverse().slice(1),
          Y(Y0).reverse().slice(1))
        ]
      };
    };

    graticule.extent = function(_) {
      if (!arguments.length) return graticule.extentMinor();
      return graticule.extentMajor(_).extentMinor(_);
    };

    graticule.extentMajor = function(_) {
      if (!arguments.length) return [[X0, Y0], [X1, Y1]];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };

    graticule.extentMinor = function(_) {
      if (!arguments.length) return [[x0, y0], [x1, y1]];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };

    graticule.step = function(_) {
      if (!arguments.length) return graticule.stepMinor();
      return graticule.stepMajor(_).stepMinor(_);
    };

    graticule.stepMajor = function(_) {
      if (!arguments.length) return [DX, DY];
      DX = +_[0], DY = +_[1];
      return graticule;
    };

    graticule.stepMinor = function(_) {
      if (!arguments.length) return [dx, dy];
      dx = +_[0], dy = +_[1];
      return graticule;
    };

    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = graticuleX(y0, y1, 90);
      y = graticuleY(x0, x1, precision);
      X = graticuleX(Y0, Y1, 90);
      Y = graticuleY(X0, X1, precision);
      return graticule;
    };

    return graticule
        .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
        .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
  }

  function identity$4(x) {
    return x;
  }

  var areaSum = adder(),
      areaRingSum = adder(),
      x00,
      y00,
      x0,
      y0;

  var areaStream = {
    point: noop$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
      areaSum.add(abs(areaRingSum));
      areaRingSum.reset();
    },
    result: function() {
      var area = areaSum / 2;
      areaSum.reset();
      return area;
    }
  };

  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }

  function areaPointFirst(x, y) {
    areaStream.point = areaPoint;
    x00 = x0 = x, y00 = y0 = y;
  }

  function areaPoint(x, y) {
    areaRingSum.add(y0 * x - x0 * y);
    x0 = x, y0 = y;
  }

  function areaRingEnd() {
    areaPoint(x00, y00);
  }

  var x0$1 = Infinity,
      y0$1 = x0$1,
      x1 = -x0$1,
      y1 = x1;

  var boundsStream = {
    point: boundsPoint,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: noop$1,
    polygonEnd: noop$1,
    result: function() {
      var bounds = [[x0$1, y0$1], [x1, y1]];
      x1 = y1 = -(y0$1 = x0$1 = Infinity);
      return bounds;
    }
  };

  function boundsPoint(x, y) {
    if (x < x0$1) x0$1 = x;
    if (x > x1) x1 = x;
    if (y < y0$1) y0$1 = y;
    if (y > y1) y1 = y;
  }

  // TODO Enforce positive area for exterior, negative area for interior?

  var X0 = 0,
      Y0 = 0,
      Z0 = 0,
      X1 = 0,
      Y1 = 0,
      Z1 = 0,
      X2 = 0,
      Y2 = 0,
      Z2 = 0,
      x00$1,
      y00$1,
      x0$2,
      y0$2;

  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
          : Z1 ? [X1 / Z1, Y1 / Z1]
          : Z0 ? [X0 / Z0, Y0 / Z0]
          : [NaN, NaN];
      X0 = Y0 = Z0 =
      X1 = Y1 = Z1 =
      X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };

  function centroidPoint(x, y) {
    X0 += x;
    Y0 += y;
    ++Z0;
  }

  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }

  function centroidPointFirstLine(x, y) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidPointLine(x, y) {
    var dx = x - x0$2, dy = y - y0$2, z = sqrt(dx * dx + dy * dy);
    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }

  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }

  function centroidRingEnd() {
    centroidPointRing(x00$1, y00$1);
  }

  function centroidPointFirstRing(x, y) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
  }

  function centroidPointRing(x, y) {
    var dx = x - x0$2,
        dy = y - y0$2,
        z = sqrt(dx * dx + dy * dy);

    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;

    z = y0$2 * x - x0$2 * y;
    X2 += z * (x0$2 + x);
    Y2 += z * (y0$2 + y);
    Z2 += z * 3;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function PathContext(context) {
    this._context = context;
  }

  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x, y);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x, y);
          break;
        }
        default: {
          this._context.moveTo(x + this._radius, y);
          this._context.arc(x, y, this._radius, 0, tau$1);
          break;
        }
      }
    },
    result: noop$1
  };

  var lengthSum = adder(),
      lengthRing,
      x00$2,
      y00$2,
      x0$3,
      y0$3;

  var lengthStream = {
    point: noop$1,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x00$2, y00$2);
      lengthStream.point = noop$1;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length = +lengthSum;
      lengthSum.reset();
      return length;
    }
  };

  function lengthPointFirst(x, y) {
    lengthStream.point = lengthPoint;
    x00$2 = x0$3 = x, y00$2 = y0$3 = y;
  }

  function lengthPoint(x, y) {
    x0$3 -= x, y0$3 -= y;
    lengthSum.add(sqrt(x0$3 * x0$3 + y0$3 * y0$3));
    x0$3 = x, y0$3 = y;
  }

  function PathString() {
    this._string = [];
  }

  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._string.push("Z");
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x, ",", y);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x, ",", y);
          break;
        }
        default: {
          if (this._circle == null) this._circle = circle(this._radius);
          this._string.push("M", x, ",", y, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };

  function circle(radius) {
    return "m0," + radius
        + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
        + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
        + "z";
  }

  function geoPath(projection, context) {
    var pointRadius = 4.5,
        projectionStream,
        contextStream;

    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }

    path.area = function(object) {
      geoStream(object, projectionStream(areaStream));
      return areaStream.result();
    };

    path.measure = function(object) {
      geoStream(object, projectionStream(lengthStream));
      return lengthStream.result();
    };

    path.bounds = function(object) {
      geoStream(object, projectionStream(boundsStream));
      return boundsStream.result();
    };

    path.centroid = function(object) {
      geoStream(object, projectionStream(centroidStream));
      return centroidStream.result();
    };

    path.projection = function(_) {
      return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
    };

    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path;
    };

    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };

    return path.projection(projection).context(context);
  }

  function transformer$1(methods) {
    return function(stream) {
      var s = new TransformStream;
      for (var key in methods) s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }

  function TransformStream() {}

  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x, y) { this.stream.point(x, y); },
    sphere: function() { this.stream.sphere(); },
    lineStart: function() { this.stream.lineStart(); },
    lineEnd: function() { this.stream.lineEnd(); },
    polygonStart: function() { this.stream.polygonStart(); },
    polygonEnd: function() { this.stream.polygonEnd(); }
  };

  function fit(projection, fitBounds, object) {
    var clip = projection.clipExtent && projection.clipExtent();
    projection.scale(150).translate([0, 0]);
    if (clip != null) projection.clipExtent(null);
    geoStream(object, projection.stream(boundsStream));
    fitBounds(boundsStream.result());
    if (clip != null) projection.clipExtent(clip);
    return projection;
  }

  function fitExtent(projection, extent, object) {
    return fit(projection, function(b) {
      var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitSize(projection, size, object) {
    return fitExtent(projection, [[0, 0], size], object);
  }

  function fitWidth(projection, width, object) {
    return fit(projection, function(b) {
      var w = +width,
          k = w / (b[1][0] - b[0][0]),
          x = (w - k * (b[1][0] + b[0][0])) / 2,
          y = -k * b[0][1];
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitHeight(projection, height, object) {
    return fit(projection, function(b) {
      var h = +height,
          k = h / (b[1][1] - b[0][1]),
          x = -k * b[0][0],
          y = (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  var maxDepth = 16, // maximum depth of subdivision
      cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

  function resample(project, delta2) {
    return +delta2 ? resample$1(project, delta2) : resampleNone(project);
  }

  function resampleNone(project) {
    return transformer$1({
      point: function(x, y) {
        x = project(x, y);
        this.stream.point(x[0], x[1]);
      }
    });
  }

  function resample$1(project, delta2) {

    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0,
          dy = y1 - y0,
          d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a = a0 + a1,
            b = b0 + b1,
            c = c0 + c1,
            m = sqrt(a * a + b * b + c * c),
            phi2 = asin(c /= m),
            lambda2 = abs(abs(c) - 1) < epsilon$1 || abs(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2(b, a),
            p = project(lambda2, phi2),
            x2 = p[0],
            y2 = p[1],
            dx2 = x2 - x0,
            dy2 = y2 - y0,
            dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 // perpendicular projected distance
            || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
            || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x00, y00, a00, b00, c00, // first point
          lambda0, x0, y0, a0, b0, c0; // previous point

      var resampleStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
        polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
      };

      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }

      function lineStart() {
        x0 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }

      function linePoint(lambda, phi) {
        var c = cartesian([lambda, phi]), p = project(lambda, phi);
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }

      function lineEnd() {
        resampleStream.point = point;
        stream.lineEnd();
      }

      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }

      function ringPoint(lambda, phi) {
        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }

      function ringEnd() {
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }

      return resampleStream;
    };
  }

  var transformRadians = transformer$1({
    point: function(x, y) {
      this.stream.point(x * radians, y * radians);
    }
  });

  function transformRotate(rotate) {
    return transformer$1({
      point: function(x, y) {
        var r = rotate(x, y);
        return this.stream.point(r[0], r[1]);
      }
    });
  }

  function scaleTranslate(k, dx, dy, sx, sy) {
    function transform(x, y) {
      x *= sx; y *= sy;
      return [dx + k * x, dy - k * y];
    }
    transform.invert = function(x, y) {
      return [(x - dx) / k * sx, (dy - y) / k * sy];
    };
    return transform;
  }

  function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
    var cosAlpha = cos(alpha),
        sinAlpha = sin(alpha),
        a = cosAlpha * k,
        b = sinAlpha * k,
        ai = cosAlpha / k,
        bi = sinAlpha / k,
        ci = (sinAlpha * dy - cosAlpha * dx) / k,
        fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x, y) {
      x *= sx; y *= sy;
      return [a * x - b * y + dx, dy - b * x - a * y];
    }
    transform.invert = function(x, y) {
      return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
    };
    return transform;
  }

  function projection(project) {
    return projectionMutator(function() { return project; })();
  }

  function projectionMutator(projectAt) {
    var project,
        k = 150, // scale
        x = 480, y = 250, // translate
        lambda = 0, phi = 0, // center
        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
        alpha = 0, // post-rotate angle
        sx = 1, // reflectX
        sy = 1, // reflectX
        theta = null, preclip = clipAntimeridian, // pre-clip angle
        x0 = null, y0, x1, y1, postclip = identity$4, // post-clip extent
        delta2 = 0.5, // precision
        projectResample,
        projectTransform,
        projectRotateTransform,
        cache,
        cacheStream;

    function projection(point) {
      return projectRotateTransform(point[0] * radians, point[1] * radians);
    }

    function invert(point) {
      point = projectRotateTransform.invert(point[0], point[1]);
      return point && [point[0] * degrees$1, point[1] * degrees$1];
    }

    projection.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };

    projection.preclip = function(_) {
      return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
    };

    projection.postclip = function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };

    projection.clipAngle = function(_) {
      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
    };

    projection.clipExtent = function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    projection.scale = function(_) {
      return arguments.length ? (k = +_, recenter()) : k;
    };

    projection.translate = function(_) {
      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
    };

    projection.center = function(_) {
      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
    };

    projection.rotate = function(_) {
      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
    };

    projection.angle = function(_) {
      return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees$1;
    };

    projection.reflectX = function(_) {
      return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
    };

    projection.reflectY = function(_) {
      return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
    };

    projection.precision = function(_) {
      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
    };

    projection.fitExtent = function(extent, object) {
      return fitExtent(projection, extent, object);
    };

    projection.fitSize = function(size, object) {
      return fitSize(projection, size, object);
    };

    projection.fitWidth = function(width, object) {
      return fitWidth(projection, width, object);
    };

    projection.fitHeight = function(height, object) {
      return fitHeight(projection, height, object);
    };

    function recenter() {
      var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
          transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose(project, transform);
      projectRotateTransform = compose(rotate, projectTransform);
      projectResample = resample(projectTransform, delta2);
      return reset();
    }

    function reset() {
      cache = cacheStream = null;
      return projection;
    }

    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return recenter();
    };
  }

  function azimuthalInvert(angle) {
    return function(x, y) {
      var z = sqrt(x * x + y * y),
          c = angle(z),
          sc = sin(c),
          cc = cos(c);
      return [
        atan2(x * sc, z * cc),
        asin(z && y * sc / z)
      ];
    }
  }

  function orthographicRaw(x, y) {
    return [cos(y) * sin(x), sin(y)];
  }

  orthographicRaw.invert = azimuthalInvert(asin);

  function geoOrthographic() {
    return projection(orthographicRaw)
        .scale(249.5)
        .clipAngle(90 + epsilon$1);
  }

  var countries;
  var portugal;
  var projection$1;
  var path$1;
  var pathSvg;
  var sphere;
  var grid;
  var txScale;
  var tyScale;
  var sScale;
  var rScale;
  var gaScale;
  var aaScale;
  var point0;
  var point1;
  var point2; // Globe gradient colours.

  var colours$1 = [{
    colour: '#f4eee7',
    stop: 0.1
  }, {
    colour: '#e1dcd6',
    stop: 0.3
  }, {
    colour: '#cfcac5',
    stop: 0.4
  }, {
    colour: '#bcb9b4',
    stop: 0.5
  }, {
    colour: '#aaa7a4',
    stop: 0.6
  }, {
    colour: '#999794',
    stop: 0.7
  }, {
    colour: '#878684',
    stop: 0.8
  }, {
    colour: '#767675',
    stop: 0.9
  }, {
    colour: '#666666',
    stop: 1
  }]; // The center of the world (Northern Portugal in our case).

  var rBase = [8, -42, 0]; // Values for the gradient. // 1

  var gradientCentrePoint = [-30, 40];
  var gradientEdgePoint = [-60, 40];
  var gradientValues;
  /**
   * Calculates the distance between two [lon, lat] points
   * in pixel, given a projection.
   * @param { 2d array } pStart The start point for the distance calc
   * @param { 2d array } pEnd The end point for the distance calc
   * @param { function } proj The projection
   * @returns { object } Star, end point as well as distance in pixel.
   */

  function getPixelDistance(pStart, pEnd, proj) {
    var pStartPx = proj(pStart);
    var pEndPx = proj(pEnd);
    var distVector = [pEndPx[0] - pStartPx[0], pEndPx[1] - pStartPx[1]];
    var distance = Math.sqrt(Math.pow(distVector[0], 2) + Math.pow(distVector[1], 2));
    return {
      start: pStartPx,
      end: pEndPx,
      distance: distance
    };
  }

  function drawGlobe(ctx) {
    var rough = state.rough.globe;
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.globalAlpha = gaScale(state.globe.scroll.progress); // Set the globe's radial gradient.

    var grad = ctx.createRadialGradient(0, 0, gradientValues.distance, 0, 0, gradientValues.distance * 6); // Add colour steps.

    colours$1.forEach(function (d) {
      return grad.addColorStop(d.stop, d.colour);
    });
    ctx.fillStyle = grad;
    ctx.beginPath(), path$1(sphere), ctx.fill();
    ctx.lineWidth = 0.05;
    ctx.strokeStyle = '#000000';
    ctx.beginPath(), path$1(grid), ctx.stroke();
    ctx.lineWidth = 0.5;
    ctx.beginPath(), path$1(countries), ctx.stroke();
    ctx.fillStyle = '#ff00ff';
    rough.path(pathSvg(portugal), {
      fill: state.bottleColour.bad.stop1,
      stroke: state.bottleColour.bad.stop1
    }); // Label and arrow.

    ctx.globalAlpha = aaScale(state.globe.scroll.progress);
    ctx.fillStyle = state.bottleColour.bad.stop0;
    ctx.font = 'bold 30px Amatic SC';
    ctx.textAlign = 'end';
    ctx.textBaseline = 'top';
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    ctx.shadowBlur = 4;
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.fillText('Portugal', point2.x, point2.y + 10);
    ctx.lineWidth = 5;
    ctx.strokeStyle = state.bottleColour.bad.stop0;
    bezWithArrowheads(ctx, point0, point1, point2, undefined, 15, false, true);
    ctx.restore();
  }

  function renderGlobe() {
    // Set the projection tranform.
    projection$1.translate([txScale(state.globe.scroll.progress), tyScale(state.globe.scroll.progress)]);
    projection$1.scale(sScale(state.globe.scroll.progress));
    var r = rScale(state.globe.scroll.progress);
    projection$1.rotate([rBase[0] + r, rBase[1] + r, rBase[2]]); // Radial gradient parameters.

    gradientValues = getPixelDistance(gradientCentrePoint, gradientEdgePoint, projection$1); // Arrow control point.

    point1 = projection$1([-20, 43]);
    point1 = {
      x: point1[0],
      y: point1[1]
    }; // Arrow end point.

    point2 = projection$1([-10, 41]);
    point2 = {
      x: point2[0],
      y: point2[1]
    }; // Start the render.

    requestAnimationFrame(function () {
      return drawGlobe(state.ctx.globe);
    });
  }

  function prepData$1() {
    // Convert from topo to geoJSON.
    countries = feature(state.globe.data, state.globe.data.objects.ne_110m_admin_0_countries);

    var _countries$features$f = countries.features.filter(function (d) {
      return d.properties.admin === 'Portugal';
    });

    var _countries$features$f2 = _slicedToArray(_countries$features$f, 1);

    portugal = _countries$features$f2[0];
    // Arrow control point 0.
    point0 = {
      x: state.width * 0.35,
      y: state.height * 0.45
    };
  }

  function prepGeoTools() {
    projection$1 = geoOrthographic().fitSize([state.width, state.height], countries);
    path$1 = geoPath().projection(projection$1).context(state.ctx.globe);
    pathSvg = geoPath().projection(projection$1);
    sphere = {
      type: 'Sphere'
    };
    grid = graticule()();
  }

  function prepScales() {
    // Translate scales.
    txScale = linear$1().domain([0, 0.5]).range([state.width * 0.3, state.width * 0.5]);
    tyScale = linear$1().domain([0, 0.3, 0.7, 1]).range([state.height * 0.2, state.height * 0.5, state.height * 0.475, state.height * 0.2]); // The scale scale.

    var sInit = projection$1.scale();
    sScale = linear$1().domain([0, 0.3, 0.7, 1]).range([sInit, sInit * 2, sInit * 2, 0]); // The globe rotation scale.

    rScale = linear$1().domain([0, 0.3, 0.7, 1]).range([-50, -1, 1, 100]); // The globe's globalAlpha scale.

    gaScale = linear$1().domain([0, 0.1, 0.9, 1]).range([0, 1, 1, 0]); // The arrow's globalAlpha scale.

    aaScale = linear$1().domain([0, 0.3, 0.35, 0.65, 0.7, 1]).range([0, 0, 1, 1, 0, 0]);
  }

  function defineTweenGlobe() {
    prepData$1();
    prepGeoTools();
    prepScales();
    var tl = gsapWithCSS.timeline({
      onUpdate: renderGlobe
    }); // Bonkers tween to make timeline work. We could work straight
    // off ScrollTrigger, but this is more in tune with the rest.

    var blub = gsapWithCSS.to({
      bar: 0
    }, {
      bar: 1
    });
    return tl.add(blub);
  }

  function tweenGlobe() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('globe');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.globe) state.tween.globe.kill();
    state.tween.globe = defineTweenGlobe();
    state.tween.globe.totalProgress(progress);
  }
  //    whose centre remains on the transformed earth, which culminated in the
  //    `getPixelDistance` function. Only to find by accident that setting
  //    a radial gradient simply at (0, 0) looks in fact better. The distance
  //    is still being used though - although this could be solved with a
  //    simple linear scale synced with the scale-scale.

  function constant$5(x) {
    return function() {
      return x;
    };
  }

  function jiggle() {
    return (Math.random() - 0.5) * 1e-6;
  }

  function tree_add(d) {
    var x = +this._x.call(null, d),
        y = +this._y.call(null, d);
    return add$1(this.cover(x, y), x, y, d);
  }

  function add$1(tree, x, y, d) {
    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

    var parent,
        node = tree._root,
        leaf = {data: d},
        x0 = tree._x0,
        y0 = tree._y0,
        x1 = tree._x1,
        y1 = tree._y1,
        xm,
        ym,
        xp,
        yp,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return tree._root = leaf, tree;

    // Find the existing leaf for the new point, or add it.
    while (node.length) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
    }

    // Is the new point is exactly coincident with the existing point?
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

    // Otherwise, split the leaf node until the old and new point are separated.
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
    return parent[j] = node, parent[i] = leaf, tree;
  }

  function addAll(data) {
    var d, i, n = data.length,
        x,
        y,
        xz = new Array(n),
        yz = new Array(n),
        x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    // Compute the points and their extent.
    for (i = 0; i < n; ++i) {
      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
      xz[i] = x;
      yz[i] = y;
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    // If there were no (valid) points, abort.
    if (x0 > x1 || y0 > y1) return this;

    // Expand the tree to cover the new points.
    this.cover(x0, y0).cover(x1, y1);

    // Add the new points.
    for (i = 0; i < n; ++i) {
      add$1(this, xz[i], yz[i], data[i]);
    }

    return this;
  }

  function tree_cover(x, y) {
    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

    var x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1;

    // If the quadtree has no extent, initialize them.
    // Integer extent are necessary so that if we later double the extent,
    // the existing quadrant boundaries don’t change due to floating point error!
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x)) + 1;
      y1 = (y0 = Math.floor(y)) + 1;
    }

    // Otherwise, double repeatedly to cover.
    else {
      var z = x1 - x0,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | (x < x0);
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0: x1 = x0 + z, y1 = y0 + z; break;
          case 1: x0 = x1 - z, y1 = y0 + z; break;
          case 2: x1 = x0 + z, y0 = y1 - z; break;
          case 3: x0 = x1 - z, y0 = y1 - z; break;
        }
      }

      if (this._root && this._root.length) this._root = node;
    }

    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  function tree_data() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) do data.push(node.data); while (node = node.next)
    });
    return data;
  }

  function tree_extent(_) {
    return arguments.length
        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  function Quad(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  function tree_find(x, y, radius) {
    var data,
        x0 = this._x0,
        y0 = this._y0,
        x1,
        y1,
        x2,
        y2,
        x3 = this._x1,
        y3 = this._y1,
        quads = [],
        node = this._root,
        q,
        i;

    if (node) quads.push(new Quad(node, x0, y0, x3, y3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x - radius, y0 = y - radius;
      x3 = x + radius, y3 = y + radius;
      radius *= radius;
    }

    while (q = quads.pop()) {

      // Stop searching if this quadrant can’t contain a closer node.
      if (!(node = q.node)
          || (x1 = q.x0) > x3
          || (y1 = q.y0) > y3
          || (x2 = q.x1) < x0
          || (y2 = q.y1) < y0) continue;

      // Bisect the current quadrant.
      if (node.length) {
        var xm = (x1 + x2) / 2,
            ym = (y1 + y2) / 2;

        quads.push(
          new Quad(node[3], xm, ym, x2, y2),
          new Quad(node[2], x1, ym, xm, y2),
          new Quad(node[1], xm, y1, x2, ym),
          new Quad(node[0], x1, y1, xm, ym)
        );

        // Visit the closest quadrant first.
        if (i = (y >= ym) << 1 | (x >= xm)) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      }

      // Visit this point. (Visiting coincident points isn’t necessary!)
      else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
    }

    return data;
  }

  function tree_remove(d) {
    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

    var parent,
        node = this._root,
        retainer,
        previous,
        next,
        x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1,
        x,
        y,
        xm,
        ym,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return this;

    // Find the leaf node for the point.
    // While descending, also retain the deepest parent with a non-removed sibling.
    if (node.length) while (true) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
    }

    // Find the point to remove.
    while (node.data !== d) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;

    // If there are multiple coincident points, remove just the point.
    if (previous) return (next ? previous.next = next : delete previous.next), this;

    // If this is the root point, remove it.
    if (!parent) return this._root = next, this;

    // Remove this leaf.
    next ? parent[i] = next : delete parent[i];

    // If the parent now contains exactly one leaf, collapse superfluous parents.
    if ((node = parent[0] || parent[1] || parent[2] || parent[3])
        && node === (parent[3] || parent[2] || parent[1] || parent[0])
        && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }

    return this;
  }

  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
    return this;
  }

  function tree_root() {
    return this._root;
  }

  function tree_size() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) do ++size; while (node = node.next)
    });
    return size;
  }

  function tree_visit(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      }
    }
    return this;
  }

  function tree_visitAfter(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  function defaultX(d) {
    return d[0];
  }

  function tree_x(_) {
    return arguments.length ? (this._x = _, this) : this._x;
  }

  function defaultY(d) {
    return d[1];
  }

  function tree_y(_) {
    return arguments.length ? (this._y = _, this) : this._y;
  }

  function quadtree(nodes, x, y) {
    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }

  function Quadtree(x, y, x0, y0, x1, y1) {
    this._x = x;
    this._y = y;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = undefined;
  }

  function leaf_copy(leaf) {
    var copy = {data: leaf.data}, next = copy;
    while (leaf = leaf.next) next = next.next = {data: leaf.data};
    return copy;
  }

  var treeProto = quadtree.prototype = Quadtree.prototype;

  treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
        node = this._root,
        nodes,
        child;

    if (!node) return copy;

    if (!node.length) return copy._root = leaf_copy(node), copy;

    nodes = [{source: node, target: copy._root = new Array(4)}];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
          else node.target[i] = leaf_copy(child);
        }
      }
    }

    return copy;
  };

  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;

  function index(d) {
    return d.index;
  }

  function find(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("missing: " + nodeId);
    return node;
  }

  function forceLink(links) {
    var id = index,
        strength = defaultStrength,
        strengths,
        distance = constant$5(30),
        distances,
        nodes,
        count,
        bias,
        iterations = 1;

    if (links == null) links = [];

    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }

    function force(alpha) {
      for (var k = 0, n = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
          link = links[i], source = link.source, target = link.target;
          x = target.x + target.vx - source.x - source.vx || jiggle();
          y = target.y + target.vy - source.y - source.vy || jiggle();
          l = Math.sqrt(x * x + y * y);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x *= l, y *= l;
          target.vx -= x * (b = bias[i]);
          target.vy -= y * b;
          source.vx += x * (b = 1 - b);
          source.vy += y * b;
        }
      }
    }

    function initialize() {
      if (!nodes) return;

      var i,
          n = nodes.length,
          m = links.length,
          nodeById = map(nodes, id),
          link;

      for (i = 0, count = new Array(n); i < m; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object") link.source = find(nodeById, link.source);
        if (typeof link.target !== "object") link.target = find(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }

      for (i = 0, bias = new Array(m); i < m; ++i) {
        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }

      strengths = new Array(m), initializeStrength();
      distances = new Array(m), initializeDistance();
    }

    function initializeStrength() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }

    function initializeDistance() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.links = function(_) {
      return arguments.length ? (links = _, initialize(), force) : links;
    };

    force.id = function(_) {
      return arguments.length ? (id = _, force) : id;
    };

    force.iterations = function(_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initializeStrength(), force) : strength;
    };

    force.distance = function(_) {
      return arguments.length ? (distance = typeof _ === "function" ? _ : constant$5(+_), initializeDistance(), force) : distance;
    };

    return force;
  }

  var frame$2 = 0, // is an animation frame pending?
      timeout$4 = 0, // is a timeout pending?
      interval$2 = 0, // are any timers active?
      pokeDelay$2 = 1000, // how frequently we check for clock skew
      taskHead$2,
      taskTail$2,
      clockLast$2 = 0,
      clockNow$2 = 0,
      clockSkew$2 = 0,
      clock$2 = typeof performance === "object" && performance.now ? performance : Date,
      setFrame$2 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

  function now$3() {
    return clockNow$2 || (setFrame$2(clearNow$2), clockNow$2 = clock$2.now() + clockSkew$2);
  }

  function clearNow$2() {
    clockNow$2 = 0;
  }

  function Timer$2() {
    this._call =
    this._time =
    this._next = null;
  }

  Timer$2.prototype = timer$2.prototype = {
    constructor: Timer$2,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now$3() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail$2 !== this) {
        if (taskTail$2) taskTail$2._next = this;
        else taskHead$2 = this;
        taskTail$2 = this;
      }
      this._call = callback;
      this._time = time;
      sleep$2();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep$2();
      }
    }
  };

  function timer$2(callback, delay, time) {
    var t = new Timer$2;
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush$2() {
    now$3(); // Get the current time, if not already set.
    ++frame$2; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead$2, e;
    while (t) {
      if ((e = clockNow$2 - t._time) >= 0) t._call.call(null, e);
      t = t._next;
    }
    --frame$2;
  }

  function wake$2() {
    clockNow$2 = (clockLast$2 = clock$2.now()) + clockSkew$2;
    frame$2 = timeout$4 = 0;
    try {
      timerFlush$2();
    } finally {
      frame$2 = 0;
      nap$2();
      clockNow$2 = 0;
    }
  }

  function poke$2() {
    var now = clock$2.now(), delay = now - clockLast$2;
    if (delay > pokeDelay$2) clockSkew$2 -= delay, clockLast$2 = now;
  }

  function nap$2() {
    var t0, t1 = taskHead$2, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead$2 = t2;
      }
    }
    taskTail$2 = t0;
    sleep$2(time);
  }

  function sleep$2(time) {
    if (frame$2) return; // Soonest alarm already set, or will be.
    if (timeout$4) timeout$4 = clearTimeout(timeout$4);
    var delay = time - clockNow$2; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
      if (time < Infinity) timeout$4 = setTimeout(wake$2, time - clock$2.now() - clockSkew$2);
      if (interval$2) interval$2 = clearInterval(interval$2);
    } else {
      if (!interval$2) clockLast$2 = clock$2.now(), interval$2 = setInterval(poke$2, pokeDelay$2);
      frame$2 = 1, setFrame$2(wake$2);
    }
  }

  function x$2(d) {
    return d.x;
  }

  function y$2(d) {
    return d.y;
  }

  var initialRadius = 10,
      initialAngle = Math.PI * (3 - Math.sqrt(5));

  function forceSimulation(nodes) {
    var simulation,
        alpha = 1,
        alphaMin = 0.001,
        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
        alphaTarget = 0,
        velocityDecay = 0.6,
        forces = map(),
        stepper = timer$2(step),
        event = dispatch("tick", "end");

    if (nodes == null) nodes = [];

    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }

    function tick(iterations) {
      var i, n = nodes.length, node;

      if (iterations === undefined) iterations = 1;

      for (var k = 0; k < iterations; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;

        forces.each(function (force) {
          force(alpha);
        });

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }

      return simulation;
    }

    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
          node.x = radius * Math.cos(angle);
          node.y = radius * Math.sin(angle);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }

    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes);
      return force;
    }

    initializeNodes();

    return simulation = {
      tick: tick,

      restart: function() {
        return stepper.restart(step), simulation;
      },

      stop: function() {
        return stepper.stop(), simulation;
      },

      nodes: function(_) {
        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
      },

      alpha: function(_) {
        return arguments.length ? (alpha = +_, simulation) : alpha;
      },

      alphaMin: function(_) {
        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
      },

      alphaDecay: function(_) {
        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
      },

      alphaTarget: function(_) {
        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
      },

      velocityDecay: function(_) {
        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
      },

      force: function(name, _) {
        return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
      },

      find: function(x, y, radius) {
        var i = 0,
            n = nodes.length,
            dx,
            dy,
            d2,
            node,
            closest;

        if (radius == null) radius = Infinity;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x - node.x;
          dy = y - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest = node, radius = d2;
        }

        return closest;
      },

      on: function(name, _) {
        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
      }
    };
  }

  function forceManyBody() {
    var nodes,
        node,
        alpha,
        strength = constant$5(-30),
        strengths,
        distanceMin2 = 1,
        distanceMax2 = Infinity,
        theta2 = 0.81;

    function force(_) {
      var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node;
      strengths = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
    }

    function accumulate(quad) {
      var strength = 0, q, c, weight = 0, x, y, i;

      // For internal nodes, accumulate forces from child quadrants.
      if (quad.length) {
        for (x = y = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c = Math.abs(q.value))) {
            strength += q.value, weight += c, x += c * q.x, y += c * q.y;
          }
        }
        quad.x = x / weight;
        quad.y = y / weight;
      }

      // For leaf nodes, accumulate forces from coincident quadrants.
      else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do strength += strengths[q.data.index];
        while (q = q.next);
      }

      quad.value = strength;
    }

    function apply(quad, x1, _, x2) {
      if (!quad.value) return true;

      var x = quad.x - node.x,
          y = quad.y - node.y,
          w = x2 - x1,
          l = x * x + y * y;

      // Apply the Barnes-Hut approximation if possible.
      // Limit forces for very close nodes; randomize direction if coincident.
      if (w * w / theta2 < l) {
        if (l < distanceMax2) {
          if (x === 0) x = jiggle(), l += x * x;
          if (y === 0) y = jiggle(), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
          node.vx += x * quad.value * alpha / l;
          node.vy += y * quad.value * alpha / l;
        }
        return true;
      }

      // Otherwise, process points directly.
      else if (quad.length || l >= distanceMax2) return;

      // Limit forces for very close nodes; randomize direction if coincident.
      if (quad.data !== node || quad.next) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
      }

      do if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x * w;
        node.vy += y * w;
      } while (quad = quad.next);
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
    };

    force.distanceMin = function(_) {
      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
    };

    force.distanceMax = function(_) {
      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
    };

    force.theta = function(_) {
      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
    };

    return force;
  }

  function forceX(x) {
    var strength = constant$5(0.1),
        nodes,
        strengths,
        xz;

    if (typeof x !== "function") x = constant$5(x == null ? 0 : +x);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
    };

    force.x = function(_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : x;
    };

    return force;
  }

  function forceY(y) {
    var strength = constant$5(0.1),
        nodes,
        strengths,
        yz;

    if (typeof y !== "function") y = constant$5(y == null ? 0 : +y);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function(_) {
      nodes = _;
      initialize();
    };

    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
    };

    force.y = function(_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : y;
    };

    return force;
  }

  /**
   * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
   * is a simple way to find a fitted line
   * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
   * using the least sum of squares.
   *
   * @param {Array<Array<number>>} data an array of two-element of arrays,
   * like `[[0, 1], [2, 3]]`
   * @returns {Object} object containing slope and intersect of regression line
   * @example
   * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
   */
  function linearRegression(data) {
      var m, b;

      // Store data length in a local variable to reduce
      // repeated object property lookups
      var dataLength = data.length;

      //if there's only one point, arbitrarily choose a slope of 0
      //and a y-intercept of whatever the y of the initial point is
      if (dataLength === 1) {
          m = 0;
          b = data[0][1];
      } else {
          // Initialize our sums and scope the `m` and `b`
          // variables that define the line.
          var sumX = 0,
              sumY = 0,
              sumXX = 0,
              sumXY = 0;

          // Use local variables to grab point values
          // with minimal object property lookups
          var point, x, y;

          // Gather the sum of all x values, the sum of all
          // y values, and the sum of x^2 and (x*y) for each
          // value.
          //
          // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
          for (var i = 0; i < dataLength; i++) {
              point = data[i];
              x = point[0];
              y = point[1];

              sumX += x;
              sumY += y;

              sumXX += x * x;
              sumXY += x * y;
          }

          // `m` is the slope of the regression line
          m =
              (dataLength * sumXY - sumX * sumY) /
              (dataLength * sumXX - sumX * sumX);

          // `b` is the y-intercept of the line.
          b = sumY / dataLength - (m * sumX) / dataLength;
      }

      // Return both values as an object.
      return {
          m: m,
          b: b
      };
  }

  /**
   * Given the output of `linearRegression`: an object
   * with `m` and `b` values indicating slope and intercept,
   * respectively, generate a line function that translates
   * x values into y values.
   *
   * @param {Object} mb object with `m` and `b` members, representing
   * slope and intersect of desired line
   * @returns {Function} method that computes y-value at any given
   * x-value on the line.
   * @example
   * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
   * l(0) // = 0
   * l(2) // = 2
   * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
   * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
   */
  function linearRegressionLine(mb /*: { b: number, m: number }*/) {
      // Return a function that computes a `y` value for each
      // x value it is given, based on the values of `b` and `a`
      // that we just computed.
      return function (x) {
          return mb.b + mb.m * x;
      };
  }

  /* eslint-disable no-return-assign */
  /**
   * Build sensible bin values (with d3's tick func),
   * return a snap function that snaps continuous
   * values to these bin centres.
   * Also return a scale for the snapped values.
   */

  function getXScaleTools(data, variable) {
    var domain = extent(data, function (d) {
      return d[variable];
    });
    var tickArray = ticks(domain[0], domain[1], 12);
    var scale = point$1().domain(tickArray);

    function snap(number) {
      return tickArray.reduce(function (a, b) {
        return Math.abs(b - number) < Math.abs(a - number) ? b : a;
      });
    }

    return {
      scale: scale,
      snap: snap
    };
  }
  /**
   * Nest by the snapped x values,
   * enumerate each value per group from 0 to max in the group,
   * scale each value from 0 to 1,
   * return a map by id to let the user combine this data in the app.
   */


  function getYValueMap(data, variable, snap) {
    // Split and Apply... (Combine happens in the main func).
    var nested = nest().key(function (d) {
      return snap(d[variable]);
    }).rollup(function (v) {
      return v.map(function (d, i) {
        return {
          id: d.id,
          y: i
        };
      });
    }).entries(data); // Unnest the results...

    var unnested = nested.map(function (d) {
      return d.value;
    });
    var flattened = [].concat.apply([], unnested); // Scale y values to [0, 1].

    var yScale = linear$1().domain(extent(flattened, function (d) {
      return d.y;
    })); // Get a map of values by the data's id variable.

    var flatMap = nest().key(function (d) {
      return d.id;
    }).rollup(function (v) {
      return yScale(v[0].y);
    }).map(flattened);
    return flatMap;
  }

  function frequency() {
    var variable; // The data variable.

    var id = 'id'; // The unique numerical row identifier variable.

    function layout(data) {
      // xValues.
      var xTools = getXScaleTools(data, variable);
      var yMap = getYValueMap(data, variable, xTools.snap); // Get the layout in an array.

      var result = data.map(function (d) {
        return {
          id: d[id],
          x: xTools.scale(xTools.snap(d[variable])),
          y: yMap.get(d[id]),
          value: xTools.snap(d[variable])
        };
      }); // Get the layout in a map by `id` which needs to be in
      // the dataset this layout gets joined by.

      var resultMap = nest().key(function (d) {
        return d[id];
      }).rollup(function (v) {
        return {
          x: v[0].x,
          y: v[0].y,
          value: v[0].value
        };
      }).map(result);
      return resultMap;
    }

    layout.variable = function (_) {
      return _ ? (variable = _, layout) : variable;
    };

    layout.id = function (_) {
      return _ ? (id = _, layout) : id;
    };

    return layout;
  }

  /* eslint-disable no-param-reassign */
  // the bottom. Not on all points as the shape might be wavey. We do this here...

  function focus(leaves, axis) {
    // Sort the node leaves descendingly by their y position for
    // the x axis and by their x position for the y axis labels.
    return axis === 'x' ? leaves.sort(function (a, b) {
      return b.y - a.y;
    }).filter(function (_, i) {
      return i < 10;
    }) : leaves.sort(function (a, b) {
      return b.x - a.x;
    }).filter(function (_, i) {
      return i < 10;
    });
  } // Values for an x axis.


  function xAxisValues(values, key, ax, p) {
    return {
      x: median(focus(values, ax), function (d) {
        return d.x;
      }),
      y: max(values, function (d) {
        return d.y;
      }) + p,
      xRange: extent(values, function (d) {
        return d.x;
      }),
      yRange: extent(values, function (d) {
        return d.y;
      }),
      zigzag: String(median(values, key)).length > 3 // 1

    };
  } // Values for a y axis.


  function yAxisValues(values, key, ax, p) {
    return {
      x: max(values, function (d) {
        return d.x;
      }) + p,
      y: median(focus(values, ax), function (d) {
        return d.y;
      }),
      xRange: extent(values, function (d) {
        return d.x;
      }),
      yRange: extent(values, function (d) {
        return d.y;
      }),
      zigzag: String(median(values, key)).length > 3
    };
  }

  function labels() {
    var nestKey;
    var axis = 'x';
    var align = false;
    var padding = 10;

    function layout(data) {
      // Label positions for each variable category.
      var ticks = nest().key(nestKey).rollup(function (v) {
        if (axis === 'x') return xAxisValues(v, nestKey, axis, padding);
        if (axis === 'y') return yAxisValues(v, nestKey, axis, padding);
        throw Error('Label axis parameter needs to be x or y');
      }).entries(data).sort(function (a, b) {
        return +a.key - +b.key;
      }); // Bounding box of the variable's point cloud.

      var bbox = {
        xMin: min(ticks, function (d) {
          return d.value.xRange[0];
        }),
        xMax: max(ticks, function (d) {
          return d.value.xRange[1];
        }),
        yMin: min(ticks, function (d) {
          return d.value.yRange[0];
        }),
        yMax: max(ticks, function (d) {
          return d.value.yRange[1];
        })
      }; // If align is true, we correct/align the labels' cross axis position.

      if (align && axis === 'x') {
        ticks.forEach(function (tick) {
          return tick.value.y = bbox.yMax + padding;
        });
      }

      if (align && axis === 'y') {
        ticks.forEach(function (tick) {
          return tick.value.x = bbox.xMax + padding;
        });
      } // Get heading or axis label positions.


      var yMinTick = ticks.filter(function (d) {
        return d.value.yRange[0] === bbox.yMin;
      })[0];
      var label = {};
      label.header = {
        x: yMinTick.value.x,
        y: bbox.yMin
      };
      label.axisLabel = axis === 'x' ? {
        x: ticks[0].value.x,
        y: ticks[0].value.y + padding
      } : {
        x: ticks[ticks.length - 1].value.x,
        y: ticks[ticks.length - 1].value.y - padding * 1.5
      }; // Return the info.

      return {
        ticks: ticks,
        bbox: bbox,
        label: label
      };
    } // Getters/setters.


    layout.nestKey = function (_) {
      return _ ? (nestKey = _, layout) : nestKey;
    };

    layout.axis = function (_) {
      return _ ? (axis = _, layout) : axis;
    };

    layout.padding = function (_) {
      return _ ? (padding = _, layout) : padding;
    }; // Special treatment for boolean getter/setter:


    layout.align = function (_) {
      return _ !== undefined || _ !== null ? (align = _, layout) : align;
    };

    return layout;
  }
   // 1.  if labels are longer than 3 than we should arrange them in zig zag.

  /* eslint-disable no-prototype-builtins */

  var dotRadius = 1.5;
  var dot;
  var dotGood;
  var dotBad;
  var margin$1;
  var xScale$1;
  var yScale$1;
  var sim;
  var tickPadding = 20;
  var yLabelAlign = 'left'; // Regression line data.

  var lrLine;
  var start$1 = [];
  var end = [];
  var cp1 = [];
  var cp2 = [];
  var length;
  var offset; // Point on regression line data.

  var pointStart = [];
  var point$3 = [];
  var pointEnd = [];
  var pointRadius;
  var pointAlpha; // Utils

  function tweenStatsAlpha(value) {
    var dur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    gsap.to(state.stats.alpha, {
      value: value,
      duration: dur
    });
  } // Scales and Data
  // ---------------


  function getScales() {
    yLabelAlign = isMobile() ? 'center' : 'left';
    var horzFactor = isMobile() ? 0.32 : 0.3;
    var vertFactor = isMobile() ? 0.32 : 0.3;
    margin$1 = {
      top: state.height * 0.3,
      right: state.width * vertFactor,
      bottom: state.height * horzFactor,
      left: state.width * 0.3
    };
    xScale$1 = linear$1().range([margin$1.left, state.width - margin$1.right]);
    yScale$1 = linear$1().range([state.height - margin$1.bottom, margin$1.top]);
  } // At each tick, this returns an object with the x and y position
  // for each label as well as their text value.


  function getLabelCoordinates() {
    if (!state.stats.current.length) return; // Get the tick values, the cloud's bounding box and the label positions.

    state.stats.current.forEach(function (el) {
      var name = el.name,
          axis = el.axis,
          straight = el.straight;
      var labelLayout = labels().nestKey(function (d) {
        return d.layout[name].value;
      }).axis(axis).padding(tickPadding).align(straight)(state.stats.data); // Add layout to the current variable object.

      el.labelLayout = labelLayout;
    });
  } // Draw Line functions


  function getLinearLine(xRange) {
    // Calculate the line function.
    var lrInput = state.stats.data.map(function (d) {
      return [d.x, d.y];
    });
    var lr = linearRegression(lrInput);
    lrLine = linearRegressionLine(lr); // Calculate the length and offset and save the
    // variables for the draw func in module scope.

    start$1 = [xRange[0], lrLine(xRange[0])];
    cp1 = start$1.slice();
    end = [xRange[1], lrLine(xRange[1])];
    cp2 = end.slice();
    length = euclideanDistance(start$1, end);
    offset = (1 - state.stats.progress.draw) * length;
  }

  function getLinearLineExtension(xRange) {
    var extension = state.stats.progress.extend * (xRange[1] - xRange[0]);
    start$1 = [xRange[0] - extension, lrLine(xRange[0] - extension)];
    cp1 = start$1.slice();
    end = [xRange[1] + extension, lrLine(xRange[1] + extension)];
    cp2 = end.slice();
    length = euclideanDistance(start$1, end);
    offset = (1 - state.stats.progress.draw) * length;
  }

  function getLogisticLine(xRange) {
    // Need this to get the exact y positions.
    var yAxisValues = state.stats.current.filter(function (d) {
      return d.axis === 'y';
    }); // Run it only if stars align.
    // We might want to probably also condition this on progress.logistic being > 0

    if (!yAxisValues.length || !yAxisValues[0].labelLayout) return; // How to debug:
    // if (state.stats.progress.logistic > 0) debugger;
    // Get the exact x and y position is a bit of a song and dance.
    // Basically, we need the tick values from the labels for
    // the axes positions we'll use as logistic start and end curve points.

    var yTicks = yAxisValues[0].labelLayout.ticks;
    var yValues = [yTicks[0].value.y, yTicks[1].value.y];
    var startDest = [state.stats.current[0].labelLayout.bbox.xMin - 10, yValues[0]];
    var endDest = [state.stats.current[0].labelLayout.bbox.xMax + 10, yValues[1]]; // The control points are fractions of the xRange distance.

    var cp1xDest = xRange[0] + (xRange[1] - xRange[0]) * 0.8;
    var cp2xDest = xRange[0] + (xRange[1] - xRange[0]) * 0.5; // Interpolating (could use gsap here, but that would require state and stuff..)

    start$1[0] += state.stats.progress.logistic * (startDest[0] - start$1[0]);
    start$1[1] += state.stats.progress.logistic * (startDest[1] - start$1[1]);
    end[0] += state.stats.progress.logistic * (endDest[0] - end[0]);
    end[1] += state.stats.progress.logistic * (endDest[1] - end[1]);
    cp1[1] = start$1[1];
    cp2[1] = end[1];
    cp1[0] += state.stats.progress.logistic * (cp1xDest - cp1[0]);
    cp2[0] += state.stats.progress.logistic * (cp2xDest - cp2[0]);
  } // Calculates the regression lines.


  function getLineDrawingParams() {
    // Only do all this work, when we want to show the regression line.
    if (!state.stats.lr) return; // The points x ranges (not the layout, the actual simulated points in px)
    // help calculate the x, y positions of the linear regression line.

    var xRange = extent(state.stats.data, function (d) {
      return d.x;
    });
    xRange[1] += 5; // let it nudge over a little.
    // Calculate the line positions.

    getLinearLine(xRange);
    getLinearLineExtension(xRange);
    getLogisticLine(xRange);
  } // Helper func to find the y tick corresponding to the point's x tick.


  function gatherTickInfo(xTick, array) {
    var yValue = lrLine(xTick.value.x); // Get the closest y tick.

    var yTick = array.reduce(function (a, b) {
      return Math.abs(b.value.y - yValue) < Math.abs(a.value.y - yValue) ? b : a;
    }); // A higher x value means we are below the ticl.

    var delta = yValue > yTick.value.y ? 'below' : 'above'; // Store the data in state so we can fetch it later from the article.

    state.stats.pointTickInfo = {
      x: xTick.key,
      y: yTick.key,
      yDelta: delta
    };
  } // Set the point coordinates we draw in `drawPoint`.


  function getPointDrawingParams() {
    if (!state.stats.lr) return;
    var xAxisValues = state.stats.current.filter(function (d) {
      return d.axis === 'x';
    })[0];
    if (!xAxisValues.labelLayout) return; // double safety net due to random race condition issue.

    var bbox = xAxisValues.labelLayout.bbox;
    var tickNumber = xAxisValues.labelLayout.ticks.length; // This needs to go in state / be picked up by the story

    var xTick = xAxisValues.labelLayout.ticks[Math.ceil(tickNumber / 2)]; // The points' final destination.

    pointStart = [xTick.value.x, bbox.yMax];
    var pointFinal = [pointStart[0], lrLine(pointStart[0])];
    var pointEndFinal = [bbox.xMax, lrLine(pointStart[0])]; // The initial point positions.

    point$3 = pointStart.slice();
    pointEnd = point$3.slice(); // Interpolating from the initial to the final positions.

    point$3[0] += state.stats.progress.point * (pointFinal[0] - point$3[0]);
    point$3[1] += state.stats.progress.point * (pointFinal[1] - point$3[1]);
    pointEnd[0] += state.stats.progress.point * (pointEndFinal[0] - pointEnd[0]);
    pointEnd[1] += state.stats.progress.point * (pointEndFinal[1] - pointEnd[1]);
    pointRadius = state.stats.progress.point * 5;
    pointAlpha = 1 - state.stats.progress.extend; // Get the tick info (what is the x and what the y key?) for the articla.
    // We only need this once to begin with (this func runs repeatedly on render).

    if (!state.stats.pointTickInfo) {
      gatherTickInfo(xTick, state.stats.current.filter(function (d) {
        return d.axis === 'y';
      })[0].labelLayout.ticks);
    }
  } // Layouts
  // -------
  // Layouts to save in each data row. The simulations
  // can move the dots to these with forceX, forceY.


  function addLayouts() {
    // Get all variable based layouts.
    var frequencyLayouts = [{
      name: 'alcohol',
      layout: frequency().variable('alcohol')(state.stats.data)
    }, {
      name: 'density',
      layout: frequency().variable('density')(state.stats.data)
    }, {
      name: 'fixed_acidity',
      layout: frequency().variable('fixed_acidity')(state.stats.data)
    }, {
      name: 'ph',
      layout: frequency().variable('ph')(state.stats.data)
    }, {
      name: 'volatile_acidity',
      layout: frequency().variable('volatile_acidity')(state.stats.data)
    }, {
      name: 'quality',
      layout: frequency().variable('quality')(state.stats.data)
    }, {
      name: 'quality_binary',
      layout: frequency().variable('quality_binary')(state.stats.data)
    }]; // Prep the scatter layout loop, with the predictors to use...

    var scatterLayouts = [{
      name: 'alcohol__quality',
      pred: 'alcohol',
      out: 'quality'
    }, {
      name: 'alcohol__quality_binary',
      pred: 'alcohol',
      out: 'quality_binary'
    }, {
      name: 'vol_acid__quality',
      pred: 'volatile_acidity',
      out: 'quality'
    }]; // Add all layouts to the main data.

    state.stats.data.forEach(function (d) {
      d.layout = {}; // That point where the globe disappears to.

      d.layout.globeExit = {
        x: txScale(1) + Math.random(),
        // 1
        y: tyScale(1) + Math.random()
      }; // Note, the Lattice layout is controlled by the link dataset.
      // Add all variable layouts to the data.

      frequencyLayouts.forEach(function (el) {
        d.layout[el.name] = {
          x: xScale$1(el.layout.get(d.id).x),
          y: yScale$1(el.layout.get(d.id).y),
          value: el.layout.get(d.id).value
        };
      }); // Add scatter plot layouts

      scatterLayouts.forEach(function (el) {
        var predictorScale = getLinearScale(el.pred);
        var outcomeScale = getLinearScale(el.out);
        d.layout[el.name] = {
          x: xScale$1(predictorScale(d[el.pred])),
          y: yScale$1(outcomeScale(d[el.out]))
        };
      });
    });
  } // Set an initial layout.


  function setLayout(name) {
    state.stats.data.forEach(function (d) {
      d.x = d.layout[name].x;
      d.y = d.layout[name].y;
    });
  } // Render and draw
  // ---------------


  function drawDot(r, colour) {
    var can = document.createElement('canvas');
    can.width = can.height = r * 2;
    var ctx = can.getContext('2d');
    ctx.beginPath();
    ctx.fillStyle = colour;
    ctx.arc(r, r, r, 0, 2 * Math.PI);
    ctx.fill();
    return can;
  }

  function drawPoint(ctx) {
    ctx.save();
    ctx.globalAlpha = pointAlpha; // Vertical line.

    ctx.beginPath();
    ctx.moveTo(pointStart[0], pointStart[1]);
    ctx.lineTo(point$3[0], point$3[1]);
    ctx.stroke(); // Point.

    ctx.beginPath();
    ctx.arc(point$3[0], point$3[1], pointRadius, 0, 2 * Math.PI);
    ctx.fill(); // Horizontal line.

    ctx.beginPath();
    ctx.moveTo(point$3[0], point$3[1]);
    ctx.lineTo(pointEnd[0], pointEnd[1]);
    ctx.stroke();
    ctx.restore();
  }

  function drawLine(ctx) {
    // Check for the regression line flag and if there's data to draw.
    if (!state.stats.lr && start$1.length) return;
    ctx.save();
    ctx.globalAlpha = state.stats.alpha.value; // Draw the regression line dynamically.

    ctx.beginPath();
    ctx.setLineDash([length - offset, offset]);
    ctx.moveTo(start$1[0], start$1[1]);
    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]);
    ctx.lineCap = 'round';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  }

  function drawStats(ctx) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.globalAlpha = state.stats.alpha.value; // Draw axes and labels.

    if (state.stats.current.length) {
      (function () {
        // Base styles.
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 0.2;
        var tickFontConfig = '12px Signika'; // Loop through each of the variables we want to show.

        var _loop = function _loop(i) {
          var currentVar = state.stats.current[i]; // Check if there's data to draw with.

          if (!currentVar.hasOwnProperty('labelLayout')) return "break"; // Reference element and layout info.

          var labelLayout = currentVar.labelLayout; // Draw each tick.

          ctx.fillStyle = '#555555'; // eslint-disable-next-line no-loop-func

          labelLayout.ticks.forEach(function (tick, j) {
            // Base info.
            var x = tick.value.x;
            var y = tick.value.y;
            var label = tick.key; // For scatter plots (they have label == true)...

            if (currentVar.label) {
              if (currentVar.axis === 'x') {
                // Get the labels' y value.
                var xTickLine = x;
                var y1TickLine = labelLayout.bbox.yMin;
                var y2TickLine = y - 10; // Check for overlapping labels.

                var zigzagCondition = tick.value.zigzag && j % 2 === 0;
                if (zigzagCondition) y2TickLine += 15; // Draw the tick line.

                ctx.beginPath();
                ctx.moveTo(xTickLine, y1TickLine);
                ctx.lineTo(xTickLine, y2TickLine);
                ctx.stroke(); // Draw the labels.

                ctx.font = tickFontConfig;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, x, y2TickLine);
              }

              if (currentVar.axis === 'y') {
                ctx.font = tickFontConfig;
                ctx.textAlign = yLabelAlign;
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x, y);
                var x1TickLine = labelLayout.bbox.xMin;
                var x2TickLine = x - 10;
                var yTickLine = y;
                ctx.beginPath();
                ctx.moveTo(x1TickLine, yTickLine);
                ctx.lineTo(x2TickLine, yTickLine);
                ctx.stroke();
              }
            } // For frequency plots (they have label == false)...


            if (!currentVar.label) {
              // Set the lengths of ticks.
              var y1 = y - tickPadding * 0.5;
              var y2 = y - tickPadding * 0.1; // Overwrite y2 if we should arrange long labels in zig zag.

              var _zigzagCondition = currentVar.axis === 'x' && tick.value.zigzag && j % 2 === 0;

              if (_zigzagCondition) y2 += 15; // Draw label.

              ctx.font = tickFontConfig;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';
              ctx.fillText(label, x, y2 + 5); // Draw ticks.

              ctx.beginPath();
              ctx.moveTo(x, y1);
              ctx.lineTo(x, y2);
              ctx.stroke();
            }
          }); // Draw the header.

          ctx.fillStyle = '#000000';

          if (currentVar.header) {
            var xHeader = labelLayout.label.header.x;
            var yHeader = labelLayout.label.header.y;
            var labelHeader = currentVar.name === 'ph' // edge case.
            ? 'pH' : prettyLabel(currentVar.name).replace('_', ' ');
            ctx.font = '50px Amatic SC';
            ctx.fillText(labelHeader, xHeader, yHeader - 50);
          } // Draw the axis labels.


          if (currentVar.label) {
            var xAxisLabel = labelLayout.label.axisLabel.x;
            var yAxisLabel = labelLayout.label.axisLabel.y;
            var labelAxis = prettyLabel(currentVar.name).replace('_', ' ');
            ctx.font = '20px Amatic SC';
            ctx.fillText(labelAxis, xAxisLabel, yAxisLabel);
          }
        };

        for (var i = 0; i < state.stats.current.length; i++) {
          var _ret = _loop(i);

          if (_ret === "break") break;
        }
      })();
    } // Draw dots.


    state.stats.data.forEach(function (d) {
      if (!state.stats.colourDots) {
        ctx.drawImage(dot, d.x, d.y);
      } else {
        ctx.drawImage(d.quality_binary ? dotGood : dotBad, d.x, d.y);
      }
    });
    ctx.restore();
  }

  function renderStats() {
    getLineDrawingParams();
    getPointDrawingParams();
    requestAnimationFrame(function () {
      drawStats(state.ctx.chart);
      drawLine(state.ctx.chart);
      drawPoint(state.ctx.chart);
    });
  } // Simulations
  // -----------
  // All the stuff we run per tick.


  function handleTick() {
    getLabelCoordinates();
    renderStats();
  } // Forces applied to all simulations.


  function boundingBox() {
    // Relies on some globals.
    var r = dotRadius;
    state.stats.data.forEach(function (node) {
      node.x = Math.max(r, Math.min(node.x, state.width - r * 2));
      node.y = Math.max(r, Math.min(node.y, state.height - r * 2));
    });
  } // Set up the simulations and stop it. We don't want
  // to start it until ScrollTrigger triggers it.


  function setSimulation() {
    sim = forceSimulation(state.stats.data).force('boxForce', boundingBox).on('tick', handleTick).stop();
  } // Initial function run on each update.


  function tweenStats() {
    getScales();
    addLayouts();
    setLayout('globeExit');
    setSimulation();
    dot = drawDot(dotRadius, state.bottleColour.base.stop1);
    dotGood = drawDot(dotRadius, state.bottleColour.good.dot);
    dotBad = drawDot(dotRadius, state.bottleColour.bad.dot);
  }
   // 1. Math.random to disperse them a little to start with.

  // External libs.
  // Move to the globe's exit position.

  var xPosGlobe = forceX(function (d) {
    return d.layout.globeExit.x;
  }).strength(0.1);
  var yPosGlobe = forceY(function (d) {
    return d.layout.globeExit.y;
  }).strength(0.1);

  function simulateGlobePosition() {
    // Configure and start simulation.
    sim.nodes(state.stats.data).force('chargeLattice', null).force('link', null).force('xCentre', null).force('yCentre', null).force('xGlobe', xPosGlobe).force('yGlobe', yPosGlobe).alpha(0.8).restart(); // Switch the global alpha off.

    tweenStatsAlpha(0);
  } // Move to lattice.


  var chargeLattice = forceManyBody().strength(-6);
  var xPosCentre = forceX(function () {
    return state.width / 2;
  }).strength(0.05); // 1

  var yPosCentre = forceY(function () {
    return state.height / 2;
  }).strength(0.05);

  function simulateLattice() {
    // Set the current variable value to null.
    // This is not a frequency distribution.
    state.stats.current = []; // This ↓ can't be in module scope with its force friends,
    // as it needs to be run after the links are produced.

    var linkForce = forceLink(state.stats.links).id(function (d) {
      return d.index;
    }).strength(1).distance(1).iterations(15); // Configure and start simulation.

    sim.nodes(state.stats.data).force('link', linkForce).force('chargeLattice', chargeLattice).force('chargeFrequencies', null).force('xGlobe', null).force('yGlobe', null).force('xCentre', xPosCentre).force('yCentre', yPosCentre).force('xAlcohol', null).force('yAlcohol', null).alpha(0.8).restart(); // Switch the global alpha on.

    state.stats.alpha.value = 1;
  } // Move to Alcohol frequency.


  var chargeFrequencies = forceManyBody().strength(-2);
  var xPosAlcohol = forceX(function (d) {
    return d.layout.alcohol.x;
  }).strength(0.5);
  var yPosAlcohol = forceY(function (d) {
    return d.layout.alcohol.y;
  }).strength(0.5);

  function simulateAlcohol() {
    state.stats.current = [{
      name: 'alcohol',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }]; // This sim is triggered on multiple occasions.

    sim.nodes(state.stats.data).force('link', null).force('chargeLattice', null).force('xCentre', null).force('yCentre', null).force('chargeFrequencies', chargeFrequencies).force('chargeScatter', null).force('xQuality', null).force('yQuality', null).force('xPosQualAlc', null).force('yPosQualAlc', null).force('xAlcohol', xPosAlcohol).force('yAlcohol', yPosAlcohol).force('xPosQualVol', null).force('yPosQualVol', null).force('xDensity', null).force('yDensity', null).alpha(0.8).restart();
  } // Move to Density frequency.


  var xPosDensity = forceX(function (d) {
    return d.layout.density.x;
  }).strength(0.5);
  var yPosDensity = forceY(function (d) {
    return d.layout.density.y;
  }).strength(0.5);

  function simulateDensity() {
    state.stats.current = [{
      name: 'density',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }];
    sim.nodes(state.stats.data).force('xAlcohol', null).force('yAlcohol', null).force('xDensity', xPosDensity).force('yDensity', yPosDensity).force('xFixed', null).force('yFixed', null).alpha(0.8).restart();
  } // Move to Fixed Acidity frequency.


  var xPosFixed = forceX(function (d) {
    return d.layout.fixed_acidity.x;
  }).strength(0.5);
  var yPosFixed = forceY(function (d) {
    return d.layout.fixed_acidity.y;
  }).strength(0.5);

  function simulateFixed() {
    state.stats.current = [{
      name: 'fixed_acidity',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }];
    sim.nodes(state.stats.data).force('xDensity', null).force('yDensity', null).force('xFixed', xPosFixed).force('yFixed', yPosFixed).force('xPh', null).force('yPh', null).alpha(0.8).restart();
  } // Move to pH frequency.


  var xPosPh = forceX(function (d) {
    return d.layout.ph.x;
  }).strength(0.5);
  var yPosPh = forceY(function (d) {
    return d.layout.ph.y;
  }).strength(0.5);

  function simulatePh() {
    state.stats.current = [{
      name: 'ph',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }];
    sim.nodes(state.stats.data).force('xFixed', null).force('yFixed', null).force('xPh', xPosPh).force('yPh', yPosPh).force('xVolatile', null).force('yVolatile', null).alpha(0.8).restart();
  } // Move to Volatile Acidity frequency.


  var xPosVolatile = forceX(function (d) {
    return d.layout.volatile_acidity.x;
  }).strength(0.5);
  var yPosVolatile = forceY(function (d) {
    return d.layout.volatile_acidity.y;
  }).strength(0.5);

  function simulateVolatile() {
    state.stats.current = [{
      name: 'volatile_acidity',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }];
    sim.nodes(state.stats.data).force('xPh', null).force('yPh', null).force('xQuality', null).force('yQuality', null).force('xVolatile', xPosVolatile).force('yVolatile', yPosVolatile).force('chargeFrequencies', chargeFrequencies).force('chargeScatter', null).force('xPosQualVol', null).force('yPosQualVol', null).alpha(0.8).restart();
  } // Move to Quality frequency.


  var xPosQuality = forceX(function (d) {
    return d.layout.quality.x;
  }).strength(0.5);
  var yPosQuality = forceY(function (d) {
    return d.layout.quality.y;
  }).strength(0.5);

  function simulateQuality() {
    state.stats.current = [{
      name: 'quality',
      axis: 'x',
      straight: false,
      header: true,
      label: false
    }];
    sim.nodes(state.stats.data).force('xVolatile', null).force('yVolatile', null).force('xQuality', xPosQuality).force('yQuality', yPosQuality).force('xAlcohol', null).force('yAlcohol', null).alpha(0.8).restart();
  }
  //    have a `strangth` setter yet. So I am implementing my own centre
  //    force here.

  // External libs.
  // Move to Alcohol scatter.

  var chargeScatter = forceManyBody().strength(-1);
  var xPosQualAlc = forceX(function (d) {
    return d.layout.alcohol__quality.x;
  }).strength(0.3);
  var yPosQualAlc = forceY(function (d) {
    return d.layout.alcohol__quality.y;
  }).strength(0.3);

  function simulateQualAlc() {
    state.stats.current = [{
      name: 'alcohol',
      axis: 'x',
      straight: true,
      header: false,
      label: true
    }, {
      name: 'quality',
      axis: 'y',
      straight: true,
      header: false,
      label: true
    }];
    sim.nodes(state.stats.data).force('chargeFrequencies', null).force('chargeScatter', chargeScatter).force('xAlcohol', null).force('yAlcohol', null).force('xPosQualAlc', xPosQualAlc).force('yPosQualAlc', yPosQualAlc).force('xPosQualVol', null).force('yPosQualVol', null).force('xPosQualBinAlc', null).force('yPosQualBinAlc', null).alpha(0.8).restart();
  } // Move to Volatile Acidity scatter.


  var xPosQualVol = forceX(function (d) {
    return d.layout.vol_acid__quality.x;
  }).strength(0.3);
  var yPosQualVol = forceY(function (d) {
    return d.layout.vol_acid__quality.y;
  }).strength(0.3);

  function simulateQualVol() {
    state.stats.current = [{
      name: 'volatile_acidity',
      axis: 'x',
      straight: true,
      header: false,
      label: true
    }, {
      name: 'quality',
      axis: 'y',
      straight: true,
      header: false,
      label: true
    }];
    sim.nodes(state.stats.data).force('chargeFrequencies', null).force('chargeScatter', chargeScatter).force('xPosQualVol', xPosQualVol).force('yPosQualVol', yPosQualVol).force('xVolatile', null).force('yVolatile', null).force('xAlcohol', null).force('yAlcohol', null).alpha(0.8).restart();
  } // Move to Volatile Acidity scatter.


  var xPosQualBinAlc = forceX(function (d) {
    return d.layout.alcohol__quality_binary.x;
  }).strength(0.3);
  var yPosQualBinAlc = forceY(function (d) {
    return d.layout.alcohol__quality_binary.y;
  }).strength(0.3);

  function simulateQualBinAlc() {
    state.stats.current = [{
      name: 'alcohol',
      axis: 'x',
      straight: true,
      header: false,
      label: true
    }, {
      name: 'quality_binary',
      axis: 'y',
      straight: true,
      header: false,
      label: true
    }];
    sim.nodes(state.stats.data).force('chargeScatter', chargeScatter).force('boxForce', boundingBox).force('xPosQualAlc', null).force('yPosQualAlc', null).force('xPosQualVol', null).force('yPosQualVol', null).force('xPosQualBinAlc', xPosQualBinAlc).force('yPosQualBinAlc', yPosQualBinAlc).force('chargeRemove', null).alpha(0.8).restart();
  }

  var chargeRemove = forceManyBody().strength(-4);

  function simulateRemove() {
    sim.nodes(state.stats.data).force('chargeScatter', null).force('boxForce', null).force('xPosQualBinAlc', null).force('yPosQualBinAlc', null).force('chargeRemove', chargeRemove).alpha(0.8).restart(); // Switch the global alpha off.

    tweenStatsAlpha(0, 1);
  }

  /* eslint-disable no-param-reassign */

  var area = {
    top: null,
    right: null,
    bottom: null,
    left: null,
    width: null,
    height: null
  };
  var xScale$2;
  var yScale$2;
  var r$1 = 5;
  var lw = 2;
  var title = {
    alpha: 0
  };
  var fontSize = '16px Signika'; // Set up / prep.

  function setDimensions$1() {
    var heightFactor = isMobile() ? 0.125 : 0.1;
    var marginHorz = state.width * 0.1;
    var marginVert = state.height * heightFactor;
    area.top = Math.floor(marginVert * 2);
    area.right = Math.floor(state.width - marginHorz);
    area.bottom = Math.floor(state.height - marginVert);
    area.left = Math.floor(marginHorz);
    area.width = Math.floor(area.right - area.left);
    area.height = Math.floor(area.bottom - area.top);
    fontSize = isMobile() ? '12px Signika' : '16px Signika';
  }

  function augmentData() {
    state.varImp.data.forEach(function (d) {
      d.value = 0;
      d.alpha = 0;
    });
  }

  function setScales$1() {
    xScale$2 = linear$1().domain([0, max(state.varImp.data, function (d) {
      return d.importance;
    })]).range([area.left, area.right]);
    yScale$2 = point$1().domain(state.varImp.data.map(function (d) {
      return d.variable;
    })).range([area.top, area.bottom]);
  } // Draw and render.


  function drawImportanceChart(ctx) {
    var rough = state.rough.chart;
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save(); // General styles.

    state.ctx.chart.lineWidth = lw; // Title.

    ctx.save();
    ctx.globalAlpha = title.alpha;
    ctx.font = '40px Amatic SC';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Variable Importance', area.left, area.top - 30);
    ctx.restore(); // The bars.

    state.varImp.data.forEach(function (d, i) {
      // Lime.
      ctx.beginPath();
      rough.line(xScale$2(0), yScale$2(d.variable), xScale$2(d.value), yScale$2(d.variable), {
        seed: i + 1,
        roughness: 0.7
      });
      ctx.stroke();
      ctx.save();
      ctx.globalAlpha = d.alpha; // Circle.

      ctx.beginPath();
      rough.circle(xScale$2(d.value) + (r$1 + lw) / 2, yScale$2(d.variable), r$1 * 2, {
        seed: i + 1,
        roughness: 0.25
      });
      ctx.stroke(); // Text.

      ctx.font = fontSize;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      var text = d.variable === 'ph' ? 'pH' : prettyLabel(d.variable);
      ctx.fillText(text, xScale$2(0), yScale$2(d.variable) + 7);
      ctx.restore();
    });
    ctx.restore();
  }

  function renderImportance() {
    requestAnimationFrame(function () {
      drawImportanceChart(state.ctx.chart);
    });
  }

  function defineTweenImportance() {
    var tl = gsap.timeline({
      onUpdate: renderImportance
    }); // Tween the title alpha.

    var titletween = gsap.fromTo(title, {
      alpha: 0
    }, {
      alpha: 1
    });
    tl.add(titletween); // Tween the variable importance values and alphas.

    state.varImp.data.forEach(function (d) {
      var valuetween = gsap.fromTo(d, {
        value: 0
      }, {
        value: d.importance
      });
      var alphatween = gsap.fromTo(d, {
        alpha: 0
      }, {
        alpha: 1
      });
      tl.add(alphatween, '>').add(valuetween, '<');
    });
    return tl;
  }

  function defineTweenImportanceRemove() {
    var tl = gsap.timeline({
      onUpdate: renderImportance
    }); // Tween the title alpha.

    var titletween = gsap.fromTo(title, {
      alpha: 1
    }, {
      alpha: 0
    });
    tl.add(titletween, 0); // Tween the variable importance values and alphas.

    state.varImp.data.forEach(function (d) {
      var valuetween = gsap.to(d, {
        value: 0
      });
      var alphatween = gsap.to(d, {
        alpha: 0
      });
      tl.add(alphatween, '>').add(valuetween, '<');
    });
    return tl;
  }

  function tweenAdd() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('importance');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.importance) state.tween.importance.kill();
    state.tween.importance = defineTweenImportance();
    state.tween.importance.totalProgress(progress);
  }

  function tweenRemove$1() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('importanceRemove');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.importanceRemove) state.tween.importanceRemove.kill();
    state.tween.importanceRemove = defineTweenImportanceRemove();
    state.tween.importanceRemove.totalProgress(progress);
  }

  function tweenimportance() {
    // Some prep.
    setDimensions$1();
    augmentData();
    setScales$1(); // Defining the add and remove tweens.

    tweenAdd();
    tweenRemove$1();
  }

  /**
   * Draws a path at a certain offset of its full length.
   * Can nicely be used to animate a path.
   * @param { Object } ctx Context to draw on
   * @param { Array|String} paths Path(s) to draw
   * @param { Object } t transform to apply to context
   * @param { Number } length Max length of the (longest) path
   * @param { Number } offset Length of the path to draw (ideally animated)
   */

  function drawPaths(ctx, paths, t, length, offset, alpha) {
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.setLineDash([length - offset, offset]); // eslint-disable-next-line no-unused-expressions

    Array.isArray(paths) ? paths.forEach(function (path) {
      return ctx.stroke(path);
    }) : ctx.stroke(paths);
    ctx.restore();
  }

  function renderModelBottle() {
    requestAnimationFrame(function () {
      drawPaths(state.ctx.glassBottle, state.modelBottle.paths, state.transform.shape, state.modelBottle.maxLength, state.modelBottle.dashOffset, state.modelBottle.alpha);
    });
  }

  function defineTweenModelBottle(offsetDraw, alphaStart, alphaTarget) {
    var tl = gsapWithCSS.timeline({
      onUpdate: renderModelBottle
    });
    var offsetIn = gsapWithCSS.fromTo(state.modelBottle, {
      dashOffset: state.modelBottle.maxLength
    }, {
      dashOffset: 0
    });
    var offsetOut = gsapWithCSS.fromTo(state.modelBottle, {
      dashOffset: 0
    }, {
      dashOffset: state.modelBottle.maxLength
    });
    var alphavalue = gsapWithCSS.fromTo(state.modelBottle, {
      alpha: alphaStart
    }, {
      alpha: alphaTarget
    });
    return tl.add(offsetDraw ? offsetIn : offsetOut).add(alphavalue, 0);
  }

  function tweenIn() {
    // Capture current progress.
    var scroll = ScrollTrigger.getById('modelBottleIn');
    var progress = scroll ? scroll.progress : 0; // Kill old - set up new timeline.

    if (state.tween.modelBottleIn) state.tween.modelBottleIn.kill();
    state.tween.modelBottleIn = defineTweenModelBottle(true, 0, 1);
    state.tween.modelBottleIn.totalProgress(progress);
  }

  function tweenModelBottle() {
    tweenIn(); // tweenOut(); // not needed but here for if and when required.
  }

  var gsapWithCSS$1 = gsap.registerPlugin(CSSPlugin) || gsap,
      // to protect from tree shaking
  TweenMaxWithCSS$1 = gsapWithCSS$1.core.Tween;

  var position = {};
  var lw$1 = 20;
  var lh = 3;
  var pad$1 = 5;
  var perc = format('.0%');
  var fontSize$1 = 8; // Draw and render.

  function drawWaveMarkers(ctx, t, path) {
    var rough = state.rough.chart;
    ctx.clearRect(0, 0, state.width, state.height);
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.globalAlpha = state.modelWave.alpha; // Line

    ctx.lineWidth = 0.1;
    ctx.beginPath();
    rough.line(position.x / 2, position.y, position.x + lw$1, position.y, {
      seed: 1
    });
    ctx.stroke(); // ...marker

    ctx.lineWidth = 0.25;
    ctx.beginPath();
    rough.line(position.x + lw$1, position.y - lh, position.x + lw$1, position.y + lh, {
      seed: 1
    });
    ctx.stroke(); // Main text (probability).

    ctx.textBaseline = 'middle';
    ctx.font = "".concat(fontSize$1, "px Signika");
    ctx.fillText("".concat(perc(state.model.probability), " likely to be good"), position.x + lw$1 + pad$1, position.y + 1); // Subtitle (tips).

    ctx.font = "".concat(Math.floor(fontSize$1 * 0.9), "px Signika");
    ctx.fillStyle = state.modelBottle.infoColour; // This is an array of text with each element getting its own line...

    state.modelBottle.info.forEach(function (d, i) {
      var sublineOffset = i === 0 ? 2 : 0;
      ctx.fillText(d, position.x + lw$1 + pad$1, position.y + (i + 1) * (fontSize$1 + 2) + sublineOffset);
    }); // Clip.

    ctx.globalCompositeOperation = 'destination-out';
    ctx.globalAlpha = 1; // to be safe.

    ctx.translate(5, 0);
    ctx.fill(path);
    ctx.restore();
  }

  function renderWaveMarkers() {
    requestAnimationFrame(function () {
      drawWaveMarkers(state.ctx.chart, state.transform.shape, state.bottleWave.bottlePath);
    });
  } // Make.


  function makeWaveMarkers() {
    // Prep.
    var wave = state.bottleWave;
    if (!wave.wavePoints || !wave.wavePoints.length) return; // A more or less steady y position.

    var h = state.glassBottle.bottleBox.height;
    var y = mean(wave.wavePoints, function (d) {
      return d[1];
    });
    if (y > h * 0.98) y = h * 0.98;
    if (y < h * 0.005) y = h * 0.005; // Position will be picked up by the draw function.

    position = {
      x: wave.wavePoints[wave.wavePoints.length - 1][0],
      y: y
    }; // Render it.

    renderWaveMarkers();
  } // Control the marker funcs.


  function startWaveMarkers() {
    gsapWithCSS$1.ticker.add(makeWaveMarkers);
  }

  function stopWaveMarkers() {
    gsapWithCSS$1.ticker.remove(makeWaveMarkers);
  }

  // as the tweening malarky wasn't fun and piled up edge cases.

  var subBottle = -0.1; // Scroll from below bottle to the current probability.

  function updateModelWave(scroll) {
    state.modelBottle.points = true;
    state.bottleWave.lift = subBottle + scroll.progress * (state.model.probability - subBottle);
    state.modelWave.alpha = scroll.progress;
    startWave();
    decayWave();
    startWaveMarkers();
  } // Stop all wavey things when scrolling back up the story.


  function stopModelWave() {
    state.modelBottle.points = false;
    stopWaveMarkers();
    stopWave();
  } // Called each time on update (e.g. resize) to start, stop
  // any action based on the flags set in the control funs above ↑.


  function checkModelWave() {
    if (state.modelBottle.points) {
      startWave();
      startWaveMarkers();
    } else {
      stopWave();
      stopWaveMarkers();
    }
  }

  /* eslint-disable no-return-assign */
  gsapWithCSS.registerPlugin(CustomEase, CustomWiggle); // Helpers.

  function getTriggerPositions() {
    var visual = document.querySelector('#visual-container');
    var visualHeight = parseInt(window.getComputedStyle(visual).height, 10);
    var windowHeight = window.innerHeight;
    var textHeight = windowHeight - visualHeight;

    if (!isMobile()) {
      return {
        start: 'top center',
        end: 'center center',
        endElement: 'center',
        endContainer: 'center'
      };
    } // If we're on mobile.


    var offset = visualHeight + textHeight / 2;
    return {
      start: "top top+=".concat(offset, "px"),
      end: "center top+=".concat(offset, "px"),
      endElement: 'center',
      endContainer: "top+=".concat(offset, "px")
    };
  }

  function lerp(a, b, t) {
    return a * (1 - t) + b * t;
  } // Set ScrollTrigger defaults.


  ScrollTrigger.defaults({
    scroller: '#container',
    start: 'top center',
    end: 'center center',
    scrub: true,
    toggleActions: 'play none none reverse',
    markers: false
  });
  CustomWiggle.create('sliderWiggle', {
    wiggles: 4
  });

  function updateDimensions() {
    var container = document.querySelector('#canvas-main-container');
    state.width = container.clientWidth;
    state.height = container.clientHeight;
  } // Get contexts and rezize canvases.


  function updateContexts(names) {
    var canvases = document.querySelectorAll('canvas');
    names.forEach(function (name, i) {
      state.ctx[name] = canvases[i].getContext('2d');
      resizeCanvas(canvases[i], state.width, state.height);
    });
  }

  function setRoughCanvases() {
    state.rough.chart = st.canvas(state.ctx.chart.canvas);
    state.rough.globe = st.canvas(state.ctx.globe.canvas);
  } // Set off canvas factory.


  function setVisualStructure() {
    // Get contexts.
    var contextnames = ['scape', 'glassBottle', 'bottleText', 'bottleWave', 'chart', 'blackBox', 'globe'];
    updateContexts(contextnames);
    setRoughCanvases();
  }

  function updateTransforms() {
    // Update all necessary transforms.
    // Update winescape image (and glass) transform.
    var scapeDim = {
      width: state.scape.image.width,
      height: state.scape.image.height
    };
    state.transform.scape = getTransform(scapeDim, {
      width: 1,
      height: 0
    });
    state.transform.shape = lodash_clonedeep(state.transform.scape); // There's no mathemtacial connection between the bottle's
    // ideal height and the aspect ratio, but using the ar
    // fits quite nicely in this case.

    var sizeFactor = isMobile() ? 135 : 100;
    state.glassBottle.bottleTop = Math.min(Math.floor(state.width / state.height * 100) / sizeFactor, 0.8);
    state.glassBottle.bottleLeft = 0.25;
    state.transform.bottle = getTransform(state.glassBottle.bottleBox, {
      width: 0,
      height: state.glassBottle.bottleTop
    }, {
      x: state.glassBottle.bottleLeft,
      height: null
    }); // Animals.
    // Get a transform for each animal based on its getBBox dimensions.

    state.animals.data.forEach(function (animal) {
      state.transform[animal.name] = getTransform(state.animals[animal.name], animal.fit);
    }); // Update the dataset transform.

    state.transform.dataset = getTransform(state.dataset.box, {
      width: 0.9,
      height: 0
    });
  } // Scroll helper.


  function clearAllContexts() {
    // Stop all potentially moving parts.
    stopWave();
    stopModelWave();
    stopWaveMarkers();
    sim.stop(); // Clear all contexts with an additional timeout
    // to make sure all above things have been stopped.

    timeout$1(function () {
      Object.entries(state.ctx).forEach(function (d) {
        return clear(d[1]);
      });
    }, 50);
  } // Set scroll.


  function setScrollBase() {
    var _getTriggerPositions = getTriggerPositions(),
        start = _getTriggerPositions.start,
        end = _getTriggerPositions.end,
        endContainer = _getTriggerPositions.endContainer;

    ScrollTrigger.create({
      trigger: '.section-0',
      start: start,
      id: 'triggerPositionRefresh',
      onEnter: function onEnter() {
        // The scroll trigger positions need to be calculated when all content
        // has loaded. Giving the first trigger no other job than refreshing
        // the scroll trigger positions seems the best way to guarantee this.
        ScrollTrigger.refresh();
      }
    });
    ScrollTrigger.create({
      animation: state.tween.wineScape,
      trigger: '.section-1',
      start: start,
      end: end,
      id: 'wineScape',
      onLeaveBack: function onLeaveBack() {
        // Stop all and clear all contexts if users scroll up to top.
        timeout$1(clearAllContexts, 50);
      }
    });
    ScrollTrigger.create({
      animation: state.tween.glassBottle,
      trigger: '.section-2',
      start: start,
      end: end,
      id: 'glassBottle'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleText,
      trigger: '.section-3',
      start: start,
      end: end,
      id: 'bottleText'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleWave,
      trigger: '.section-4',
      start: start,
      end: end,
      id: 'bottleWave'
    });
    ScrollTrigger.create({
      trigger: '#slider-tool',
      start: 'top 75%',
      onEnter: function onEnter() {
        gsapWithCSS.to('#slider-alcohol', {
          duration: 0.5,
          scale: 1.1,
          x: 10,
          ease: 'sliderWiggle'
        });
        gsapWithCSS.to('#slider-acids', {
          duration: 0.5,
          delay: 0.1,
          scale: 1.1,
          x: 10,
          ease: 'sliderWiggle'
        });
        gsapWithCSS.to('#slider-sugars', {
          duration: 0.5,
          delay: 0.2,
          scale: 1.1,
          x: 10,
          ease: 'sliderWiggle'
        });
      }
    });
    ScrollTrigger.create({
      // The initial transition is done via tween...
      animation: state.tween.lolliChart,
      trigger: '.section-5',
      start: start,
      end: end,
      id: 'lolliChart'
    });
    ScrollTrigger.create({
      // ...all others lolli transitions are done manually to have
      // better access to the possibly changed  slider values.
      trigger: '.section-6',
      start: start,
      end: end,
      id: 'lolliUpdate1',
      onUpdate: function onUpdate(_ref) {
        var progress = _ref.progress;
        // Lines.
        state.lolli.keys.forEach(function (d) {
          var a = state.lolli.data[d].values[1];
          var b = state.lolli.data[d].values[2];
          var current = lerp(a, b, progress);
          state.lolli.data[d].value = current;
        });
        renderLolliChart();
      }
    }); // trigger bottom for the 2nd lolli update a little different.

    ScrollTrigger.create({
      trigger: '.section-7',
      start: start,
      end: 'center bottom',
      id: 'lolliUpdate2',
      onUpdate: function onUpdate(_ref2) {
        var progress = _ref2.progress;
        // Lines.
        state.lolli.keys.forEach(function (d) {
          var a = state.lolli.data[d].values[2];
          var b = state.lolli.data[d].values[3];
          var current = lerp(a, b, progress);
          state.lolli.data[d].value = current;
        });
        renderLolliChart();
      }
    });
    ScrollTrigger.create({
      trigger: '.section-8',
      start: start,
      end: end,
      id: 'lolliUpdate3',
      onUpdate: function onUpdate(_ref3) {
        var progress = _ref3.progress;
        // Circle radius.
        var startRadius = state.lolli.radiusTarget;
        var endRadius = 0;
        var currentRadius = lerp(startRadius, endRadius, progress); // Lines.

        state.lolli.keys.forEach(function (d) {
          var startValue = state.lolli.data[d].values[3];
          var endValue = state.lolli.data[d].values[4];
          var currentValue = lerp(startValue, endValue, progress);
          state.lolli.data[d].value = currentValue;
          state.lolli.data[d].radius = currentRadius;
        }); // Quality text.

        var quality = state.lolli.data.quality;
        var startOffset = 0;
        var endOffset = quality.text.length;
        var currentOffset = lerp(startOffset, endOffset, progress);
        quality.text.offset = currentOffset;
        renderLolliChart();
      },
      onEnterBack: function onEnterBack() {
        clear(state.ctx.blackBox);
      }
    }); // 2 items.

    arrows.forEach(function (d, i) {
      ScrollTrigger.create({
        animation: state.tween[d],
        trigger: ".section-".concat(9 + i),
        start: start,
        end: end,
        id: d
      });
    });
    ScrollTrigger.create({
      animation: state.tween.cleanup,
      trigger: '.section-11',
      start: start,
      end: end,
      id: 'cleanup'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleTextOut,
      trigger: '.section-12',
      start: start,
      end: end,
      id: 'bottleTextOut'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleEmpty,
      trigger: '.section-13',
      start: start,
      end: end,
      id: 'bottleEmpty',
      onLeave: function onLeave() {
        stopWave();
        clear(state.ctx.bottleWave);
        clear(state.ctx.blackBox); // extra clean for Safari.
      },
      onEnterBack: startWave
    }); // Setting up all the scrolltriggers for the animals.
    // 8 items.

    for (var i = 0; i < animalPaths.length - 1; i++) {
      var animal = animalPaths[i];
      ScrollTrigger.create({
        animation: state.tween[animal.name],
        trigger: ".section-".concat(14 + i),
        start: start,
        end: end,
        id: animal.name
      });
    }

    ScrollTrigger.create({
      animation: state.tween.bottleFill,
      trigger: '.section-22',
      start: start,
      end: end,
      id: 'bottleFill',
      onLeave: stopWave,
      onEnterBack: startWave
    }); // 3 items.

    bottleColours.forEach(function (d, i) {
      ScrollTrigger.create({
        animation: state.tween[d.name],
        trigger: ".section-".concat(23 + i),
        start: start,
        end: end,
        id: d.name
      });
    });
    ScrollTrigger.create({
      animation: state.tween.bottleGrid,
      trigger: '.section-26',
      start: start,
      end: "bottom-=10% ".concat(endContainer),
      // the grids need seom more space..
      id: 'bottleGrid'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleGridColour,
      trigger: '.section-27',
      start: start,
      end: end,
      id: 'bottleGridColour'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleGridSort,
      trigger: '.section-28',
      start: start,
      end: "bottom-=10% ".concat(endContainer),
      id: 'bottleGridSort'
    });
    ScrollTrigger.create({
      animation: state.tween.bottleGridOut,
      trigger: '.section-29',
      start: start,
      end: "bottom-=10% ".concat(endContainer),
      id: 'bottleGridOut',
      // Shut the glassBottle context up.
      onEnterBack: function onEnterBack() {
        state.glassBottle.alpha = 0;
        clear(state.ctx.glassBottle);
      }
    }); // Setting up all the scrolltriggers for the dataset.
    // We set up a scrolltrigger/tween for each column and the grid.
    // 13 items.

    state.dataset.info.forEach(function (d, i) {
      ScrollTrigger.create({
        animation: state.tween[d.tween],
        trigger: ".section-".concat(30 + i),
        start: start,
        end: end,
        id: d.tween,
        onEnter: function onEnter() {
          return state.glassBottle.alpha = 1;
        },
        onEnterBack: function onEnterBack() {
          return state.glassBottle.alpha = 1;
        }
      });
    });
    ScrollTrigger.create({
      animation: state.tween.globe,
      trigger: '.section-43',
      start: start,
      end: 'bottom+=10% center',
      // the globe needs some extra screen time 🥂
      id: 'globe',
      onEnter: function onEnter() {
        // Shut the glassBottle context up.
        state.glassBottle.alpha = 0;
        clear(state.ctx.glassBottle);
      },
      onUpdate: function onUpdate(self) {
        return state.globe.scroll.progress = self.progress;
      }
    });
    ScrollTrigger.create({
      trigger: '.section-44',
      start: start,
      end: end,
      id: 'statsLattice',
      onLeaveBack: simulateGlobePosition,
      onEnter: simulateLattice
    });
    ScrollTrigger.create({
      trigger: '.section-45',
      start: start,
      end: end,
      id: 'statsAlcohol',
      onLeaveBack: simulateLattice,
      onEnter: simulateAlcohol
    });
    ScrollTrigger.create({
      trigger: '.section-46',
      start: start,
      end: end,
      id: 'statsDensity',
      onLeaveBack: simulateAlcohol,
      onEnter: simulateDensity
    });
    ScrollTrigger.create({
      trigger: '.section-47',
      start: start,
      end: end,
      id: 'statsFixed',
      onLeaveBack: simulateDensity,
      onEnter: simulateFixed
    });
    ScrollTrigger.create({
      trigger: '.section-48',
      start: start,
      end: end,
      id: 'statsPh',
      onLeaveBack: simulateFixed,
      onEnter: simulatePh
    });
    ScrollTrigger.create({
      trigger: '.section-49',
      start: start,
      end: end,
      id: 'statsVolatile',
      onLeaveBack: simulatePh,
      onEnter: simulateVolatile
    });
    ScrollTrigger.create({
      trigger: '.section-50',
      start: start,
      end: end,
      id: 'statsQuality',
      onLeaveBack: simulateVolatile,
      onEnter: simulateQuality
    });
    ScrollTrigger.create({
      trigger: '.section-51',
      start: start,
      end: end,
      id: 'qualityDots',
      onLeaveBack: function onLeaveBack() {
        return state.stats.colourDots = false;
      },
      onEnter: function onEnter() {
        state.stats.colourDots = true;
        sim.restart(); // ...won't change colours if it's cold.
      }
    });
    ScrollTrigger.create({
      trigger: '.section-52',
      start: start,
      end: end,
      id: 'statsAlcoholColoured',
      onLeaveBack: simulateQuality,
      onEnter: simulateVolatile
    });
    ScrollTrigger.create({
      trigger: '.section-53',
      start: start,
      end: end,
      id: 'statsAlcoholColoured',
      onLeaveBack: simulateVolatile,
      onEnter: simulateQualVol
    });
    ScrollTrigger.create({
      trigger: '.section-54',
      start: start,
      end: end,
      id: 'statsAlcoholColoured',
      onLeaveBack: simulateQualVol,
      onEnter: simulateAlcohol
    });
    ScrollTrigger.create({
      trigger: '.section-55',
      start: start,
      end: end,
      id: 'statsAlcoholQuality',
      onLeaveBack: simulateAlcohol,
      onEnter: simulateQualAlc
    });
    ScrollTrigger.create({
      trigger: '.section-56',
      start: start,
      end: end,
      id: 'statsDrawLR',
      onLeaveBack: function onLeaveBack() {
        state.stats.lr = false;
        simulateQualAlc();
      },
      onEnter: function onEnter() {
        return state.stats.lr = true;
      },
      onUpdate: function onUpdate(self) {
        state.stats.progress.draw = self.progress;
        renderStats();
      }
    });
    ScrollTrigger.create({
      trigger: '.section-57',
      start: start,
      end: end,
      id: 'statsDrawLRPoint',
      onUpdate: function onUpdate(self) {
        state.stats.progress.point = self.progress;
        renderStats();
      }
    });
    ScrollTrigger.create({
      trigger: '.section-58',
      start: start,
      end: end,
      id: 'statsExtendLR',
      onUpdate: function onUpdate(self) {
        state.stats.progress.extend = self.progress;
        renderStats();
      }
    });
    ScrollTrigger.create({
      trigger: '.section-59',
      start: start,
      end: end,
      id: 'statsQualityBinaryAlcohol',
      onLeaveBack: simulateQualAlc,
      onEnter: simulateQualBinAlc
    });
    ScrollTrigger.create({
      trigger: '.section-60',
      start: start,
      end: end,
      id: 'statsLogisticLine',
      onLeaveBack: simulateQualBinAlc,
      onUpdate: function onUpdate(self) {
        state.stats.progress.logistic = self.progress;
        renderStats();
      }
    });
    ScrollTrigger.create({
      trigger: '.section-61',
      start: start,
      end: end,
      id: 'statsRemove',
      onLeaveBack: function onLeaveBack() {
        state.stats.lr = true;
        tweenStatsAlpha(1); // Switch the global alpha back on.

        simulateQualBinAlc();
      },
      onEnter: function onEnter() {
        state.stats.lr = false;
        simulateRemove();
      }
    });
    ScrollTrigger.create({
      animation: state.tween.importance,
      trigger: '.section-62',
      start: start,
      end: end,
      id: 'importance',
      // Stop the simulation as it would otherwise
      // continue to draw on the context.
      onEnter: function onEnter() {
        return sim.stop();
      },
      onEnterBack: function onEnterBack() {
        return clear(state.ctx.bottleWave);
      } // 1

    });
    ScrollTrigger.create({
      animation: state.tween.importanceRemove,
      trigger: '.section-63',
      start: start,
      end: end,
      id: 'importanceRemove'
    });
    ScrollTrigger.create({
      animation: state.tween.modelBottleIn,
      trigger: '.section-64',
      start: start,
      end: end,
      id: 'modelBottleIn',
      onEnterBack: function onEnterBack() {
        return clear(state.ctx.bottleWave);
      } // 1

    });
    ScrollTrigger.create({
      trigger: '.section-65',
      start: start,
      end: end,
      id: 'modelWaveInit',
      onLeaveBack: function onLeaveBack() {
        return stopModelWave();
      },
      onUpdate: function onUpdate(self) {
        return updateModelWave(self);
      }
    });
  }

  function setScroll() {
    // Match media is needed to reset and rebuild the
    // start and end positions for the triggers on resize.
    // It also recalculates all scroll positions, I believe.
    ScrollTrigger.matchMedia({
      '(min-width: 800px)': setScrollBase,
      '(max-width: 799px)': setScrollBase
    });
    ScrollTrigger.refresh();
  } // Main function.


  function update(wineScapeImg) {
    state.scape.image = wineScapeImg;
    updateDimensions();
    setVisualStructure();
    updateTransforms();
    buildModelControls();
    setupLolliSlider();
    tweenWineScape();
    tweenGlassBottle();
    tweenBottleText();
    tweenBottleWave();
    tweenLolliChart();
    tweenBlackBox();
    tweenCleanup();
    tweenBottleEmpty();
    tweenBottleTextOut();
    tweenAnimals();
    tweenBottleFill();
    tweenBottleColour();
    tweenBottleGrid();
    tweenBottleGridColour();
    tweenBottleGridSort();
    tweenBottleGridOut();
    tweenDataset();
    tweenGlobe();
    tweenStats();
    tweenimportance();
    tweenModelBottle();
    setScroll();
    checkModelWave();
  }
  //    when racing back. So better safely removing it twice...

  var glass = 'M249.7 337.5c-.4 2-1.1 4.4-1.1 6.5 0 .7 0 1.4-.2 2-.4 1.4-.3 2.9-.8 4.2-.4 1-.4 2.7-.4 3.9 0 1.3-.3 2.5-.3 3.8 0 2.6-.5 4.7-1 7.1-.5 2-1.2 4.9-1.2 7 0 2.3-.4 4.7-.5 7-.2 3.2-1.6 6.4-1.7 9.7 0 .7-.6 1.3-.6 2 0 .8 0 1.7-.3 2.5-.3 1.5-.5 3.2-.5 4.7 0 3.8-.5 7.6-.5 11.4 0 5.2-.6 10.1-.6 15.3 0 2.4 1 5 1.6 7.1.6 2 0 4.9 0 7 0 3.4 1.4 6.6 1.4 10 0 .8.6 1.3.6 2s.1 2.2.5 2.8c.4.5.1 1.7.4 2.3l.7 2c2.3 4.7 4.4 9.3 7 13.7.9 1.6 2.5 3 4.1 3.8 1.7 1 2.3 3.4 3.7 4.6.3.3.9.3 1.3.6.5.4.8 1 1.3 1.3.8.5 1.3 1.3 2.1 1.8 1.4.7 1.6 3 2.8 4.1 2.1 1.8 3.8 4 6 5.5 1 .7 2.4 1.6 3 2.5.8 1 2.9 1.6 3 3 .1.8 1 1.6 1.2 2.3.4.8 0 1.7.3 2.6.4 1.4 1.2 3 1.3 4.5.1 1.6 1 3.1 1.4 4.7l1.3 5.5c1 4.4 1 8.5 1 13 0 3.6 1.1 7.1 1.3 10.7.1 2.3 1 6-.9 8-.8.8-1.2 2.2-1.7 3.3-.4.8-1 1.5-1.5 2.2-.4.5-.4 1.3-.7 1.7-1.2 1.4-1.2 3.7-3 4.8-1.4.8-2 2.2-3.4 2.9-.5.3-4.5 3.3-4.2 3.9.7 1.4 1.9 2.5 2.6 3.9.7 1.1 1.6 1.6 2.2 2.7 1.2 2.1 2.9 4 2.9 6.6 0 1-.6 3.4.8 3.4l3.9.3c.5 0 2.4.3 2.7.7.3.2 3 .4 3.4.4h4c4 0 7.7-.4 11.5-.6 4.7-.2 8.9-2 13.7-2 2.6 0 5.1-.7 7.7-.7 2.2 0 4.3 0 6.3-.4 3.9-.9 7.8-1.6 11.6-2.1 1-.1 1.3-2.8.6-3.4-.3-.2-.3-.8-.8-1l-1.7-1c-1.3-.8-3.3-.4-4.8-.4-1.8 0-3.6-.8-5.3-.9-1.3 0-4-.9-5.3-1.6-1-.6-2.6-.8-3.7-.9-1.3 0-3-.8-4.1-1.3-2-1-4.3-1.1-6.2-2.6-.8-.5-1.3-1-1.8-1.6-.4-.4-.7-1-1.2-1.4-.5-.3-1.3-.4-1.7-1-1.3-1.4-3-2.3-4.3-3.7l-1.6-1.5c-1-1-1.2-2.2-2-3.3a19.3 19.3 0 01-3.7-11.2c-.1-3.5-1.3-6.9-1.4-10.3v-10c0-5.2.5-10 .5-15 0-2.4.5-5.5 1.5-7.6.7-1.3.7-2.5 1.6-3.6 1.5-2 2-4.5 3.8-6.4 1.7-1.6 3.6-2.3 5.5-3.5 2.1-1.3 4.2-3.5 6-5.3 2-2 4.6-3.6 6.7-5.7.6-.6 1-1.6 1.4-2.3 1.1-1.7 2.2-3.5 3.1-5.3.8-1.4 2-2.5 2.8-4a44 44 0 003-5.8c.5-1.2.7-2.2.9-3.4.3-2.1 1-4.2 1.4-6.3.4-2.6 1.4-5.1 1.9-7.8 1-6 .8-11.6.8-17.7 0-2.6.1-5.5-.7-8-1-3.5-1.4-6.4-1.5-10 0-1.6-.8-3-1-4.5-.3-1.4-.6-3-.7-4.4-.1-2.5-.5-5-.8-7.4l-.3-3.6c0-.6-.7-1.3-.8-2-.3-2.1-.8-4.2-1-6.3l-.9-3.7c-.7-2.5-.4-5.4-1-8-.7-2.4-.6-4.8-1-7.4-.3-1.3-.3-2.6-.6-4-.1-.9-.7-1.7-.7-2.7-.2-2.2-1.5-4-2-6.2-.3-1.6-.8-3-1.4-4.6-.7-2.2-1.3-4.5-1.3-6.8l-.3-3c0-1-.5-.7-1.3-1-2.5-.5-5-.6-7.5-.6-1.3 0-2.3.7-3.6 1-1 .3-2.2 0-3.2.2a96 96 0 01-15.1 1.3l-13.2-.3c-3.2 0-6.8-.5-10 0-5.2 1-10.9.4-15.6 2.8';

  var bottle = 'M1 135V230.5L3.5 234.5L7.5 236L11 237H52H54.5L61.5 236H64L65.5 234.5L66.5 233L67.5 230.5V206L66.5 135L65.5 129L64 121.5L62.5 115L60.5 107.5L57.5 99.5L53 89.5L50 80.5L47.5 70L45.5 63L44.5 55.5V12L45.5 10.5V8.5L44.5 4.5V1H42H24V4.5L23 6.5V15L24 18V22.5L23 28.5V44.5V54L22 59.5L21 66L19 75.5L17.5 83L15 89.5L12.5 95L10.5 99.5L8.5 104.5L6.5 108.5L3.5 118.5L2 126L1 135Z';

  var textBottle = 'M5 132.7c3.7 0 6 1.5 9.4 2.2 1.6.4 2.8 1.1 4.6 1.1h5.5c4.2.2 8.4.7 12.7.7h6c1.8 0 3.6-.9 5.3-1 3.8-.5 7.3-2.6 11-3 .9 0 3.6-1.5 3.6 0v23.5c0 5.5.4 10.8.4 16.2 0 4 .9 8 .5 11.8-1 11.4-.9 23-.9 34.5v3.7c0 1.3-2 2-3 2.4-4.3 1.8-8.2 3-12.6 3.8-3.6.6-7.8-.6-11.4 0-4.8.8-9.2.1-14.1 0-3.2 0-6.6-1-9.5-2-1.5-.5-2.7-.5-4-1.1l-2-.7c-1.5-.6-1-5.4-1.2-7C4.2 211.1 4 204.6 4 198v-35-21.9c0-3 .7-6.2.7-9.2m-1.2 1.4c1.7 0 3 .8 4.7.8 1 0 2 .9 3 .9 2.2 0 4.2.8 6.4.8l16.3.3h7.8c1.6 0 3 .3 4.5 0s3.3-.8 4.8-.9l1.6-.4c.8-.2 1.5 0 2.2-.2 1.2-.3 2.6-.1 3.8-.5l2.8-.8c.7-.2 2.5.4 2.8-.3m-1.9-.8c0 3.4.3 6.6.3 10v14.2c0 1.7-.2 3.2.2 4.8.6 2.7 1.6 5.6 1.1 8.4-.2 1.8-.2 3.6-.2 5.5v17.1c0 5.1-1.4 10.3-1.4 15.4 0 3.3.6 6.5.6 9.8v7.8m.8-2.5c-3 1.2-5.4 2.7-8.4 3.3-2.5.6-5.3 2-7.9 2-2.9 0-5.7.3-8.6.3-2.8 0-5.7.8-8.5.8H27c-1.4 0-2.6.1-4-.2-1.2-.3-2.2-.1-3.5-.5-.8-.3-2.1-.2-3-.5-.5-.2-1.5-.1-2-.2-1.2-.1-2.5-1.1-3.7-1.1-1.5 0-2.6-1-3.8-1.4-.9-.2-1.8-2-1.8-2.7 0-1.3-.3-2.6-.3-4 0-3-.6-5.9-.6-8.9v-10c0-3.5-.5-6.8-.5-10.3V176 163v-6.8-3.8c0-.8.5-1.5.5-2.3l.3-9v-5-2.5c0-.5-.5-1-.5-1.4m16.1 65.5V194.4a49.4 49.4 0 010-1.6l-.1-5v-.6a42.2 42.2 0 01-.1-2l.1-.1h.1l.2-.1a2.6 2.6 0 011.2.3c.4.2.7.5 1 .9a4.4 4.4 0 01.6 2.5 6 6 0 01-1.5 4 2 2 0 01-.6.3l-.3.1v3.2a107.2 107.2 0 010 3.8l-.3.1h-.1l-.1-.7a72.7 72.7 0 000-1.7zm.5-5.5h.4v-.1l.1-.1.2-.2a4.3 4.3 0 001.3-3.2 5 5 0 00-.4-2 1.8 1.8 0 00-1.8-1.1 70.3 70.3 0 00.2 6.7zm5.3 8.2h-.2l-.4-.1-.1-.1v-.2h.2v-.1h.6l.1-.1v-.4a42.2 42.2 0 000-2.2v-2.2a28.4 28.4 0 010-2.3v-2.3a23.4 23.4 0 000-2.3h-.5-.4-.1-.1c-.3 0-.4 0-.4-.2v-.1l.2-.2h.2a14.2 14.2 0 012.4.2c.3 0 .4.2.4.3v.2h-.5-.6v1a150.6 150.6 0 010 2.3v2.4a29.9 29.9 0 000 4V198.8a3.3 3.3 0 00.1.8.2.2 0 000 .2h1l.5.1a.2.2 0 010 .2V200.4h-.2l-.1.1a1.4 1.4 0 01-.4 0H27.1a1 1 0 01-.4.2l-.4-.1-.1-.1a.6.6 0 00-.2 0zm9 0a8.3 8.3 0 00-.4-1.4l-.3-.9-.4-1-.3-.8v-.2l-.2-.5a184.3 184.3 0 00-2.3-6 3.3 3.3 0 00-.1 1 7.7 7.7 0 000 1.3v1.2a4.7 4.7 0 000 .5v1.4a134.3 134.3 0 00.1 3.6V200.6a1 1 0 01.1.3.4.4 0 01-.2.4h-.2c-.2 0-.4-.3-.4-1v-.7l.1-.7a78.9 78.9 0 00-.1-6v-1.4a73.7 73.7 0 00.1-1.8v-.2-.4l.2-.7.2-.2h.2l.2.2v.1l.1.2.3 1a31.1 31.1 0 001.6 4 52 52 0 012.1 6.3h.1a75 75 0 00.5-10.8v-.2-.1-.2c0-.3 0-.4.2-.4l.2.1h.1l.1.5v1.5a50.5 50.5 0 01-.3 6.1 185 185 0 01-.4 4.7h-.3l-.3.1h-.1v-.1H35a2 2 0 01-.1-.5v-.1zm4.1-6.2v-.6-1.6c.2-2.5.6-3.8 1.3-4a.7.7 0 01.2 0 1 1 0 01.2.1l1.3.3.2.1c.2.1.4.3.5.7.3.4.5 1 .7 1.8l.2 2.4v.1a36.3 36.3 0 000 1.1v1.3a22.1 22.1 0 01-.2 2.8l-.3 1.1a4.3 4.3 0 01-.4.9l-.6.6-.5.2h-.3c-1.5 0-2.3-2.4-2.3-7.3zm3.7-3.1V190.9c0-.6-.2-1-.5-1.5a1.4 1.4 0 00-1.6-.6c-.3.1-.6.4-.7.8v.9a11.9 11.9 0 01-.2 2 10.6 10.6 0 010 .9v1a14 14 0 000 .7v.8a15.7 15.7 0 00.6 4.2 2.9 2.9 0 00.4.7c.2.2.4.2.6.2.4 0 .7-.2 1-.7l.1-.3c.3-.8.4-1.5.5-2.3a33.5 33.5 0 00-.2-6.5zm5 9.3l-.3-.1v-.7a9.8 9.8 0 010-.7 3.3 3.3 0 010-.4v-.3-.2-.3-.8a150.3 150.3 0 00-.5-8.9 17.5 17.5 0 01-1.7 0l-.3-.2v-.1l.1-.2H45.4a26.3 26.3 0 013.4.1h.8c.3 0 .4.1.4.3l-.1.2a.6.6 0 01-.3 0 8.6 8.6 0 01-.9 0h-.9v.4a104.5 104.5 0 00.3 7.7 100.6 100.6 0 010 4.1l-.1.1h-.3zM25.3 217h1.3v-.1-.2a127.4 127.4 0 00-.3-9.5V206a1.3 1.3 0 000-.4h-.1l-.1-.1H25.3h-.1-.2a.2.2 0 010-.2v-.1h.3l.1-.1H26.8v.1l.1.1v.6a15.4 15.4 0 000 1.5v1.8a83.2 83.2 0 00.3 5.3V216.8h.9l.4.1v.2c0 .1 0 .2-.3.2h-1.3a26.7 26.7 0 01-1.6 0v-.3-.1h.1zM32 219l-.1-.2.1-1V215.1a156.4 156.4 0 00.1-2.3v-1-.8h-.1c-.4 0-.8-.1-1-.3-.4-.2-.6-.5-.8-.8a3.3 3.3 0 01-.5-2.6c0-.4.2-.7.4-1l.5-.4.7-.2h.4l.2.1h.1l.2.1.3.2v3.7a21.5 21.5 0 000 1.2 2 2 0 000 .4v2.8a179.8 179.8 0 00-.1 2.6V217.5a11.4 11.4 0 00-.1.8v.2l-.1.4-.2.1zm-.1-8.4h.2a69.7 69.7 0 00-.1-4.3c-.1-.2-.3-.2-.5-.3h-.5c-.3.1-.5.3-.6.5-.2.1-.2.3-.3.5v.6a3.6 3.6 0 00.2 1.3 4 4 0 00.6 1.2l.3.2c.2.2.5.3.7.3zm4.7.4H36h-.2l-.2.1a.4.4 0 01-.2 0l-.2-.2v-.5-.9a10.4 10.4 0 00-.1-1.8 19 19 0 01-.2-1.7l.2-.1H36.8v.2l-.2.1h-1.1a9 9 0 000 1.6 43.3 43.3 0 00.2 2.7h.3l1.1.3.2.2.4.9.3 1.8a11.7 11.7 0 01-.1 3.7 3.5 3.5 0 01-.3.6l-.3.4-.5.4h-.3c-.3 0-.5 0-.5-.2a.2.2 0 01-.1 0 .1.1 0 010-.2h1a.8.8 0 00.2-.2l.3-.7a10 10 0 00.3-1.5 25.4 25.4 0 00-.3-3.6 5.7 5.7 0 00-.4-1 .8.8 0 00-.3-.4h-.2zm-1.1-3.1zm5.4 9v-.2H41.2a1.8 1.8 0 01.3.3l.2.1a1 1 0 001-.6l.2-1.5a21.1 21.1 0 00-.2-2.8 4.8 4.8 0 00-.8-1.4v-.2h-.2-.4v-.1l.1-.3a14.8 14.8 0 01.5-.7l.3-.4.1-.8a9.5 9.5 0 00-.3-2.1 1.7 1.7 0 00-.3-.6l-.1-.1a.6.6 0 00-.4-.1l-.4.1-.1.2-.1.2-.1.1-.3.3h-.2l-.1-.2.2-.3.4-.5a1.2 1.2 0 01.8-.3l.4.1.3.3c.2.2.4.5.4.8a7 7 0 01.3 2.3c0 .3 0 .6-.2 1l-.3.2a12.6 12.6 0 00-.3.5 1.4 1.4 0 01.8.9l.1.1a10.7 10.7 0 01.5 2.3 11 11 0 010 1 12.2 12.2 0 01-.1 1.7l-.1.4-.3.4a1.2 1.2 0 01-1 .4 1.5 1.5 0 01-.8-.3l-.1-.3zm-24.9-53.5v-2a63 63 0 00-.1-7V153a30.5 30.5 0 000-3.1l-.1.2a75.5 75.5 0 01-1.5 8.2 37.4 37.4 0 00-.6 2.4v.1h-.2l-.1.1h-.2a.6.6 0 01-.2-.3v-.4l-.1-.5a254.4 254.4 0 00-2.1-10.2 111.3 111.3 0 000 4.3 245.4 245.4 0 000 7v.1a15.2 15.2 0 000 .9v1.5a.5.5 0 01-.6-.3l-.1-.8v-5.7a100 100 0 000-4.8l.1-2.6v-1.9-.1a.4.4 0 01.2-.1H10.6v.1a106.8 106.8 0 012.8 12.3l.2-.8.1-.8v-.3a377.4 377.4 0 01.4-1.9l1-5.3.2-1 .2-1.3.1-.6.1-.4h.1l.2-.1h.1v.1l.2.2v2.2a39 39 0 00.1 5 101.8 101.8 0 01.3 6.5 201.8 201.8 0 010 2.9l-.3.1-.4-.1v-.1a1 1 0 010-.4zm4-12.8v-.3c.3 0 .5.3.5.8v.4l.1 5.7a33.7 33.7 0 00.3 4.6v.8c.1.7.4 1.2.8 1.5.3 0 .5.2.8.1a.6.6 0 00.5-.3c.3-.5.6-1.8.7-3.7v-.9a796.3 796.3 0 00.2-8.7V150.3a.7.7 0 010-.2c0-.1.1-.2.4-.2l.3.1V150.8a33.6 33.6 0 01-.1 2.2v1l-.1.8v.2a.6.6 0 010 .2 12 12 0 000 1.5l-.1 3.6c0 1.2-.2 2.3-.5 3.1-.2.5-.4.9-.7 1.1a1.3 1.3 0 01-1.2.3 1.7 1.7 0 01-.4-.2 2.6 2.6 0 01-.7-.5l-.1-.3-.4-2a43.2 43.2 0 01-.2-6.7 79 79 0 00-.2-4.5zm7.4 14.6l.1-.1h.5l.3.1a1.1 1.1 0 00.8-.4l.4-.5.2-.4a9 9 0 00.3-2.2 6.6 6.6 0 00-1-3.1 76 76 0 01-1.3-3 6 6 0 01-.3-1.7 4.8 4.8 0 01.4-1.8 2.2 2.2 0 01.5-.8l.3-.2.5-.1h.4l.2.2.2.2v.2a.1.1 0 010 .1h-.2-.1-.2a.7.7 0 00-.2 0l-.5.1-.4.5v.3a5.8 5.8 0 00-.3 1.4v.9a2.8 2.8 0 00.1.3l.2.4v.4l.2.4a2 2 0 00.2.3l.1.2.3.5a14.2 14.2 0 011.2 2.5 8 8 0 010 4l-.3.7a2.5 2.5 0 01-.9.9 1.7 1.7 0 01-.9.2H28l-.4-.1a.5.5 0 01-.3-.3zm2.4-13.5zm3.8 13.6h-.2l-.5-.1-.1-.1v-.2h.2v-.2h.7l.1-.3v-.2a45.7 45.7 0 000-2.4v-.8l-.1-1.5a31 31 0 010-2.6l.1-2.5a25.7 25.7 0 00-.1-2.5H32.7a1.6 1.6 0 01-.3 0c-.2 0-.3 0-.4-.3v-.1l.2-.1.3-.1a15.8 15.8 0 012.6.3c.3 0 .5.2.5.3l-.1.2H34.3v1.1a160.2 160.2 0 010 2.6v2.6a32.8 32.8 0 00.1 4.3v.7a1.8 1.8 0 000 .4 6.2 6.2 0 000 .5v.1a.2.2 0 00.1.2h1.1l.5.1a.2.2 0 010 .2V165.2l-.2.1h-.2a1.7 1.7 0 01-.3 0 2.6 2.6 0 00-.4 0h-.3a1 1 0 01-.5.2 1 1 0 01-.5 0v-.2a.7.7 0 00-.2 0zm4.5-8l.1-1.4a33.4 33.4 0 01.3-2.4 3.3 3.3 0 01.6-1.5c.2-.3.5-.5.8-.6l.6-.1h1a.2.2 0 01.1.2l-.1.3h-.2-.5a1 1 0 00-.7.2l-.3.3a2 2 0 00-.2.4 8.6 8.6 0 00-.6 2.1 29 29 0 00-.2 2.4v1.7a27.2 27.2 0 00.1 1.7 2.1 2.1 0 01.2.6 23.7 23.7 0 01.2 2.4v.2a1.9 1.9 0 00.6.9l.5.2a2.1 2.1 0 00.7.1l.4-.1c.2-.1.4-.3.5-.6l.3-1.5a35.8 35.8 0 000-1.6V160l-.1-.1-.5-.1h-.3-.2c-.3 0-.5 0-.5-.3v-.1c.1-.2.3-.2.5-.2h1.1l.6.2h.1l.2.1V159.8a4 4 0 01-.1.6l-.1.8a28.1 28.1 0 000 3.3 5 5 0 01-.6.6l-.8.4-.8.2c-.6 0-1.1-.1-1.4-.3-.3-.1-.5-.4-.7-.8v-.1a56 56 0 01-.6-7.2zm12.5 6.5a9 9 0 00-.4-1.7l-.3-.9-.4-1.1-.3-.8-.1-.3-.2-.5a214 214 0 00-2.4-6.5 3.6 3.6 0 00-.2 1 8.5 8.5 0 000 1.4v1.3a5.2 5.2 0 000 .5v.9l.1.7a133.6 133.6 0 000 4v1.9l.2.1a1.1 1.1 0 010 .3.4.4 0 01-.3.4h-.1c-.3 0-.5-.3-.5-1V162.7l.1-.7a85.9 85.9 0 00-.1-6.6 54.6 54.6 0 01.1-3.5v-.2-.5l.2-.7.2-.2h.3l.2.1v.2l.1.2c0 .4.2.7.3 1a34 34 0 001.8 4.5 57 57 0 012.3 6.9 81.9 81.9 0 00.6-11.8v-.3-.3c0-.3 0-.4.2-.4h.3v.2l.2.4v1.4l-.1.2a54.8 54.8 0 01-.3 6.7 189.1 189.1 0 01-.4 5.1l-.4.1H51h-.1-.1l-.1-.1a2 2 0 01-.1-.5v-.1zm6.2-5.8l-.1-1.5-.2-.3v-.2a7 7 0 01-.3-1 169.7 169.7 0 01-1.7-5.3l.3-.2.6 1.4.6 1.9.2.8a21.1 21.1 0 00.6 1.4v-.5l.1-.2a7.8 7.8 0 00.4-1.4 59 59 0 011-3.7.3.3 0 01.3 0v.2a13 13 0 01-.6 2.5 30.2 30.2 0 00-.8 4v.1l.1.3a1.2 1.2 0 010 .3.9.9 0 00-.1.3 30.8 30.8 0 00.2 2 70.3 70.3 0 000 1.6v2.3c0 .5-.1.8-.3 1a.3.3 0 01-.2 0h-.1l-.2-.2.1-.3a22.1 22.1 0 000-4.8v-.5z';

  var textAlcohol = 'M4 12h-.3V9.6l-.8-.3-1.3-.1v.2l-.2.4-.3 1.6-.1.3c0 .1 0 .2-.2.2l-.2-.1v-1a27 27 0 00.6-2.3L1.7 6l.1-.5A52.7 52.7 0 013 .7l.4.2.2 1.5L4 5l.2 2.5a31.1 31.1 0 00.2 4v.3l-.4.1zm-.7-2.9l.3-.1a41 41 0 00-.4-6.6v-.6L3 1.7v-.2l-.3.9A51.2 51.2 0 002 7.1l-.1.6-.3 1V9l1.5.2h.2zm3.3 3.1c-.1 0-.2-.1-.2-.3v-.5a269.1 269.1 0 01.1-8v-1l.2-.1h.2v2.8a79.3 79.3 0 010 2v.3a12.3 12.3 0 000 1.3v2.9h.8l.5.1h.4v.3l-.2.2H7h-.3zm4.6 0l-.5-.3-.4-.5c-.2-.4-.3-1-.3-1.8V7a28.9 28.9 0 01.1-3l.3-1 .5-.6.4-.2.4-.2h.7l.1.1v.1l-.1.3h-.7c-.2 0-.3 0-.5.2s-.3.5-.3.7l-.2 1a8.5 8.5 0 00-.2 1.5v4.3c0 .4.2.7.5 1 .2.4.6.5 1 .5H12.6c0 .1 0 .2-.2.3l-.3.2h-.9zm4.7 0c-1.1 0-1.7-1.8-1.7-5.4v-.6c0-2.8.3-4.1 1-4.1h.3l1 .2c.1 0 .3.2.5.6.2.4.4.8.5 1.4l.1 1.8V8a14.3 14.3 0 01-.3 3l-.4.7-.4.4a1 1 0 01-.6.2zm0-.3c.4 0 .7-.3.9-.9.1-.5.3-1.1.3-1.7a22.7 22.7 0 00-.1-5V4c0-.4-.2-.8-.4-1.1a1 1 0 00-.9-.5c-.5 0-.7.2-.8.7v.6c0 .8-.1 1.3-.2 1.5V8a12.6 12.6 0 00.3 2.8c0 .3.2.6.4.8.1.2.3.3.5.3zm6.4.3c0-.1-.2-.2-.5-.2V8h-.1v-.2-.6h-1l-.5-.1H20a26.7 26.7 0 010 2 25.8 25.8 0 00.1 2.5v.3h-.2c-.2 0-.3-.2-.3-.8V8.3 7v-1-3.5-.2l.2-.1c.2 0 .3.3.3.9a102.3 102.3 0 010 3.6c0 .1.3.2 1 .2h.1l.4-.1.2-.4-.1-2a34.8 34.8 0 010-2.3H22a98.7 98.7 0 00.3 7v3.2zm-1-5.6zm4.7 5.7c-1.1 0-1.7-1.9-1.7-5.5v-.6c0-2.8.3-4.1 1-4.1h.3l1 .2c.1 0 .3.2.5.6l.4 1.4c.2.6.2 1.2.2 1.8V8a14.3 14.3 0 01-.3 3l-.4.7-.4.4a1 1 0 01-.6.2zm0-.5c.4 0 .7-.2.8-.8l.4-1.7a22.7 22.7 0 00-.1-5V4c0-.4-.2-.8-.4-1.1a1 1 0 00-1-.5c-.4 0-.6.2-.7.7v.6c0 .8-.1 1.3-.2 1.5V8a12.6 12.6 0 00.3 2.8c0 .3.2.6.3.8l.6.3zm4 .4c-.2 0-.3-.1-.3-.3v-.5a269.1 269.1 0 010-8l.1-.6v-.4l.2-.1h.2v2.8a79.3 79.3 0 010 2v.3a12.3 12.3 0 000 1.3v2.9h.8l.5.1h.4v.3l-.2.2h-1.5-.3z';

  var textAcids = 'M4 12h-.3V9.6l-.8-.3-1.3-.1v.2l-.2.4-.3 1.6-.1.3c0 .1 0 .2-.2.2l-.2-.1v-1a27 27 0 00.6-2.3L1.7 6l.1-.5A52.7 52.7 0 013 .7l.4.2.2 1.5L4 5l.2 2.5a31.1 31.1 0 00.2 4v.3l-.4.1zm-.7-2.9l.3-.1a41 41 0 00-.4-6.6v-.6L3 1.7v-.2l-.3.9A51.2 51.2 0 002 7.1l-.1.6-.3 1V9l1.5.2h.2zm4.2 3c-.2 0-.4-.1-.5-.3l-.4-.4c-.2-.4-.3-1-.4-1.8V7a28.9 28.9 0 01.2-3l.3-1 .4-.6.5-.2.3-.2H8.8v.2l-.2.3H8c-.2 0-.4 0-.5.2l-.4.7-.2 1a8.5 8.5 0 00-.1 1.5v4.3c0 .4.2.7.4 1 .3.4.6.5 1.1.5H8.9c0 .1 0 .2-.2.3l-.4.2h-.8zm4-.1c-.3 0-.4 0-.4-.2h-.7l.1-.3h.5v-.1l.1-.1V11 7.8 4.3 2.6h-.7-.2c-.2 0-.3-.1-.3-.3l.2-.1h.2a10.9 10.9 0 011.8.1c.2 0 .3.2.3.3l-.4.1h-.5V7a26.8 26.8 0 000 3.3v.5l.1.4c0 .1.1.2.3.2h.5c.3 0 .4 0 .4.2v.2H12l-.3.1-.2.1zm3 0l-.1-.3a46.6 46.6 0 010-4.4V5.5a81.3 81.3 0 00-.1-3.3l.2-.1h.2l.2.2.3.1.4.1c.2 0 .3.2.6.5l.5.4.2.4.3.5a5.5 5.5 0 01.2 2v1.2a26.1 26.1 0 00-.3 2.6c0 .3-.2.5-.3.7-.2.5-.7 1-1.3 1.3h-1zm1-.4l.2-.2.2-.1c.7-.7 1-1.9 1-3.6v-.3-1.8c0-.6-.2-1.2-.5-1.8a2 2 0 00-.7-.7c-.2-.2-.5-.3-.8-.3l-.1 2.7.1 5.6v.3l.1.2h.5zm4 .6l-.2-.2c-.1 0-.2 0-.2-.2v-.1h.3l.3.1c.2 0 .4 0 .6-.3.2-.1.3-.4.4-.6l.2-1.5c0-.7-.2-1.4-.6-2.2a36.6 36.6 0 01-1-2 4 4 0 01-.2-1.2c0-.4 0-.8.3-1.3l.3-.6.6-.2.4.1.2.3-.2.1h-.2-.2l-.4.1-.2.5-.2 1v.6a2 2 0 00.1.2l.1.3v.3l.2.3v.2l.2.1.2.3a9.3 9.3 0 01.8 1.8 5.8 5.8 0 01.2 1.5c0 .5 0 .9-.2 1.3-.2.5-.4.9-.8 1l-.6.3h-.1zm1.3-9.8z';

  var textSugars = 'M1.7 12.3h-.4H1a.6.6 0 01-.3-.3c0-.2 0-.2.2-.2h.4l.4.2c.2 0 .4 0 .6-.3.2-.1.4-.4.5-.7a4.7 4.7 0 000-3A7.3 7.3 0 002 6.1a48 48 0 01-.9-2L1 2.5c0-.4 0-.7.2-1 0-.3.2-.6.5-.8.2-.2.5-.3.8-.3l.5.1.2.3V1h-.3L2.5.8c-.2 0-.4 0-.6.2l-.4.7v.6A5.2 5.2 0 002 4.8L2.5 6l.2.3a15.2 15.2 0 01.7 2l.2 1.4a4 4 0 01-.5 1.8 2 2 0 01-.6.7l-.8.2zm5.5 0a1 1 0 01-.5-.2l-.5-.4-.3-1.5a37.3 37.3 0 01-.2-3.4V2c.2 0 .3.3.3.9v4a30.2 30.2 0 00.3 3.1c0 1.2.3 1.7 1 1.7.5 0 .8-1 1-3.1v-.3V2 2c0-.1.1-.2.3-.2l.2.1v3.7a8.3 8.3 0 00-.1 1V9l-.4 2.2c-.3.6-.6 1-1.1 1zm5.7-.2c-.5 0-.8 0-1-.2-.3 0-.4-.3-.5-.6a21.3 21.3 0 01-.4-5v-1l.2-1.7c.1-.4.2-.7.5-1 .2-.3.5-.5 1-.5h.3c.3 0 .4 0 .4.2v.1l-.3.1H12.8l-.4.1-.4.5-.4 1.5-.1 1.6v2.2l.2.6v1c0 .3 0 .6.2.8 0 .3.2.5.3.6.2.2.5.3.9.3.3 0 .5-.2.6-.5l.2-1v-2c0-.1-.2-.2-.5-.2h-.2l-.4-.1c0-.2.1-.3.4-.3h.7l.5.1.1.2v.6l-.1.5a19.6 19.6 0 000 2.3c-.5.5-1 .8-1.5.8zm6.3 0h-.3l-.1-.3-.2-1.4v-.6h-1.4l-.5-.1-.1.1v.3a10.8 10.8 0 01-.4 1.7c0 .2-.1.3-.2.3l-.2-.1-.1-.2.5-2.2.2-1 .1-1 .2-1a49.7 49.7 0 01.6-3.3 15.5 15.5 0 01.2-1.3h.6l.1.2a14.9 14.9 0 00.2 2.4l.9 7.3-.1.2zm-.7-2.7l-.6-6.3-.8 4-.4 2.1.6.2h1.2zm4.7 2.8l-.4-1a25.9 25.9 0 01-.7-3.6l-.4-.8c-.2 0-.4 0-.4.2a66.5 66.5 0 00.3 4.9l-.1.2H21.2A330.2 330.2 0 0121 2l.2-.1c.6 0 1 .1 1.3.4.3.2.4.6.4 1v1.1c0 .2 0 .5-.2.8 0 .3-.2.6-.4.9l-.2.4a142.2 142.2 0 001.3 5.7l-.2-.1zm-1.8-5.8c.2 0 .4 0 .5-.3.2-.1.3-.4.4-.7.2-.6.2-1 .2-1.4a3 3 0 00-.1-1c-.2-.4-.4-.6-.9-.6l-.1.1v.3a49.5 49.5 0 000 3.6zm4 5.8c-.1 0-.2 0-.3-.2-.1 0-.2 0-.2-.2l.1-.1h.3l.2.1c.3 0 .5 0 .6-.3.2-.1.3-.4.4-.6.2-.6.2-1 .2-1.5 0-.7-.2-1.4-.6-2.2a36.6 36.6 0 01-1-2A4 4 0 0125 4l.3-1.3c0-.2.2-.4.4-.6L26 2l.4.1.2.3-.2.1h-.2-.1l-.4.1-.3.5-.2 1 .1.6a2 2 0 000 .2l.1.3.1.3.1.3.1.2.1.1.2.3a9.3 9.3 0 01.8 1.8 5.8 5.8 0 01.2 1.5c0 .5 0 .9-.2 1.3-.2.5-.4.9-.8 1-.1.2-.4.3-.6.3zm1.2-9.8z';

  var textQuality = 'M4.4 14H4a.6.6 0 00-.2-.1.9.9 0 01-.4-.5l-.2-.9a4 4 0 00-.2-.7 1.8 1.8 0 01-1.4-.5 4 4 0 01-.8-2v-.8V7v-.7a52.3 52.3 0 01.3-4c0-.5.2-1 .4-1.4.2-.4.5-.6.9-.6.3 0 .7.2 1 .5.4.3.6.6.6 1 .3 1.5.4 3.5.4 5.8a7 7 0 01-.9 4v.2l.1.2v.4l.2.6.1.3.4.2c.4 0 .5 0 .5.2s-.1.3-.5.3zM3 11.5c.3 0 .6-.5.8-1.4L4 5.5V3.8L3.9 3l-.1-.7c0-.4-.2-.8-.5-1a1 1 0 00-.9-.5c-.1 0-.3 0-.4.3-.2.4-.3 1-.5 2.1a24.2 24.2 0 00-.1 3.5v.9a8.5 8.5 0 00.4 2.7l.5.7c.2.2.4.3.7.3zm5.2.8a1 1 0 01-.5-.1l-.5-.4-.3-1.5a37.3 37.3 0 01-.2-3.4l-.1-4.5v-.2c.3 0 .4.3.4.9v4a30.2 30.2 0 00.2 3.1c0 1.2.4 1.7 1.2 1.7.4 0 .7-1 .9-3.1v-.3V2 2c0-.1.1-.2.3-.2l.2.1v3.7a8.3 8.3 0 00-.1 1V9l-.4 2.2c-.3.6-.6 1-1.1 1zm6.9 0l-.3-.1-.1-.3-.2-1.4v-.6h-1.3l-.6-.1v.1l-.1.3a10.8 10.8 0 01-.4 1.7c0 .2-.1.3-.2.3l-.2-.1v-.2l.4-2.2.2-1 .2-1 .1-1a49.7 49.7 0 01.6-3.3 15.5 15.5 0 01.2-1.3h.7v.2a14.9 14.9 0 00.2 2.4l.9 7.3-.1.2zm-.7-2.8l-.6-6.3-.8 4-.3 2.1.5.2h1.2zm2.7 2.8c-.2 0-.2-.1-.3-.3v-.5a269.1 269.1 0 01.1-8v-.6l.1-.4.1-.1h.2v2.8a79.3 79.3 0 010 2v.3a12.3 12.3 0 000 1.3v2.9h.9l.5.1H19v.3l-.1.2h-1.3-.5zm4.3-.2c-.3 0-.4 0-.4-.2h-.7l.1-.3h.5v-.1l.1-.1V11 7.8 4.3 2.6h-.7-.2c-.2 0-.3-.1-.3-.3l.2-.1h.2a10.9 10.9 0 011.8.1c.2 0 .3.2.3.3l-.4.1h-.5V7a26.8 26.8 0 000 3.3v.5l.1.4c0 .1.1.2.3.2h.5c.3 0 .4 0 .4.2v.2h-.8l-.3.1-.2.1zm3.7-.2v-.6a8.7 8.7 0 010-.8v-.2-.4a82 82 0 00-.4-7.3h-1.2l-.3-.3c0-.1.1-.2.3-.2a20.1 20.1 0 012.6.2h.6c.2 0 .3 0 .3.2l-.1.1h-.3a7 7 0 01-.6 0h-.6l-.1.3a92.8 92.8 0 01.2 9l-.2.1-.2-.1zm4.5.4h-.2V12 9.4 7.2l-.1-.3v-.2a15.3 15.3 0 01-.6-1.7 23.4 23.4 0 01-.9-2.6l.3-.1.4 1 .4 1.2.2.6.4 1v-.3l.3-1.1.4-1.8c.1-.6.2-.9.4-.9l.2.2-.5 1.8a21 21 0 00-.6 2.7l.1.3v.4a14.7 14.7 0 000 1.4v2.4c0 .7 0 1-.2 1z';

  var blackBox = 'M56.7559 135.85C56.4469 135.664 56.3165 135.477 55.7541 135.08M12.4048 137.076C12.8044 136.409 13.3678 136.127 13.8549 135.607L12.4048 137.076ZM12.6102 136.936C13.1717 136.445 13.7076 135.765 13.9616 135.424L12.6102 136.936ZM12.7512 138.136C13.3738 137.786 13.9569 136.63 15.0434 135.076L12.7512 138.136ZM12.8485 138.113C13.2702 137.511 13.7596 137.181 15.4744 135.575L12.8485 138.113ZM12.8317 139.828C14.2231 138.184 15.3295 137.364 16.8359 135.264L12.8317 139.828ZM12.7065 139.932C14.2138 138.17 15.6883 136.535 16.4587 135.261L12.7065 139.932ZM12.9912 141.179C14.283 138.999 16.1605 137.97 17.8698 135.245L12.9912 141.179ZM12.7961 141.054C14.7253 139.162 17.0529 136.518 18.0587 135.464L12.7961 141.054ZM12.1583 143.089C14.8519 140.741 16.3924 138.824 19.4445 135.646L12.1583 143.089ZM12.8309 142.81C13.8623 140.952 15.6923 139.585 19.5462 135.703L12.8309 142.81ZM12.1767 144.504C15.6089 141.066 18.7547 137.907 20.7922 135.277L12.1767 144.504ZM12.3708 144.464C14.5833 142.224 16.9369 139.804 21.1754 135.533L12.3708 144.464ZM12.9673 145.249C16.1904 142.435 18.9286 138.917 22.1402 135.324L12.9673 145.249ZM12.4054 145.551C15.5196 142.65 18.0682 140.135 22.0147 135.247L12.4054 145.551ZM12.3573 147.458C16.7343 143.573 20.264 139.36 23.8137 135.41L12.3573 147.458ZM12.4534 147.06C14.9282 144.814 17.3482 141.926 23.8826 135.297L12.4534 147.06ZM12.3143 148.942C16.4286 144.371 19.7367 140.988 25.2098 135.937L12.3143 148.942ZM12.7624 148.636C17.3802 143.459 22.3135 138.319 24.983 135.502L12.7624 148.636ZM12.7036 150.33C15.6248 146.78 18.1659 143.855 25.9867 135.115L12.7036 150.33ZM12.6388 150.195C16.6766 145.855 20.4809 141.637 26.4494 135.435L12.6388 150.195ZM12.3076 151.326C18.2737 145.931 23.7883 139.714 28.1662 135.149L12.3076 151.326ZM12.6473 151.528C15.9415 148.367 19.1002 144.837 27.5447 135.555L12.6473 151.528ZM12.8261 153.097C18.9187 145.913 25.6228 138.479 28.9792 135.419L12.8261 153.097ZM12.7539 153.003C16.9471 148.408 21.6241 143.623 29.0757 135.188L12.7539 153.003ZM12.9692 154.417C17.1782 149.592 21.8598 144.182 30.2694 135.785L12.9692 154.417ZM12.814 154.59C17.1858 149.325 21.8333 144.424 30.6798 135.581L12.814 154.59ZM13.1258 156.091C18.7017 149.304 24.749 142.669 32.3814 135.536L13.1258 156.091ZM12.4261 155.703C19.8084 147.909 27.0911 140.501 32.1528 135.483L12.4261 155.703ZM12.7728 157.04C20.0254 149.464 27.4483 142.141 33.1345 135.733L12.7728 157.04ZM12.6514 157.534C19.2372 150.345 26.4036 142.764 33.3435 135.637L12.6514 157.534ZM13.0582 158.733C16.8822 153.85 22.0337 149.247 35.2701 135.275L13.0582 158.733ZM12.7375 159.058C17.9799 153.489 23.5188 147.648 34.9598 135.325L12.7375 159.058ZM12.9791 160.357C18.5016 154.449 24.6973 148.228 36.0379 135.16L12.9791 160.357ZM12.6936 160.374C17.9984 154.108 24.0959 148.397 35.8557 135.422L12.6936 160.374ZM12.3399 162.179C21.6005 152.136 30.0851 143.622 37.7731 135.52L12.3399 162.179ZM12.4759 161.971C19.2896 155.193 25.7716 148.204 37.4885 135.411L12.4759 161.971ZM12.7708 162.755C21.7734 154.048 29.7579 145.113 38.525 135.066L12.7708 162.755ZM12.6229 163.368C19.3989 156.551 25.7541 149.246 38.5977 135.482L12.6229 163.368ZM12.5289 165.116C18.6929 157.836 25.8124 150.902 40.5483 134.861L12.5289 165.116ZM12.5849 164.731C19.5193 157.108 26.5975 149.641 40.1835 135.474L12.5849 164.731ZM12.7322 166.284C22.2154 155.356 32.0195 145.002 41.9747 135.841L12.7322 166.284ZM12.4029 166.478C22.1339 156.465 31.3973 146.457 41.7509 135.525L12.4029 166.478ZM13.0158 167.363C24.4816 155.42 35.3928 143.413 43.0471 135.07L13.0158 167.363ZM12.4148 167.575C19.7953 160.036 26.4683 153.088 42.9878 135.677L12.4148 167.575ZM12.926 168.714C24.5085 155.981 36.2727 143.827 44.9053 135.825L12.926 168.714ZM12.7019 169.367C18.5623 161.988 25.2642 155.392 44.5149 135.623L12.7019 169.367ZM12.4168 170.537C23.1292 159.652 33.6793 147.83 45.7642 135.082L12.4168 170.537ZM12.9416 170.617C19.9223 162.701 26.9313 155.142 45.7671 135.641L12.9416 170.617ZM12.4116 171.862C24.2561 158.641 37.1527 146.107 47.6177 135.61L12.4116 171.862ZM12.568 172.225C25.0059 159.216 37.3614 146.236 46.9575 135.481L12.568 172.225ZM12.1113 173.868C19.9679 165.103 27.933 157.077 48.6638 135.454L12.1113 173.868ZM12.6683 173.777C21.0822 164.652 29.2064 155.529 48.5736 135.316L12.6683 173.777ZM12.4501 174.558C24.3074 162.672 36.0033 150.538 49.8568 135.711L12.4501 174.558ZM12.4616 174.91C20.9572 165.997 29.3737 156.92 50.1246 135.232L12.4616 174.91ZM12.9295 176.117C23.6172 164.574 33.9232 153.306 51.4367 135.254L12.9295 176.117ZM12.7883 176.42C24.2141 163.725 36.1701 150.97 51.1146 135.368L12.7883 176.42ZM12.7542 178.019C24.6629 164.833 37.2102 150.993 52.8214 135.157L12.7542 178.019ZM12.6921 177.656C28.3105 160.783 44.0059 143.98 52.5432 135.448L12.6921 177.656ZM12.4238 179.369C24.1255 166.332 36.9738 153.328 53.8027 135.463L12.4238 179.369ZM12.7529 179.354C22.6275 168.086 32.7148 157.335 54.14 135.346L12.7529 179.354ZM12.9254 181.196C26.7687 165.593 41.0326 150.399 55.2629 135.379L12.9254 181.196ZM12.6714 181.066C21.5738 171.042 30.6956 161.167 55.5316 135.373L12.6714 181.066ZM12.9843 182.101C26.8962 167.109 40.9636 152.284 56.6165 136.022L12.9843 182.101ZM12.7192 182.273C25.8109 167.988 38.9761 153.839 56.4085 135.826L12.7192 182.273ZM12.7039 183.882C30.4222 165.673 47.7707 147.145 56.8197 137.267L12.7039 183.882ZM12.7355 184.009C27.7653 167.44 43.1412 151.339 56.9028 136.831L12.7355 184.009ZM12.4421 185.507C29.4547 167.567 46.3449 150.189 56.7677 138.6L12.4421 185.507ZM12.6692 184.998C24.8441 172.378 36.6006 159.886 56.7708 138.378L12.6692 184.998ZM13.0042 186.463C22.0301 176.3 31.5647 165.961 56.4973 139.858L13.0042 186.463ZM12.4367 186.915C23.9964 174.634 35.292 162.635 56.6992 140.1L12.4367 186.915ZM12.9151 188.517C30.6557 169.752 47.2534 151.32 56.5716 141.614L12.9151 188.517ZM12.4592 188.211C22.0642 178.208 31.4735 168.471 56.861 141.256L12.4592 188.211ZM12.8021 189.618C28.6517 172.432 45.4568 154.913 57.0001 143.332L12.8021 189.618ZM12.6942 189.627C26.3622 174.738 40.3381 160.007 56.5788 142.949L12.6942 189.627ZM12.6303 191.35C22.2815 179.802 32.5994 168.843 56.616 143.974L12.6303 191.35ZM12.721 190.987C27.1498 176.181 41.1813 161.108 56.7459 144.468L12.721 190.987ZM12.7649 192.569C26.4938 177.173 40.9556 162.052 57.0171 145.712L12.7649 192.569ZM12.4852 192.578C25.5907 178.652 38.5975 165.112 56.5398 146.029L12.4852 192.578ZM12.8722 193.89C23.7317 181.859 35.5717 170.232 56.9052 147.569L12.8722 193.89ZM12.7848 194.013C24.5702 182.016 36.1827 169.435 56.6834 147.434L12.7848 194.013ZM12.1367 195.972C30.0227 178.006 46.4772 159.901 56.8837 148.994L12.1367 195.972ZM12.6586 195.609C23.5431 183.935 34.5678 172.38 56.591 148.747L12.6586 195.609ZM12.3766 196.901C29.5753 178.551 47.2072 160.792 56.284 149.965L12.3766 196.901ZM12.8285 197.12C23.8903 184.876 34.9005 173.666 56.76 150.384L12.8285 197.12ZM12.3577 198.483C29.3196 181.466 45.5278 164.218 56.3147 151.975L12.3577 198.483ZM12.6324 198.602C24.279 186.229 35.8339 174.285 56.789 151.58L12.6324 198.602ZM12.6142 199.493C22.8543 189.07 32.3565 178.699 56.8687 152.848L12.6142 199.493ZM12.6607 199.659C27.3852 184.742 41.8589 169.536 56.4934 153.324L12.6607 199.659ZM12.2654 201.326C26.8242 185.505 41.2117 170.253 56.324 154.693L12.2654 201.326ZM12.5139 201.212C25.4307 187.393 38.9846 173.162 56.4408 154.895L12.5139 201.212ZM12.1632 202.792C28.0287 186.782 42.4974 170.976 56.7548 156.262L12.1632 202.792ZM12.5975 202.811C26.8054 187.718 40.7691 172.992 56.5662 156.273L12.5975 202.811ZM12.5538 204.087C23.9519 192.781 34.6647 180.829 56.9824 157.308L12.5538 204.087ZM12.7364 204.269C27.9948 187.764 43.4068 171.482 56.6737 157.652L12.7364 204.269ZM12.8467 205.727C29.6488 187.718 46.3974 169.36 56.9833 159.183L12.8467 205.727ZM12.6777 205.954C25.1732 192.43 37.6094 179.299 56.7645 158.87L12.6777 205.954ZM12.6629 206.83C27.2332 192.77 40.7271 177.874 56.8009 160.816L12.6629 206.83ZM12.8375 207.058C24.7677 194.496 36.7669 182.012 56.6823 160.612L12.8375 207.058ZM12.4195 208.831C29.4407 190.452 47.1376 172.36 56.7525 162.407L12.4195 208.831ZM12.6866 208.728C22.6457 197.756 32.7643 187.155 56.4394 161.901L12.6866 208.728ZM12.708 209.892C23.3943 198.925 34.2172 187.289 56.3587 163.599L12.708 209.892ZM12.7574 210.404C28.7437 193.458 44.3762 176.522 56.7207 163.488L12.7574 210.404ZM12.3762 211.577C22.7282 201.642 32.4305 190.946 57.0376 165.114L12.3762 211.577ZM12.6287 211.655C23.3642 201.14 33.464 190.088 56.6578 164.84L12.6287 211.655ZM12.905 212.766C30.7065 194.838 47.7552 176.332 56.8684 166.651L12.905 212.766ZM12.4758 213.042C29.2495 195.263 45.8872 177.578 56.8825 166.482L12.4758 213.042ZM12.3315 214.5C29.373 196.766 46.0354 179.343 56.6295 167.894L12.3315 214.5ZM12.7684 214.586C25.9817 200.028 39.708 185.485 56.4483 167.9L12.7684 214.586ZM12.9637 216.357C22.1811 205.926 31.6165 195.957 56.2346 169.496L12.9637 216.357ZM12.4497 215.996C25.8435 201.395 39.8423 186.679 56.7204 169.494L12.4497 215.996ZM12.7843 217.435C29.7033 199.962 46.3234 182.167 56.5959 170.86L12.7843 217.435ZM12.4087 217.458C26.5208 202.704 40.4471 187.901 56.6347 170.73L12.4087 217.458ZM12.3492 218.771C22.4496 208.965 31.0425 199.907 56.8655 172.168L12.3492 218.771ZM12.8344 218.952C24.0822 207.763 34.6531 195.928 56.5578 172.367L12.8344 218.952ZM12.8656 220.733C27.5266 204.284 42.4681 188.152 56.3313 173.44L12.8656 220.733ZM12.4635 220.537C25.1671 206.809 37.9146 193.102 56.9341 173.562L12.4635 220.537ZM13.2263 221.892C28.8288 204.358 45.8626 186.739 56.6763 175.146L13.2263 221.892ZM12.8498 221.607C24.3046 209.353 36.3858 196.976 56.6751 175.007L12.8498 221.607ZM13.781 222.011C25.5882 209.75 36.5609 198.589 56.3186 176.491L13.781 222.011ZM14.0822 221.745C26.1784 208.096 38.7855 195.132 56.4164 176.814L14.0822 221.745ZM15.3592 221.856C30.6112 205.174 45.3322 189.308 56.9155 178.242L15.3592 221.856ZM15.5611 221.696C30.5206 206.284 44.7162 191.175 56.5169 178.013L15.5611 221.696ZM16.507 221.737C28.4048 209.921 39.4688 197.572 56.7507 179.664L16.507 221.737ZM16.9704 221.693C31.1935 206.548 45.4689 191.693 56.5018 179.783L16.9704 221.693ZM18.4813 221.862C30.9015 208.658 43.2647 195.154 56.4842 181.155L18.4813 221.862ZM18.2248 221.808C29.8822 209.657 41.1371 197.215 56.8695 181.132L18.2248 221.808ZM19.749 222.012C29.503 211.396 39.6304 201.092 56.8516 182.847L19.749 222.012ZM19.5815 221.819C32.3546 208.179 45.2095 194.462 56.8001 182.693L19.5815 221.819ZM20.64 221.553C30.5855 211.973 39.7677 202.867 56.5275 184.036L20.64 221.553ZM21.1191 221.659C34.3769 206.931 48.4968 192.374 56.4214 183.944L21.1191 221.659ZM22.2287 221.495C29.1366 214.928 36.7592 207.624 56.8796 185.807L22.2287 221.495ZM22.2798 221.559C32.7436 211.221 42.547 200.235 56.7659 185.378L22.2798 221.559ZM23.8539 222.125C32.0597 212.92 39.7646 204.541 56.2261 187.278L23.8539 222.125ZM23.6909 221.735C33.6128 211.263 43.8651 200.569 56.6702 187.07L23.6909 221.735ZM25.6915 222.159C37.0361 209.141 49.1632 197.213 56.646 187.911L25.6915 222.159ZM25.034 221.492C33.9792 212.463 42.9805 202.851 56.6859 188.086L25.034 221.492ZM26.1262 221.523C34.5628 214.367 40.9506 206.171 56.9679 189.387L26.1262 221.523ZM26.4541 221.965C34.2017 213.094 41.9905 205.129 56.5744 190.075L26.4541 221.965ZM27.7269 221.836C35.0524 214.265 41.9469 207.517 56.8072 191.63L27.7269 221.836ZM28.1876 221.529C37.7281 211.647 47.491 201.488 56.4024 191.588L28.1876 221.529ZM29.4123 221.515C37.9172 213.543 45.6357 204.189 56.4155 192.366L29.4123 221.515ZM29.1298 221.962C35.572 215.282 41.7448 208.714 56.7785 192.628L29.1298 221.962ZM31.2912 221.938C38.3993 213.279 47.5988 204.05 57.0309 193.838L31.2912 221.938ZM31.0322 221.858C39.9743 212.672 48.3763 203.062 56.7342 194.148L31.0322 221.858ZM32.0717 221.61C38.1767 214.692 45.0162 208.467 57.0316 195.872L32.0717 221.61ZM31.877 221.846C40.1462 213.471 47.6002 205.418 56.5351 195.677L31.877 221.846ZM33.9008 221.367C40.9624 213.369 48.7129 205.331 56.4589 196.831L33.9008 221.367ZM33.7249 221.85C40.7374 213.741 48.3564 206.161 56.6056 197.227L33.7249 221.85ZM34.5584 221.427C43.1832 213.314 51.4028 204.572 56.8458 198.888L34.5584 221.427ZM35.0464 221.981C39.5136 216.895 43.7413 212.007 56.7141 198.548L35.0464 221.981ZM36.4698 221.784C41.3759 216.482 45.4406 211.585 57.0203 200.434L36.4698 221.784ZM36.4838 221.719C43.7409 213.504 51.0704 205.558 56.6079 200.185L36.4838 221.719ZM37.856 222.144C42.606 216.347 46.4103 211.564 56.251 201.296L37.856 222.144ZM37.8763 221.771C43.5806 215.345 49.8561 209.105 56.4296 201.716L37.8763 221.771ZM38.617 221.357C46.2156 214.522 52.4044 207.96 56.3086 202.84L38.617 221.357ZM39.3275 221.805C44.8713 215.956 50.2205 209.817 56.3093 203.289L39.3275 221.805ZM40.8702 222.163C43.7291 218.431 47.0151 214.743 57.1229 204.591L40.8702 222.163ZM40.3178 221.828C44.2189 217.998 47.8254 213.988 56.5925 204.397L40.3178 221.828ZM42.3162 221.971C47.5154 215.945 52.8955 209.791 56.0898 206.142L42.3162 221.971ZM41.8141 221.848C45.9288 217.857 49.6995 213.609 56.7652 206.266L41.8141 221.848ZM43.0361 221.445C46.8706 217.989 49.8977 214.796 56.9127 207.736L43.0361 221.445ZM43.2962 221.805C46.3562 218.094 49.7124 214.61 56.8709 207.373L43.2962 221.805ZM45.116 222.019C47.2323 218.784 50.4672 215.125 56.5813 209.239L45.116 222.019ZM44.8666 221.715C47.0854 218.476 50.1629 215.842 56.6231 209.149L44.8666 221.715ZM45.8835 221.984C48.3527 219.202 51.1 216.111 56.2985 210.711L45.8835 221.984ZM45.8418 221.599C49.0541 218.376 51.5979 215.446 56.8228 210.53L45.8418 221.599ZM46.7493 221.871C49.7569 219.396 52.4631 216.787 56.6156 211.443L46.7493 221.871ZM47.2121 221.816C50.2682 218.346 53.2726 215.427 56.7184 211.793L47.2121 221.816ZM48.3424 221.56C51.0712 218.384 53.9587 216.041 56.2188 213.303L48.3424 221.56ZM48.4805 221.594C51.3761 219.145 53.7982 216.269 56.8417 213.332L48.4805 221.594ZM50.3388 221.705C51.8334 219.786 53.5057 218.744 57.1192 215.067L50.3388 221.705ZM49.9771 221.662C52.3951 219.023 55.1302 216.561 56.5136 214.782L49.9771 221.662ZM51.4371 221.913C53.8771 219.47 55.7004 217.05 56.3251 216.679L51.4371 221.913ZM51.4081 221.934C52.6774 220.486 53.7714 219.709 56.8686 216.153L51.4081 221.934ZM52.5042 222.116C54.3759 220.089 54.9871 219.335 56.248 217.425L52.5042 222.116ZM52.7933 221.672C53.9039 220.628 54.8724 219.768 56.7953 217.918L52.7933 221.672ZM54.5263 221.584C54.4528 221.12 54.983 220.457 56.331 219.254L54.5263 221.584ZM54.2421 221.777C54.7095 221.274 55.3354 220.648 56.7714 219.268L54.2421 221.777ZM55.7132 221.843C55.9851 221.481 56.3705 220.952 56.6745 220.848L55.7132 221.843ZM55.636 221.777C55.8849 221.506 56.1922 221.104 56.5532 220.709L55.636 221.777ZM14.4401 221.661C13.7163 221.098 13.1919 220.707 12.661 220.284L14.4401 221.661ZM14.1566 221.561C13.8001 221.201 13.3686 220.835 12.5797 220.41L14.1566 221.561ZM15.6972 221.18C14.905 221.218 14.4611 220.437 12.283 218.675L15.6972 221.18ZM15.6461 221.57C14.5554 220.652 13.5368 219.992 12.542 219.172L15.6461 221.57ZM17.7948 221.647C16.717 220.839 15.3782 219.948 12.3999 218.093L17.7948 221.647ZM17.5532 221.456C15.7427 219.956 14.064 218.744 12.8208 217.8L17.5532 221.456ZM19.2604 221.734C16.5993 220.471 14.8512 218.397 12.9666 216.837L19.2604 221.734ZM19.0202 221.833C17.407 220.389 15.2982 218.861 12.546 216.491L19.0202 221.833ZM20.7766 221.597C17.7729 218.863 14.5436 216.304 12.7008 214.84L20.7766 221.597ZM20.4506 221.421C17.4638 219.236 14.6253 216.75 12.8385 215.082L20.4506 221.421ZM21.7343 221.366C18.855 219.418 15.7908 215.998 12.3619 213.587L21.7343 221.366ZM22.4468 221.619C20.088 219.884 18.4289 218.598 12.7415 213.727L22.4468 221.619ZM23.3613 221.795C21.8792 219.445 19.396 217.532 12.943 212.888L23.3613 221.795ZM23.5894 221.712C19.4976 217.901 15.063 214.323 12.8303 212.668L23.5894 221.712ZM24.9028 222.079C20.9616 218.282 17.0589 214.565 12.3524 211.461L24.9028 222.079ZM25.0998 221.498C22.5587 219.072 19.5721 216.798 12.2942 211.133L25.0998 221.498ZM26.7579 221.565C22.3394 217.602 17.3311 213.994 13.0672 210.528L26.7579 221.565ZM27.0751 221.783C22.739 217.862 18.2172 214.452 12.5558 209.961L27.0751 221.783ZM28.8044 221.591C22.3346 216.694 16.883 212.118 12.5566 208.626L28.8044 221.591ZM28.5158 221.403C22.8694 217.099 17.4177 212.65 12.7874 208.568L28.5158 221.403ZM30.289 222.035C25.7768 217.467 20.9628 214.064 13.0219 207.125L30.289 222.035ZM30.2228 221.705C23.4942 216.389 16.7241 210.633 12.4879 207.575L30.2228 221.705ZM31.3993 221.582C25.5375 216.77 18.2424 211.607 12.8623 206.005L31.3993 221.582ZM31.8146 221.509C24.1973 215.464 16.3606 209.481 12.736 206.254L31.8146 221.509ZM33.0939 221.793C29.0259 217.869 23.9897 214.199 12.2426 204.561L33.0939 221.793ZM33.521 221.42C26.8268 216.072 19.9924 210.767 12.5086 205.161L33.521 221.42ZM34.5035 221.599C29.608 217.494 23.7234 212.719 12.9043 203.916L34.5035 221.599ZM34.7655 221.672C28.824 216.498 22.0908 211.313 12.5416 203.576L34.7655 221.672ZM35.9484 221.545C28.2989 215.63 20.8442 209.422 12.2588 202.91L35.9484 221.545ZM36.54 221.802C27.0925 214.041 17.4927 206.786 12.6915 202.617L36.54 221.802ZM38.3077 221.787C30.1486 215.255 22.3036 208.892 12.5864 201.584L38.3077 221.787ZM38.3034 221.519C29.0787 214.608 20.4058 207.364 12.6668 201.243L38.3034 221.519ZM39.8971 221.87C31.4988 215.294 23.1414 209.005 13.0436 199.95L39.8971 221.87ZM39.4326 221.683C31.4189 215.14 23.6553 208.906 12.5192 199.844L39.4326 221.683ZM40.9936 221.438C33.4534 214.601 24.9908 208.759 12.7999 198.746L40.9936 221.438ZM41.2767 221.635C29.759 212.576 18.7667 203.691 12.5284 198.807L41.2767 221.635ZM42.7998 221.935C33.6811 215.041 25.4064 207.635 12.4922 197.422L42.7998 221.935ZM42.8707 221.619C34.6448 215.049 25.6585 208.112 12.7092 197.469L42.8707 221.619ZM44.7263 221.719C34.2517 213.602 24.1319 205.508 13.0712 196.464L44.7263 221.719ZM44.6144 221.73C36.5389 215.572 28.1623 209.264 12.5785 196.189L44.6144 221.73ZM46.367 221.266C36.7255 214.401 26.3398 205.778 12.1586 194.773L46.367 221.266ZM45.9534 221.578C36.6317 213.973 26.907 206.581 12.3448 194.68L45.9534 221.578ZM48.0285 221.509C35.6279 212.09 22.8751 202.025 12.2217 193.737L48.0285 221.509ZM47.6118 221.516C38.6629 214.471 30.3211 207.05 12.6166 193.428L47.6118 221.516ZM49.5177 221.179C39.1463 213.539 30.1968 205.447 12.5619 192.526L49.5177 221.179ZM49.2141 221.644C36.0632 211.351 23.0703 200.954 12.7871 192.349L49.2141 221.644ZM50.6708 221.878C40.8755 214.175 30.921 205.61 12.2739 191.204L50.6708 221.878ZM50.9958 221.59C38.7614 212.07 26.691 202.478 12.8284 191.248L50.9958 221.59ZM52.2906 221.724C42.2103 213.199 30.9126 204.626 12.6554 189.855L52.2906 221.724ZM52.5079 221.619C43.7647 214.483 35.1802 207.552 12.705 189.891L52.5079 221.619ZM54.3965 222.04C39.924 210.474 26.5731 199.674 12.8833 188.851L54.3965 222.04ZM53.8143 221.603C42.1605 212.282 30.834 203.196 12.6772 188.568L53.8143 221.603ZM55.4935 221.463C42.9094 211.172 30.5373 201.728 12.4921 187.091L55.4935 221.463ZM55.5594 221.464C41.4841 210.252 26.7491 198.712 12.5818 187.064L55.5594 221.464ZM57.1297 221.637C39.9586 208.381 22.8263 194.892 12.9909 185.782L57.1297 221.637ZM56.9398 221.133C40.7331 207.773 24.3082 194.882 12.7244 186.12L56.9398 221.133ZM56.2531 219.978C45.4047 211.003 34.4326 201.84 12.5548 184.955L56.2531 219.978ZM56.6386 219.861C46.7541 211.895 37.1754 204.076 12.7232 184.434L56.6386 219.861ZM57.118 219.028C46.2413 209.643 34.7417 200.54 12.4122 183.052L57.118 219.028ZM56.6838 218.889C42.4443 207.418 28.177 196.006 12.8184 183.378L56.6838 218.889ZM56.9794 217.621C47.2368 209.851 38.6757 202.391 12.4151 181.795L56.9794 217.621ZM56.5794 217.384C40.5118 205.084 24.6237 192.178 12.7113 181.93L56.5794 217.384ZM56.7676 215.929C43.1652 205.163 30.1694 194.96 12.909 180.763L56.7676 215.929ZM56.921 216.229C44.9445 206.758 33.0076 197.243 12.4317 180.978L56.921 216.229ZM56.2194 214.958C44.0488 204.614 31.8908 194.602 12.1069 179.788L56.2194 214.958ZM56.6653 214.831C45.2403 205.018 33.7039 195.649 12.5215 179.494L56.6653 214.831ZM57.0927 214.024C42.4364 202.236 27.7022 190.904 12.4435 178.5L57.0927 214.024ZM56.9121 213.548C45.6492 205.242 35.263 196.768 12.6595 178.422L56.9121 213.548ZM56.5043 211.911C47.7452 204.957 37.8919 197.206 12.5672 177.068L56.5043 211.911ZM56.828 212.156C47.2527 204.508 37.9825 197.135 12.7426 176.861L56.828 212.156ZM56.4233 210.959C46.7649 202.923 36.6536 195.045 12.797 175.741L56.4233 210.959ZM56.5312 211.034C44.3471 201.375 32.0287 191.238 12.4069 175.528L56.5312 211.034ZM57.2048 210.106C40.9457 197.245 24.8141 184.467 12.4973 174.763L57.2048 210.106ZM56.8003 209.786C42.85 198.594 28.5045 187.437 12.5582 174.188L56.8003 209.786ZM57.133 208.196C41.2985 196.118 26.2945 184.475 12.8428 173.093L57.133 208.196ZM56.4898 208.468C42.1213 197.221 27.9303 185.9 12.6501 173.046L56.4898 208.468ZM56.8864 207.689C44.1639 196.784 31.5345 186.703 12.3999 171.619L56.8864 207.689ZM56.898 207.368C44.5596 197.51 32.6187 187.624 12.6622 171.836L56.898 207.368ZM57.1173 205.643C41.9418 194.143 27.1521 183.002 12.5822 170.227L57.1173 205.643ZM56.7669 205.837C43.0871 194.853 29.3235 183.786 12.6234 170.798L56.7669 205.837ZM56.7269 204.827C46.9259 196.496 35.84 188.105 12.5323 169.527L56.7269 204.827ZM56.7353 204.921C39.5046 190.422 21.7052 176.086 12.5411 169.506L56.7353 204.921ZM56.5214 203.717C44.7674 194.368 32.824 184.731 12.6964 167.946L56.5214 203.717ZM56.8338 203.55C44.2858 193.406 31.5729 183.361 12.7354 167.888L56.8338 203.55ZM56.5947 201.827C38.7976 188.404 21.8232 174.71 12.5695 166.694L56.5947 201.827ZM56.9022 202C40.3967 188.44 23.5987 175.096 12.5993 167.045L56.9022 202ZM56.3943 200.45C40.6777 187.79 25.1748 174.882 12.3038 165.285L56.3943 200.45ZM56.7745 200.98C43.5756 190.5 30.4553 180.176 12.5499 165.384L56.7745 200.98ZM56.5896 199.719C45.218 190.164 34.2379 181.725 12.3346 163.969L56.5896 199.719ZM56.6965 199.714C41.7642 187.882 26.964 175.773 12.8766 164.363L56.6965 199.714ZM56.4466 198.522C45.9628 189.68 35.7529 181.889 12.9968 163.241L56.4466 198.522ZM56.6138 198.334C44.5397 188.426 32.3724 179.072 12.3562 162.81L56.6138 198.334ZM56.5937 197.353C44.8574 187.8 33.2562 177.647 12.358 162.136L56.5937 197.353ZM56.5897 197.21C41.0226 183.753 24.6496 171.145 12.483 161.84L56.5897 197.21ZM56.396 195.745C45.7132 187.155 35.4813 178.181 13.0107 160.218L56.396 195.745ZM56.5411 195.615C40.3082 182.288 24.0504 169.232 12.496 160.416L56.5411 195.615ZM56.7208 194.295C41.4875 181.768 25.3467 170.02 12.7288 159.183L56.7208 194.295ZM56.6572 194.363C39.5095 180.845 22.3247 167.103 12.7117 159.026L56.6572 194.363ZM56.4155 192.923C40.9305 180.276 24.8798 167.615 12.1576 158.232L56.4155 192.923ZM56.6863 193.24C45.8684 184.474 35.2617 175.88 12.691 157.729L56.6863 193.24ZM56.867 192.071C47.1027 184.562 37.6556 176.708 12.646 156.502L56.867 192.071ZM56.8029 191.982C42.6112 180.996 29.2633 169.845 12.778 156.514L56.8029 191.982ZM56.6852 190.96C43.9459 180.428 31.3535 170.39 12.2752 155.054L56.6852 190.96ZM56.4467 190.599C42.1508 178.977 27.3941 167.411 12.7153 155.42L56.4467 190.599ZM57.16 189.616C47.453 181.835 38.4808 174.243 12.6612 154.343L57.16 189.616ZM56.5346 189.534C45.7459 180.58 34.6909 171.525 12.7346 154.069L56.5346 189.534ZM56.9439 187.957C42.0289 176.028 26.8465 164.385 12.2926 152.894L56.9439 187.957ZM56.5058 187.911C39.4145 174.687 22.0666 160.868 12.6199 152.61L56.5058 187.911ZM56.613 186.993C43.7721 176.122 30.1847 165.53 12.4359 151.397L56.613 186.993ZM56.534 187.006C43.0808 175.814 29.2773 164.923 12.7988 151.667L56.534 187.006ZM56.9372 185.426C41.0392 172.543 25.3692 160.759 12.2673 150.545L56.9372 185.426ZM56.8148 185.603C40.34 172.764 24.0974 159.581 12.5084 149.975L56.8148 185.603ZM56.2646 184.159C43.626 174.006 30.4054 163.025 12.9842 149.348L56.2646 184.159ZM56.6383 184.287C46.8219 176.274 37.2046 168.388 12.6801 148.876L56.6383 184.287ZM57.0624 183.061C47.4836 175.013 37.5882 167.931 12.9358 147.929L57.0624 183.061ZM57.013 183.026C42.2483 171.79 27.6182 160.143 12.3129 147.471L57.013 183.026ZM56.9363 181.371C47.8607 174.175 38.6027 167.029 12.636 146.668L56.9363 181.371ZM56.5131 181.784C44.1094 171.987 31.5913 161.948 12.701 146.297L56.5131 181.784ZM57.1349 180.182C43.0273 169.674 29.7237 158.966 12.5778 144.86L57.1349 180.182ZM56.7644 180.506C42.8319 169.214 28.7173 157.6 12.4653 144.953L56.7644 180.506ZM56.9895 178.78C44.2265 169.366 32.4498 159.944 12.8681 143.993L56.9895 178.78ZM56.7735 178.977C46.3032 170.767 36.3082 162.287 12.6759 143.71L56.7735 178.977ZM57.1188 177.92C45.8588 169.295 35.8318 161.103 13.0364 142.438L57.1188 177.92ZM56.7095 178.017C43.5846 166.984 30.2537 156.414 12.5274 142.54L56.7095 178.017ZM56.3626 176.837C41.1019 164.801 26.1379 151.946 12.4729 141.231L56.3626 176.837ZM56.5174 176.695C40.3563 163.387 23.9249 149.865 12.5839 141.105L56.5174 176.695ZM56.7863 175.69C40.6517 162.752 24.1363 149.69 13.1068 140.354L56.7863 175.69ZM56.5617 175.59C47.1117 167.626 37.0188 159.306 12.8679 140.193L56.5617 175.59ZM57.0193 174.231C41.9271 162.238 27.2526 149.838 12.4925 138.799L57.0193 174.231ZM56.6892 174.01C46.2584 165.481 34.9483 156.763 12.7932 138.888L56.6892 174.01ZM56.367 172.592C46.614 164.767 36.095 156.218 12.8544 137.424L56.367 172.592ZM56.8714 172.841C41.0257 159.774 24.4712 146.973 12.48 137.624L56.8714 172.841ZM56.2209 171.609C41.8667 159.423 27.2329 147.178 12.1821 136.383L56.2209 171.609ZM56.7162 171.344C41.0615 159.247 25.5589 146.652 12.4909 136.021L56.7162 171.344ZM56.9948 170.302C42.1544 158.593 27.8487 146.624 12.5749 134.831L56.9948 170.302ZM56.5589 170.425C40.402 157.326 23.8313 143.953 12.6517 135.272L56.5589 170.425ZM56.8456 168.674C44.3127 158.617 31.6811 148.847 14.1091 134.927L56.8456 168.674ZM56.5243 169.018C46.1682 160.344 35.5563 152.127 14.5674 135.113L56.5243 169.018ZM56.6661 167.698C41.2382 155.157 26.0796 143.813 15.7977 135.298L56.6661 167.698ZM56.7288 167.76C47.7565 160.499 38.7707 153.168 16.1675 134.902L56.7288 167.76ZM57.1213 166.265C43.2565 154.804 29.2853 144.541 18.198 134.9L57.1213 166.265ZM56.7951 166.185C48.0783 159.231 39.1615 152.493 17.5012 135.121L56.7951 166.185ZM57.0259 165.45C42.1352 153.154 27.9134 142.222 18.7497 135.194L57.0259 165.45ZM56.8751 165.317C46.6515 157.192 37.0211 149.526 19.2515 134.835L56.8751 165.317ZM57.1258 163.442C45.5893 154.849 34.8225 146.331 20.4571 135.474L57.1258 163.442ZM56.8497 163.652C47.8173 156.57 39.1638 149.548 20.7578 135.112L56.8497 163.652ZM56.3571 162.983C49.7089 156.489 42.1982 150.666 22.5835 135.367L56.3571 162.983ZM56.8153 162.682C44.0099 152.278 31.213 141.727 22.4163 135.303L56.8153 162.682ZM56.8628 161.367C45.3255 151.655 33.4881 142.298 24.1644 134.776L56.8628 161.367ZM56.7693 161.452C49.9204 156.203 42.7602 150.817 24.162 135.327L56.7693 161.452ZM57.0423 159.803C49.2044 154.079 40.5529 147.029 25.9836 135.247L57.0423 159.803ZM56.5794 160.153C50.2314 154.704 43.4121 149.64 25.7585 135.347L56.5794 160.153ZM56.5784 159.192C46.7764 150.591 36.6121 142.744 26.9298 135.411L56.5784 159.192ZM56.715 158.53C48.8833 152.401 40.7271 146.24 26.9438 135.059L56.715 158.53ZM56.7891 157.946C47.8831 150.384 38.5155 143.736 29.0427 135.068L56.7891 157.946ZM56.6523 157.547C46.6576 149.351 36.5111 141.222 28.7031 135.112L56.6523 157.547ZM56.2662 156.422C49.7439 150.401 42.3002 144.557 30.7405 135.443L56.2662 156.422ZM56.6484 156.358C47.5325 148.856 38.8066 141.945 30.2862 134.963L56.6484 156.358ZM56.4427 154.746C49.0015 148.836 41.734 143.102 31.9252 134.778L56.4427 154.746ZM56.6677 154.928C46.9658 147.181 36.7105 139.324 32.1038 134.947L56.6677 154.928ZM56.3853 153.552C50.5248 148.227 43.3035 142.95 33.3506 134.982L56.3853 153.552ZM56.7888 153.567C48.0935 146.551 39.1258 139.609 33.6695 135.226L56.7888 153.567ZM56.3347 151.981C48.5951 145.828 40.5172 139.868 34.5434 134.678L56.3347 151.981ZM56.7112 152.362C48.5505 145.913 40.9316 139.437 35.0502 134.845L56.7112 152.362ZM56.552 150.959C52.3091 147.3 47.2281 144.385 36.242 134.723L56.552 150.959ZM56.5656 151.322C50.8151 146.39 44.3972 141.404 36.8345 135.311L56.5656 151.322ZM56.805 149.618C53.1433 146.356 49.2233 143.339 38.3179 135.099L56.805 149.618ZM56.5386 149.678C49.7953 144.463 42.962 138.899 38.4543 135.322L56.5386 149.678ZM57.2417 148.403C52.6538 145.009 48.3034 141.678 40.1866 134.836L57.2417 148.403ZM56.5811 148.741C52.434 145.108 47.7863 141.65 39.7771 135.005L56.5811 148.741ZM56.6369 147.255C52.3078 143.46 48.2644 140.467 41.7404 135.29L56.6369 147.255ZM56.8794 147.192C51.3337 142.88 45.8958 138.332 41.3951 135.101L56.8794 147.192ZM56.3945 145.838C52.8829 143.61 49.2919 140.625 42.8349 134.64L56.3945 145.838ZM56.5199 145.869C51.1347 142.013 46.3003 137.429 43.2066 134.822L56.5199 145.869ZM56.7082 144.604C53.3793 142.711 50.344 139.802 44.1619 134.845L56.7082 144.604ZM56.5684 144.981C52.3723 141.266 48.2947 138.206 44.6461 135.187L56.5684 144.981ZM56.3915 143.093C53.6211 141.556 50.2714 138.231 46.7364 135.171L56.3915 143.093ZM56.6489 143.598C54.367 141.416 52.0922 139.456 46.395 134.956L56.6489 143.598ZM56.34 141.968C54.3878 140.1 51.3866 138.001 47.6131 135.478L56.34 141.968ZM56.4575 142.164C53.3177 139.64 49.8405 136.82 48.0628 135.106L56.4575 142.164ZM57.2752 141.311C55.1831 139.526 52.7781 137.771 49.6859 135.176L57.2752 141.311ZM56.5141 141.02C54.4981 139.319 52.2669 137.428 49.2585 135.373L56.5141 141.02ZM56.9479 139.766C55.1886 138.278 53.619 137.482 51.2645 134.928L56.9479 139.766ZM56.5468 139.549C54.7214 138.062 52.6207 136.51 51.0404 135.231L56.5468 139.549ZM56.2275 138.619C55.6351 137.836 54.2461 136.182 52.6848 135.434L56.2275 138.619ZM56.7655 138.552C55.9208 137.531 55.2115 137.222 52.7562 135.071L56.7655 138.552ZM56.4404 137.081C56.1742 136.675 55.5449 135.732 54.2513 135.247L56.4404 137.081ZM56.7179 137.02C56.2266 136.624 55.6907 136.201 54.4344 135.226L56.7179 137.02ZM56.6624 135.762C56.3588 135.629 56.2236 135.455 55.6908 135.003L56.6624 135.762Z M12.7276 221.584C12.4361 192.908 12.2952 164.099 12.5453 135.549M13.0773 135.552C26.6689 135.33 41.182 135.882 56.4428 135.744L13.0773 135.552ZM12.5977 135.168C23.9348 135.003 34.9571 135.023 56.5793 135.516L12.5977 135.168ZM56.1624 135.318C57.0535 165.155 56.6355 194.242 56.218 221.374L56.1624 135.318ZM56.3482 135.327C56.5387 166.315 56.7032 197.406 56.5414 221.576L56.3482 135.327ZM56.0494 222.024C40.889 221.51 26.0151 221.051 12.6812 221.232L56.0494 222.024ZM56.1374 221.691C40.7551 221.82 25.5179 221.776 12.856 221.779L56.1374 221.691ZM12.7387 221.857C12.4329 200.555 12.3433 179.5 12.5428 135.581L12.7387 221.857Z';

  var textModel = 'M24.9 171.5c-.2 0-.3 0-.3-.2a1 1 0 01-.1-.5V168 167l-.1-3.8v-1l-.6 2.5-.5 2.7v.4l-.3.8c0 .3-.3.5-.5.5-.4 0-.7-.6-.7-1.7 0-.7 0-1.3-.2-2a30 30 0 00-.6-2.7l-.5-2v5.9l.1 1.2v2.5c0 .2 0 .4-.2.6-.3 0-.5 0-.7-.2l-.1-.9v-1.4-8.5-2.3l.5-.3.3.3.3.5a33 33 0 011.6 6.9l.3 1.4.1-.6.4-1.5a66.2 66.2 0 001-6.6v-.1l.3-.4.4-.1h.3l.1.4a187.7 187.7 0 00.4 13l-.2.6c-.2.3-.4.4-.5.4zm5-.2c-.3 0-.5 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.3a18 18 0 01-.1-2.8v-2l.1-1.8c0-.6.2-1.1.4-1.7l.3-.5.5-.2a3 3 0 012.3 1l.6 1 .3 1.5.1 1.6v2.1c0 3.5-.7 5.2-2.3 5.2zm0-.7l.6-.3c.2-.1.3-.4.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.8.7c-.2.4-.2.9-.2 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm5 .5c-.3 0-.4-.8-.4-2.3v-2.9a199.6 199.6 0 000-6.6l.4-.2c.5 0 .9.1 1.2.3.4.2.8.4 1 .8a5.6 5.6 0 011.5 4.1v1.5l-.1 1.8a4.1 4.1 0 01-2.3 3.5H35zm.8-1h.7l.5-.6.3-.7.3-.9a10.8 10.8 0 00.2-2.3c0-3.6-.7-5.5-2.1-5.7l-.2 2a91 91 0 00.3 7.9v.4zm5.7 1.1l-.4-.1a.6.6 0 01-.2-.4v-.9-.3l-.1-1.2v-1.1a92.8 92.8 0 010-6v-.8c0-.9.2-1.3.7-1.3l1.4.3c.5.1.8.3.8.5l-.2.4-.3.2-1.4-.4a12.5 12.5 0 010 2.1v1.6h.6c.6 0 1 .1 1 .4 0 .2-.1.3-.3.4l-.4.1h-.9a19.3 19.3 0 010 3 36.6 36.6 0 000 2.6H43c.5 0 .7.1.7.4 0 .2 0 .3-.2.4a1 1 0 01-.6.1h-1.5zm7 0l-1.5-.1-.7.2-.3-.2a84.8 84.8 0 010-8.4v-.2-1.7c0-1.1.2-1.7.6-1.7l.3.1.1.3v1.4a118.7 118.7 0 00-.1 5.1V167.6l-.1 1.5c0 .8.2 1.2.6 1.2h.7c.7 0 1 .2 1 .5 0 .1 0 .2-.2.3l-.3.2z';

  var animalBird = 'M37.7 26.3c1.1-1.2 2.6-2.1 3.9-3.1.7-.5 1.4-1.3 2-2 .8-.7 2-.9 2.8-1.5.8-.6 2-1.3 2.9-1.7.9-.4 1.6-1 2.6-1.5s2.3-.8 3.4-1.4c1-.5 2.2-1 3.3-1.2 1.5-.4 2.9-1.3 4.2-2 1.8-1 4.2-2 6.2-2.3 2.3-.4 4.5-1.2 6.8-1.2.3 0 2.9.1 1.8 1-.7.5-.7 1.8-1.2 2.4A4 4 0 0076 13c0 .7 1.2.4 1.6.4 1.7 0 3 .2 4.7.5l5.5 1.2c2.4.5-1 4.5-.6 4.6 1 .4 2.9.2 3.8 1 .3.2 1 .3 1.4.3.5 0 1 .6 1.5.8 1.8 1 1.9 2.7 1.9 4.6 0 .7.2 2.5 1 2.8 1 .4 1.9 1.7 2 2.7.6 2.3-.4 4.9.9 7 .7 1.5 1.8 3.4 1.8 5 0 2-1 3.6-1.3 5.4-.4 2-.8 3.8-1 5.7-.5 3-.7 7-2.6 9.4a7 7 0 00-.8 3c0 .4-.5 1.6-.2 1.2.3-.5 2.6 1.3 3 1.5 2 .9 4 1 6 1s3.5-.8 5.3-1.2c1.9-.6 3.7-1.4 5.7-1.9 2.2-.6 4-2 6.1-2.8 3-1.2 5.8-2.9 9-2.9.5 0 .6 0 .3.6-.6 1-.8 2-1.1 3-.7 2.2-1.9 4.4-2.1 6.7 0 .5-.5 1 0 1.3l1.4 1c1.3 1 4.2.7 5.6.2.7-.2 4-1.2 4.6-.5.5.4-.7 3.4-1 4-.2.7-.4 1.7-.7 2.3-.3.6-.2 1.5-.5 2-.5 1 2.6.9 3.3.9h5c1.4 0 3.4 0 2.4 1.8-.4.8-.6 1.7-.8 2.6 0 .4-.4 2.5-.2 2.7.4.4 2.8.4 3.3.4 1.4.2 3 .6 4.4.6 3.2 0-2.7 10.3-3 11.7-.9 3.5-3.3 6.8-4.7 10.1-.6 1.3-1.5 2.5-2.5 3.5-1.2 1.4-2.7 2.1-4 3.4-1.4 1.3-2.5 3-3.8 4.2l-3.3 3.2c-2.8 2.7-6.3 4.5-9.3 6.9a22.6 22.6 0 01-5 3c-2.5 1-5.2 1.6-7.6 2.7a23 23 0 01-4 1.2c-2.2.5-4.4 1.4-6.7 2-2.4.6-5.5.9-8 .9-1.1 0-3 0-4 .4m-5.3-10.7c0 3.7.8 7.4 1.7 11 .5 1.8 1.1 3.8 1.4 5.7 0 1 .4 2 .7 3 .5 1.9-.2 4.3.1 6.2.4 3 .8 5.8.8 9 0 2.5.5 5 .5 7.4 0 1 .8 3.2 0 4a32 32 0 01-5.7 3.5c-1.6.7-2.6 2.4-4 3.2m10.2-7.4c0 2.2.3 4.5-.5 6.6-.5 1.4-1.9 2.4-2.4 3.9m2.4-8.6c3.9 0 6.4 2 8.4 5m-6.7-41.3H87m-3.1-.5c-2.8 0-5.5-.4-8.2-.4-1.5 0-3.2-1-4.6-1-2 0-3.5-1.4-5.4-1.4m-1 1c-1.6-.7-3.4-1-5-1.7-.8-.4-2.6-.7-3.5-.8-1.3 0-3.2-.6-4.3-1.2-1.6-.8-3-2-4.6-2.6-1.1-.5-2.3-1.4-3.4-1.7-1.3-.4-2.5-1.5-3.7-2.1a16 16 0 01-3.4-2.6c-1.2-1.3-2.3-2.8-3.6-4a61.4 61.4 0 01-7-7.3 9.9 9.9 0 01-2.2-4.1c-.4-1.5-.3-3-.5-4.5l-.3-3c0-1.1-.6-2.1-1-3.2-.4-1.4-.4-2.7-.8-4.1-.5-2.1-.6-4.1-.6-6.3 0-3.4.7-6.4 1.5-9.6.4-1.6 1.2-3.1 2-4.5l.7-1.3c.2-.3.4-1.4.4-.6m7.4-26.5c0 1.9.8 3.6 1 5.4 0 1.7 1.1 3.2 1.1 4.8 0 1.6.5 3 .5 4.6l.2 3.8c0 1 0 1.8-.4 2.6-.6 1.2-1.3 1.6-2 2.5-.6.7-2.2.4-3 .4h-4.6c-5 0-9.8-.6-14.5-2.6-.7-.3-1.7-.2-2.2-.7-.6-.5-1.6-.9-2.2-1.2-1.3-.8-2.3-2.4-3.2-3.5L2.3 66l-1.1-1.8c-.9-1 2.5-4 3.3-4.6 3.4-2.7 7-5.5 10.1-8.6.9-.9 3-2.4 4.2-2.5 1 0 1.8-.6 2.9-.5.4 0 1 .8 1.5 1 1.6.4 3 1.7 4.7 1.9.8 0 1.5.5 2.2.7.6 0 2.3.3 2.5.7m1.2 8.6c-4.8 0-10.4-.7-15 .9-2 .7-4.3 1.5-6.4 1.5-2.2 0-4.2.7-6.3.7-.8 0-5 1.2-5 1m36.3-35.8c-6.6-2.7-15.1-.3-18.1 6.5-.7 1.4-.7 3.1-.7 4.7 0 1.3.3 2.4.5 3.5.3 2.7 3.7 5 5.4 6.7 2 2 7 2.4 9.3 1.2 2-1 3.2-2 4.7-3.4l1.7-2.2c.5-.7.4-1.5.7-2.3 1.1-3 1.8-8 .5-11-1-2.1-1.2-3.2-3.3-4.3a7.4 7.4 0 00-3.8-.9m-1.2 12.4c-1.5 1.2-.2 2 .6.6.5-.8.4-2.7-.7-2.7-1.4 0-1.3.1-1.3 1.4 0 .5.7 1.9 1.4 1.2 1-1.3-1.8-1.9-2.3-1.9-1.2 0 .1 1.4 1 1.2 1.2-.3.5-1.4.2-.7-.5.8.6 1.9 1.4 1.9m24.5-3.6c-1.9 0-4.2 1.6-5.7 2.9-.5.4-1.1.7-1.6 1.2a11.2 11.2 0 00-2.6 4.6c-.5 1.6-1 3.4-1 5.1v2.4c0 .9.4 1.5.4 2.2.1.8 1.8 2.3 2.4 2.9a11 11 0 002.9 2.1c1.4.7 2.5 1 4 1h3c1.2 0 2-.8 2.9-1 1.6-.4 2.9-2.5 4.2-3.5 1.3-1 2.5-2.3 3.7-3.5 2.3-2.4 2.7-6.5 1.6-9.6-.7-2.3-1.2-4-3-5.5a9.7 9.7 0 00-3.9-1.8c-3-.6-7.3-2.1-10.1 0m3.3 13.2c-.8.7-2 3.3.1 2.8.6-.1.8-1.2.6-1.7-.3-.5-1.7-.4-1-.4.6 0 1.6-.6.8-1-.6-.4-1.2-.2-1 .6.1.3 2.2.4 1.9-.5-.2-.5-1.6-.6-1.4.3.2.4 1.6 0 .9-.9-1-1-3.2 1.8-.6 1.7 1 0 .4-1.4-.5-1.4-1.2 0-1.5.4-1.5 1.5 0 .8.8 1 1.3.3.6-.7-1.2-.8-1.4-.4-1 1.6 3.4.2 1.8.2m13.1 30.1l10-.2c1.8 0 3.6 0 5.3-.4 1.6-.5 3.3-.5 5-1 1.2-.4 2.3-.5 3.6-.5 2.3 0 3 2.3 1.4 4-.8 1-1.5 2.7-2.1 3.8-.5 1-1.4 2.7-2.3 3.4-.3.3-.3.9-.7 1.2-.5.4.6 0 1.3.2 1.4.5 2.9 1.5 4.3 1.7 1.8.2 3 1.3 4.4 2.1 2.3 1.3 1.2 3.8-.2 5.2-.8.7-1.9 1.3-2.5 2.1-.2.3 1 .1 1.4.3l3.8 1.2c1.6.5 4.5 1.4 4.6 3.4 0 2.1-2.9 4-4.5 5-1 .7-2 1.4-3.2 2-1.1.5-3 1.5-4.3 1.6-3.3.2-6.3 2.1-9.6 2.1-2.6 0-5.3.5-7.9.5-1.2 0-2.4.1-3.6-.2-1-.3-1.8-1.2-2.8-1.5-.9-.1-2.5-1.2-3.1-1.7-1.1-1-2.6-1.6-3.9-2.4-1.1-.8-2.5-1.4-3.5-2.4-.8-.7-2-2.5-3-2.5m4.5 34.8c-.6 4.1-.4 8.5-1.6 12.4-1.3 4-2.3 8.2-3.8 12a78.8 78.8 0 00-3.2 11c-.1.8-.5.7-1.2 1l-2.4 1.8c-.8.5-1.6 1.2-2.2 1.8-.3.3-.9 1.3-.6.4m7.1-5c.4 2 1.8 4.2 1.2 6.4-.4 1.4-1.9 2.9-1.9 4.3m0-9c4 0 7.2.4 9 4.2m44.6-14.2c-.2 0-.7-1.3-1.4-3.7l-2.2-8v5.9l.1 2.6a53.4 53.4 0 010 2.8 1 1 0 01-.5.1c-.2 0-.4 0-.4-.3v-.5l.1-.7a65 65 0 00-.2-5.6v-2.3a36.7 36.7 0 01.1-3.3v-.2c0-.6.2-.9.4-.9s.4.3.6.8a145.2 145.2 0 013 10.9v-3l.1-3.1v-5.4c0-.3.3-.4.6-.4s.5.2.5.7l-.1.6a148.9 148.9 0 01-.1 6.7v5.5c0 .2 0 .3-.2.5 0 .2-.2.3-.4.3zm5.1 0c-.3 0-.6 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.3a18 18 0 01-.2-2.8v-2l.2-1.8c0-.6.2-1.1.4-1.7 0-.2.2-.4.3-.5l.5-.2a3 3 0 012.2 1l.7 1 .3 1.5.1 1.6v2.1c0 3.5-.8 5.2-2.4 5.2zm0-.7l.6-.3.4-.7a16.6 16.6 0 00.4-5.7l-.2-2v-.4a2 2 0 00-.4-1.2c-.3-.3-.6-.5-1-.5-.5 0-.7.3-.9.7l-.1 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm8 .7c-.2 0-.4-.2-.5-.3a.7.7 0 01-.3-.4l.2-.4.4.1h.4c.2 0 .4 0 .6-.2.1-.2.3-.5.3-.8l.3-1.5a5 5 0 00-.8-2.5l-.2-.4a20.8 20.8 0 01-1-2l-.2-1.4c0-.6.2-1.1.4-1.7l.5-.7.8-.2c.2 0 .4 0 .6.2l.2.5v.2l-.4.1-.4-.1c-.2 0-.4.3-.6.7l-.2 1c0 .4 0 .8.2 1.1 0 .4.2.7.4 1l.4.7.6 1.2.4 1.1.2 1.4c0 .7-.2 1.4-.5 2a2 2 0 01-.8.9c-.3.2-.6.3-1 .3zm7 0c-.5-.2-1-.2-1.7-.2l-.6.2-.4-.2a84.8 84.8 0 010-8.4v-.2-1.7c0-1.1.2-1.7.6-1.7l.4.1.1.3v.7l-.1.7a118.7 118.7 0 000 5.1v.2l-.1 1.4v1.5c0 .8.2 1.2.6 1.2h.7c.7 0 1 .2 1 .5 0 .1 0 .2-.2.3l-.4.2zm4 0c-.2 0-.5 0-.8-.3-.2-.2-.5-.4-.6-.8-.4-.7-.6-1.5-.7-2.3a18 18 0 01-.1-2.8v-2l.1-1.8c0-.6.2-1.1.4-1.7l.4-.5.4-.2a3 3 0 012.3 1l.6 1 .3 1.5.2 1.6v2.1c0 3.5-.8 5.2-2.4 5.2zm0-.7l.6-.3c.2-.1.3-.4.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.8.7l-.2 1.5v2.7a34 34 0 00.4 4.6c.2.8.4 1.3.8 1.3zm5.5.1v-.7V167.7a77.3 77.3 0 01-.6-8.7c-.7 0-1.1-.1-1.3-.3l-.2-.3s0-.2.2-.2l.4-.2 1.2.1 1.2.1H139.7c.4 0 .6.2.6.4s0 .3-.2.4l-.4.1a3 3 0 01-.5 0l-.4-.1v.2l.3 5a62.8 62.8 0 01.1 5.6l-.4.1-.3-.2zm6.7.3c-.4 0-.6-1-.6-3V165v-.3-.2h-.9l-.6-.1v2a30.8 30.8 0 00.1 3l-.1.5-.4.2c-.3 0-.4-.3-.5-.7a9 9 0 01-.2-1.8v-1.4l.1-1.3v-.6-1.5a55.5 55.5 0 000-4v-.5l.4-.1c.4 0 .6.3.6 1v4.5l1 .1h.6v-.2a43.7 43.7 0 00-.2-5.1l.1-.3.4-.2.4.1h.1c0 1.8 0 4 .2 7l.2 4.5-.2.4-.5.1zm7 .2l-.5-.1a.6.6 0 01-.2-.4v-.9-.3-1.2l-.1-1.1a92.8 92.8 0 010-6v-.8c0-.9.3-1.3.8-1.3l1.3.3c.6.1.8.3.8.5l-.1.4-.4.2-1.4-.4a12.5 12.5 0 010 2.1v1.6h.7c.6 0 .9.1.9.4l-.2.4-.4.1h-1a19.3 19.3 0 010 3 36.6 36.6 0 000 2.6h1.4c.4 0 .6.1.6.4 0 .2 0 .3-.2.4a1 1 0 01-.5.1H152zm5.1-.2c-1 0-1.5-.2-1.5-.6 0-.2.1-.4.5-.4H157v-.4a19.1 19.1 0 00-.1-2.5 77.1 77.1 0 01-.2-5v-1-1a2 2 0 01-.4.1c-.3 0-.4-.1-.4-.4 0-.2 0-.3.2-.4l.7-.2 1.3-.2c.1 0 .3 0 .4.2l.1.3-.1.4-.3.1H157.5v.4a93.8 93.8 0 00.4 8.8v.7h.3c.5 0 .8.2.8.6v.1l-.4.3h-.2-1.1zm4.2-.3v-.7V167.7a77.3 77.3 0 01-.5-8.7c-.7 0-1.2-.1-1.4-.3l-.2-.3s0-.2.2-.2l.4-.2 1.2.1 1.2.1H162.7c.4 0 .6.2.6.4s0 .3-.2.4l-.4.1a3 3 0 01-.5 0l-.3-.1v.2c0 1 0 2.8.2 5a62.8 62.8 0 01.1 5.6l-.4.1-.3-.2zm6.8.3c-.4 0-.7-1-.7-3V165l.1-.3-.1-.2H166.7l-.6-.1v2a30.8 30.8 0 00.1 3l-.1.5-.4.2c-.2 0-.4-.3-.5-.7a9 9 0 01-.1-1.8v-1.4V164.2v-1.5a55.5 55.5 0 000-4l.1-.5.4-.1c.3 0 .5.3.5 1v4.5l1 .1h.6v-.2a43.7 43.7 0 00-.2-5.1l.1-.3.4-.2.4.1h.1l.2 7 .2 4.5c0 .1 0 .3-.2.4l-.4.1zm3.6.2l-.5-.1a.6.6 0 01-.2-.4v-.9-.3-2.3a92.8 92.8 0 010-6v-.8c0-.9.2-1.3.7-1.3l1.4.3c.5.1.8.3.8.5l-.2.4-.3.2-1.4-.4a12.5 12.5 0 010 2.1v1.6h.6c.6 0 .9.1.9.4 0 .2 0 .3-.2.4l-.4.1h-.9a19.3 19.3 0 010 3 36.6 36.6 0 000 2.6H173.5c.5 0 .7.1.7.4 0 .2 0 .3-.3.4a1 1 0 01-.5.1H172zm7.4.1c-.2 0-.5-.3-.7-.9-.3-.6-.4-1.2-.6-1.9v-.6l-.8-3h-.2v2c0 1.6.1 2.9.4 3.8l-.2.5h-.5l-.3-.3v-1.2a110 110 0 00-.3-9.8c0-.6.2-1 .6-1 .7 0 1.2.3 1.6.6.4.3.6.8.6 1.4v1.9l-.3.5-.3.7-.3.5.1.5.3 1.2a28.3 28.3 0 001 3.9l.1.2c.2.2.2.4.2.6l-.1.3-.3.1zm-2.2-7.2c.3-.1.5-.5.7-1l.3-1.7c0-.4 0-.8-.2-1.1 0-.2-.2-.4-.3-.5a.8.8 0 00-.5-.1v4.4zm5.7 7.2c-.1 0-.3 0-.4-.2a.7.7 0 01-.2-.5l.2-.4c.2-.2.3-.3.5-.3s.3.1.5.3l.2.4c0 .2-.1.4-.3.5l-.5.2z';

  var animalCroc = 'M6.1 65.6c-.6-1.5-1.4-2.8-1-4.5.2-.8 1.1-2 1.7-2.7 1.7-1.6 3-2.5 5.5-2.5 2.2 0 4.3-.2 6.1.8 1.1.6 2.4.6 3.5 1.2.7.4 1.1 1.6 1.7 1.9M22.1 57c1.9 0 4.9-.6 6.7 0 1.3.4 2.5 1.4 3.7 2m-3-2.8c1.6-.3 2.8-.8 4.4-.8h2.4c1.3 0 2.8 1.4 3.8 2m-8-2.7c0-3 2.1-4.5 4.5-5.6 1-.4 2 .5 2-1a8 8 0 011-3.2c1-1.8 2.7-2 4.5-1.4 1.7.5 2.8 2.2 4.4 3m0 2.3c2.5-2 5.6-4.5 8.8-2.8 2 1.2 3.4 3.4 5.4 4.4m-.5-2.3c2.6 0 5 .3 7.4.5 1.2 0 2.4 1.4 3.4 1.7 1.2.4 2.2 1.2 3.4 1.6 1.2.4 1.8 1.5 2.8 2m-7-6.3c.8-.7 2-1.6 3.1-2 .4-.2 1.4-.7 1.7-1 .5-.6 2.4-1.5 3.3-1.6 1-.1 2-1 3.1-1a9 9 0 003.3-.7c.9-.4 2.7-.6 3.7-.6 1.3 0 2.5-.5 3.8-.5 2.8 0 5.6-.5 8.4-.5 1.3 0 2.5 0 3.7.2 2.2.3 5 0 7 .8 1.1.4 3 0 4.2.3 1.3.2 2.6.7 4 .7s2.7.5 4.1.5h3.8l5.2.3c1.2 0 2.6.6 3.8 0 .7-.3 2.5-.3 3-.9.3-.4 1.2-.3 1.6-.6a4 4 0 011.5-.8c1.3-.1 4.1-1.4 4.8-2.7.3-.5.9-.7 1.2-1.2.2-.4.2-1.5.5-1.7.3-.3.6-2.5.6-3 0-1.3.3-2.5.3-3.7 0-2-1.2-4.3-2.6-5.7-.7-.6-1.6-1.1-2.4-1.5-.9-.6-1.5-1.3-2.4-1.8-2-.9-4.3-.3-6.5-.8-2-.5-5-.5-7.1-.5h-7.7c-1.5 0-2.9 0-4.2.2-1.2.3-2.3.8-3.5.8h-3.4c-1 0-2 1-3.3 1-2.2 0-4.5 1-6.6 1.5-2.3.7-4.5 1-6.8 1.8-1.2.4-2.6 1-3.8 1-1.1 0-2.2.8-3.2.8-2.3.1-4.4 1-6.7 1-.6 0-1.1.3-1.7.3-.2 0-1.7 0-1.5.2.4.3 2 1.4 2.4 1.5 2 .6 3.6 2 5.7 2 1 .1 2 .3 3.2.3 1 0 2.1.6 3.1.6l7 .2h7.1c1.4 0 2.7.9 4 1 1.1.2 2.3 0 3.5 0 2.6 0 4.9 1 7.4 1 1.1 0 2.6.3 3.7.8.8.4 2.5 1.3 3.3 1.3 1.8 0 4.2 2.1 5.8 3 1.8 1 3.6 3.1 4.7 4.8m8.6-22c1.9.6 3.6 1.3 5.2 2.2 1.2.7 2 2 3.1 2.6 1.6.9 4.2 3.4 4.4 5.3.2 1 1 2.2 1 3.2 0 2 .8 3.6 1 5.4.4 2.5.3 5.1.3 7.7 0 1.1.4 3-.1 4l-1.9 4c-1 1.9-3.5 3.4-5 5-.8.7-1.5 1.5-2.5 2-1 .4-1.6 1.2-2.5 1.7-1.2.7-2.7 1.3-3.7 2.1-.8.7-2.6.8-3 1.7M129 59c-1 4.7-4.3 11.4-.4 15.7 1.2 1.4 2.5 3.3 4.4 3.8 2.5.7 4.5 2 6.7 3.3m.2-23.6c.8.6 2.3 1.4 2.5 2.5.3.8.5 2 1 2.7.4.8 0 2.4 0 3.3 0 1.8.8 1 1.8 1.8l3 2.2c.7.6 1 2 1.8 2.5 1.3 1 2.9 3 3.4 4.7.3 1 .2 2 .2 3.2 0 1.7-.7 1-1.8 2l-1.6.5c-.4.2-1 .7-1.4.8-.6 0-1.7 1-2 1.5-.7 1-3.5 3.5-4.6 3.6-.6 0-2.4.7-3 .2 0-.1 1-2.2 1.2-2.3m-1.5 1c-1 0-1.9 0-2.8.5-.3.1-1.5.5-1.3 0 .3-.6.8-2.8 1.3-3m-1.5 2c-.9 0-2.7.4-2-1.1.3-.4.7-1.7.7-2.2 0-1.2 1.8-2.3 2.8-2.8m-4 3.3c0-1.5-.5-3.2 1.2-4 1-.4 2-.3 3-.8m-6-1.5c-1.3.5-3 1.4-4 2.4-.2.3-1.4.7-1.7.9-.5.2-.9.9-1.3 1-1 .3-1.9 1-3 1-.7.1-3 .8-2.2.8m-.3-3.3c2.8 0 5.7.1 8.3-1 1.3-.6 2.4-1.7 3.7-2.3M119 84c0-.1 1-2 1-1.7m-20-10.2c1.7 0 3.5-.3 5.3-.3 1 0 3.3-.4 4.1.2.4.3 1.4.5 1.9.7.6.4 1 1 1.6 1.5 1 .9 2.2 1.5 3 2.5 2 2.2 1.5 5.7 1.3 8.3 0 1.3-1.3 2.3-2 3.3l-2 3.2-1.4 2.2c-.2.5-1.5 1.3-1.3 2 0 .3-1.4 1.6-1.6 1.8-.4.4-1.3 1-1.6 1.4-.6 1-2 2-2.9 2.8-.7.7-1.7 2.3-2.8 2.6l-3.3 1c-1.2.4-2.2 1.7-3.3 2.3-.5.3-1.4 1-1.4.3s.1-1.5.3-2.2c.1-.6 2-3.4 2-2.4m-3.3 2.8h-2.3c-.2 0-.7.3-.7.1-.2-.5.5-1.5.7-2 .2-.5 2.6-4.4 3-3.4m-4.5 3.3l-3.4.2c-.8 0 .3-1.8.6-2.2.6-.9 1-1.9 1.9-2.6.4-.3 1.2-.8 1.4-1.3m-3.8 2.6c-.1 0-2.7.1-2.5-.3.2-.4.7-1 1-1.2 1-.8 1.8-1.1 2.9-1.7.9-.5 2.3-.8 3.1-1.4.5-.5 3.7-1.5 3.6-1.5m-.5.8c.7-3.3 3-5.8 4.4-8.7a19 19 0 012.7-3.8c1-1.1 2.2-3.4 3.6-4M92.7 91.1c-3.2-.4-6.7-1-8.3-4.3a11.5 11.5 0 010-9.1M86.8 91c-4.7 0-9.4 1-13.9 0-3.2-.7-6.4-.8-9.6-1.6-6.2-1.3-11.4-5.4-17.2-7.3m21.4-4.6c2.7 2.1 5.5 4.3 8.6 5.8 1.1.6 2.3 1.5 3.4 1.8 1.2.4 2.6.8 3.7 1.3m-30.2-.7c.6 0 3.4.3 4-.2.4-.3 2.5-.4 3-.4 1.7 0 3.6-1 5.2-1.5m.7 6.1c2.4-.5 5-1.7 6.9-3m-16.3 2.5c-2.2.4-4.2 1.4-5.9 2.7-1.5 1.3.9-3.8.9-4.2m-2.6 3h-3.3c-.2 0-.7.3-.7.1l.5-1.3 1.3-2c.2-.4 1-1.6 1-.6m-3.6 2c-.7 0-2.7.5-2-.6.5-.5.8-1 1.1-1.5a6.4 6.4 0 013.2-3m-4 3.4c-.4 0-2.7.3-3 0-.4-.4.3-1.7.5-2 .6-.5 2-1 2.2-1.6M5 63.3c.3 1.6.5 2.5 2.2 2.5h3.4c2 0 3.6 0 5.1 1.5 1.5 1.5 3.2 1.3 5.3 1.3a8 8 0 003.7-.6c.7-.4 1.8-.9 2.6-.9 2.3 0 3.3.6 5.1 1.6 1.9 1 4 1.2 6.1 1.2l7.6-.2c2.2 0 3.8.5 5.9.5m8-7.1a16 16 0 01-5.9 7.7c-1.1.7-2.7 2-4 2.4-.8.2-1.3.7-2 1-.7.3-1.5.1-2.4.3-.8.2-3.1.2-3.6.9-.2.2-1.5.6-1.8.6-.7 0-1.2.6-2 .8-1 .2-1.7 1.5-2.7 1.8-.5.1-1 .6-1.7.9-.4.2-1.5.4-1.7.7-.5.6-2.8.8-3.6.9-.3 0-1.9.2-2 .4-.3.3-1.6 0-2 .3-.6.2-3.9.3-4.3 0-.7-.6-.9-3-.3-3.7 1.7-1.9 4.8-2.2 6.3-4.6 1.2-2.2 3.6-3.8 4.3-6.1m-2 .5a30.1 30.1 0 01-9.3 7.8c-1.6 1-3.1 3-3.1 4.9 0 1.1-.2 2 .5 2.9.6.7 2 .6 2.5 1.3.4.5 2.6.9 3.3.9l3.4.2c2.2 0 5.2.4 7-1 .4-.4 1.9-1 2.4-1 1 0 1.8-1 2.8-1 1 0 2-.5 3-.5.6 0 2.6-.4 3-.8.7-.4 2.6-.4 3.4-.5 1.2-.3 2.2-.5 3.5-.5 1 0 2.2-.3 3.4-.3 1 0 2.8.3 3.8-.1 2.1-1 3.7-1.8 5.4-3.5 1.5-1.5 3.3-2.5 4.4-4.4 1.1-2 3.2-4 3.8-6.3.4-2 .7-4.7-.7-6.3-1-1.1-2.5-3-4-3.5-1-.3-1.8-.5-3-.5-.3 0-1.4-.2-1.7 0-.1.2-1 .8-.8.8m-3 5c3 0 8.6-.5 8.6 3.7l-.2 4.6c0 1.2 0 3.6-.6 4.7m-8.8 5.3c0-1.7.9-3.3 1.5-4.8.4-.8.6-2.9-.3-3.3m-8.6 8.1l1.3-3.8m-10.7 5.6c0-1 .5-3.8.5-2.8m-6.9 5v-1.7m-7-1.3c0-.1-.3-2.2 0-2.4.3-.4.6.8 1 1 .8.5 1.4 1.4 2 1.7m-11.2-2.6c-.3-.8-.4-1.9-.9-2.6-.4-.7.4 0 .5.1.6.5 1.7.8 2 1.5m-3.1-9.4c0 .6-.1 4.7.6 3.9.7-.8 1.6-1.7 2.2-2.6M8.4 66.6s2.2 4.1 2.3 2.5c0-.4.7-2.6 1-2.7m29.5-16.8c-2-.3-3.2 1-2.4 2.8.3.7.4 1 1.3 1 .5 0 .3-1.3.3-1.6v-2c0-1-.5.1-.5.6 0 .6-.6 1-.5 1.7 0 .5 1.1.8 1.2.4.4-1.2 1-3 .5-4.3-.4-1.6-1.2.8-1.2 1.4 0 .8-2 2.8.1 3.3 1 .2.6-1.4.6-1.9 0-.8-.8-1.3-1-2.2m15.5 3.3c-.7-.5-2-2.4-2.8-.9-.3.8-.5 1-.5 1.8 0 .6 1.1 1.3 1.5.8.5-.6.9-1 1-1.8.2-.5.2-1.7 0-2.3 0-.4-1.2 1.1-1.4 1.3-.4.5-.7 1.5-.6 2.3.2.8 1 .6 1.7.6 1 0 .9-3.2-.2-3.3-1.2 0-2.2 2.8-1.4 3.8 1.1 1.4 2.3-1.4 2.2-2.3 0-.4-1.4-1-1.7-.7-.6.6-.6 1.3-.6 2m30.7-.5c.5-1.2 1.6-4.6 1.6-3.4 0 .8.7 1.9 1.4 2.4.9.7.6 1.3-.4 1.3-.3 0-2.6.6-1.5.2m6.3-3c.5-.8 1-2.2 1.6-2.8.1-.1.3.6.4.7.5.2.9.5 1.2 1 1.1 1.4-1.6 1.6-2.7 1.6m6.4-3c.2-.2 3-2.4 3-2.1 0 .6.8 1.3 1.2 1.9.5 1-1.7.8-2.2.9l-2.2.2h-.3m8.8-2c.1-.2 1-2.5 1.6-1.9l.7.7c.5.3 1.3 1.7 1.3 2.2 0 1-4.6-.2-4.6-.2m9.7-2c1.5-1.2 1.6-1.5 2.7 0 .5.6-2.3.4-2.7.4m9.1 0c1.1-.4 2.5-1.2 2.5.7 0 .2-2.4.1-2.7.1m9.6 1c.2-.1 1.7-1.5 2-1.1l1 1c1 .9-1.7.6-2.2.6m8.4-.2c.3-.4 1-1.8 1.5-1 .1.3.5.4.5.7 0 .7-1.6.6-2 .8m6-2.3c0-.6 0-2.4.8-1.1.5.8.9 1.6-.2 1.6m3.5-2c0-1.5 0-1.6 1-.5.7.7.4.8-.5 1m-78.7 0c.5-1 1.2-2 2-2.5.5-.3.6-.7.3 0s-.6 2.8-1 3m5-1.8c.2-.5.5-2.4.6-1 0 .3.5.7.7 1 .5 1 .8 1.3-.5 1.3m7.6-3.3c.4-.6.8-1.8 1.4-2.3.1-.1.2 1.1.3 1.3.5 1 .7 2-.7 2m5.6-2c.4-.4 2.3-2.5 3-2.3l.3 1.9c0 .9-.5.9-1.2.9-.4 0-2.2-.3-1-.3m6.8-.7c1.9-1.6 2-2 3-.2.8 1.7-2.4.8-1.7.4m8.1 1c.3-.1 2-1.5 2-.6 0 .5.3.9.3 1.4m8.6-.5c.8-1 1.3-2 1.3-.4l.2 1.6m6.1-.5c.2-.8.2-2 .9-1.3.4.6 1 .6 1.2 1.3m6.8-1.5c.4-.9.5-1.6 1-.6.3.3.6.4.8.9m7.9-6.4c0-1.1 0-1.2.2-.2m1-3c0-.8-.4-2.2.2-1.2l.6.9M52.8 52.3c0 .3-.5 3.4 0 2.3.3-.6-.2-1.3.3-1.9.1-.1 1.3-.6.6-.6-.4 0-1.8-.2-1.9.5 0 .7 1.1 1.3 1.8 1.3s0-1.3-.6-1.3c-1.3 0-1.3.3 0 .3.7 0-1.1.3-.4 0M25.2 81.5c0-8.6 11-10.9 17.7-10.9m4.4 1.6c-1.9 0-3.8-.2-5.5.2-1.6.4-2.8 1.1-4.3 1.5-1 .3-2.8.8-3.5 1.5l-1.5 1.2c-.5.7-1.1 1.6-.7.1m-22-58.6c-.2 0-.3 0-.4-.2l-.1-.4-.1-.3V17A99.1 99.1 0 006 7.9v9.2l.1.1.1.2c0 .2 0 .3-.2.4l-.4.2c-.3 0-.5-.4-.5-1.1v-3a240.4 240.4 0 010-6.5c0-.6.2-1 .7-1.4v.1h.1c.3 0 .6.5 1 1.4L8 10l1 3.6.2.7.7 2c.2-2.5.3-5.6.3-9.1V7v-.3c0-.3.1-.5.4-.5.2 0 .3 0 .4.2l.2.5v1.3a142.2 142.2 0 01-.7 9.7l-.6.2zm5.8.2c-.3 0-.6 0-.9-.3-.3-.2-.5-.4-.6-.8-.4-.7-.6-1.5-.7-2.3a18 18 0 01-.1-2.8v-2l.1-1.8c0-.6.2-1.1.4-1.7l.3-.5.5-.2a3 3 0 012.3 1l.6 1 .3 1.5.1 1.6V13c0 3.5-.7 5.2-2.3 5.2zm-.1-.7l.6-.3c.2-.1.3-.4.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.8.7c-.2.4-.2.9-.2 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm5.8.7c-.1 0-.3 0-.4-.2a.7.7 0 01-.2-.5c0-.1 0-.3.2-.4.1-.2.3-.3.5-.3s.3.1.4.3c.2.1.2.3.2.4 0 .2 0 .4-.2.5l-.5.2zm5.2 0c-.1 0-.3 0-.4-.2a.7.7 0 01-.2-.5c0-.1 0-.3.2-.4.2-.2.3-.3.5-.3s.3.1.4.3c.2.1.2.3.2.4 0 .2 0 .4-.2.5l-.5.2z';

  var animalGiraffe = 'M35 75.7c-3 .7-5.8 3-8 5-1.6 1.4-4.3 2.4-4.3 5 0 .9-.4 2.6-.8 3.4-.5.8-.2 2.2-.2 3.1 0 2.4-.2 4.9.4 7.2.9 4.1 7.4 5 10.9 5 2.4 0 4.9 1 7.2-.2 2.2-1 3.9-2.6 5.8-3.7 1.8-1 3.6-2.3 5.3-3.3a14 14 0 002.6-2c.7-.5 1-1.7 1.7-2.3 1-.8.5-5 .5-6.3 0-2-1.4-5-2.7-6.5-1.4-1.5-2.8-2.4-4.2-3.7-1.4-1.3-4-.7-5.3-1.9-.7-.5-2.4-.4-3.3-.4-1-.1-2-.7-3.2-.4-1.5.5-2.8 2.5-4.4 3m-6.7 13.2c-1.1 1.5-1.6 2.1-1.6 4 0 1.3 1.6 1.4 2.5.7.9-.8.8-2.1.8-3.2 0-.8-1.3-2.5-1.3-2.5m5.3 0c0 1.7-2.1 7.7 1.4 6.6 1.5-.4-.1-5.8-.1-6.9M54 60.8c-2.3-.4-2.6-.4-2.6 1.8 0 1.6 0 2.2 1.8 2.2 2.4 0 3.3-3.6 1.2-4.6m-2.4-6c-1.5 0-3.9-.4-5.4 0-.9.3-1.6 1.5-2.2 2.2-1.3 1.6-1.6 4.8-1.6 6.9 0 2 2.4 4.7 4.1 5.6 1.3.8 5.5 1.8 7 1a39 39 0 013.1-1.5c1.2-.6 1.4-1.7 2-2.5 1.5-1.8 1.6-4.8 1.6-7 0-2-2.7-4.5-4.6-4.7-1.8-.2-6.4-2.4-7.6 0m22.5 7c-1.5 1-2.4 2-.5 3.1.7.4 2 .3 2.6-.2 2-1.5-.9-3.2-2.1-3.6m1-7.3c-5.8 0-9.5 5.1-8.3 10.8.6 2.4 3.2 4.8 5.3 5.8 1.3.7 2.9 1 4.3 1 1.7 0 2.4-1 3.8-1.7.9-.5 1.9-1.4 2.7-2.2.7-.7 1-2.3 1.6-2.8 1.4-1-.6-6.5-1.5-7.6-1-1.1-2-2.6-3.3-3.4-1-.5-2.9-.2-4.1-.2-2.3 0-5 .8-6.1 3M35.9 75.7l6.1-5.3c.5-.3 2-2.2 2.2-2m13.2-15.2c1.4-2.6 4-4 5.3-6.5 1-1.6 1.9-2.6 3.3-3.8 2.3-2.1 5.1-1 8-1 1.4 0 2.7.7 4.1.7 1.4 0 2.8 0 4.1.6 1.4.6 2.8 1 4.2 1.7 1 .6 1.4 1.9 2 2.9.7 1.3.6 3.1 1.5 4.4.7.9.5 3.2 1.4 4 .7.6.7 3 1.1 4 .4 1 .7 3 .7 4 0 2 1 4.2 1 6.3 0 2 1 4 1 6 0 3.3 2.3 6.5 2.3 9.8 0 2.3.8 5 1.2 7.3.4 2.6.4 5.9 1.4 8.2.3.6.4 2 .4 2.7 0 1 .5 1.8.7 2.8.4 2.3.2 4.8.7 7.1 1 4.6 1.8 9.3 2.9 13.9.6 3 .7 6.4 2.2 9 1.7 3.3 4.5 3.2 7.6 4.6 1.5.6 2.7.6 4.4.6 1.6 0 2.6.7 4 1.3 1.5.6 3.4.6 5 1.2 1.3.5 2.9.8 4.3.8 2.7 0 5.5 1.6 7.7 2.8 2.1 1.2 5.3 1.5 5.8 4.3s0 6.3 0 9.1c0 1.8.4 3.6.4 5.3 0 .8 0 4 .5 4.3.8.7.6 3.3 1 4.3.3.7 0 1.5.3 2.2.3.6.5 2 .5 2.7.3 8.9 0 17.8 0 26.7 0 5.4.3 10.7.3 16 0 4.5.7 8.8.7 13.3v8c0 1.5-.4 3.5.2 4.9.4.8.4 2.9.4 3.8 0 1.3.4 2.7.4 4.1 0 2-.7 1.7-2.5 1.7-1.4 0-2.4-.4-3.8-.4h-4.2c-.8 0-3.1 1-3.8.2-.3-.4-1-.2-1-1 0-.7.7-1.2 1-1.8.4-.8 1.3-2.5 1.9-3 .7-.6 1.2-3 1.5-3.9.6-1.5.3-3.4.3-5 0-6.4-.3-12.7-.3-19 0-3.3-.7-6.5-.7-9.6 0-.9 0-3.5-.4-4-.8-1.1-2-.8-3.4-.8h-29c-3.3 0-6.4.6-9.5.6-2.1 0-2.4.4-2.4 2.5l-.3 6c0 4.2-.3 8.4-.3 12.5 0 1.5.6 3 .6 4.5v5.8c0 1.7.4 3 .4 4.7v2c0 1 .3 1 .6 1.6.4.8 4.1 8.4 2.2 8.4-1.6 0-3.2-.7-4.8-.7h-5c-1.5 0-6.6 1.6-6.6-1 0-2.3 3-4.8 3.6-7a28 28 0 001.4-7.7v-9.4-4.5c0-1.6-.7-3.1-.7-4.8 0-2.4-.2-6-1.2-8.2-.5-1.1-.1-2.7-.5-3.8-.2-.8-.4-2.6-.9-3.2-.5-.8.2-3-.5-3.6-.8-.6-.8-3.4-1-4.3-1.7-6.1-.8-12.6-.8-18.9v-14.8c0-4.1-.7-8-.7-12 0-4.6-.7-9-.7-13.7 0-4-1-7.6-1-11.6 0-3.2 0-6.4-.6-9.5-.3-1.2-.6-3.1-1.3-4-.4-.5 0-2.2 0-2.8v-6.6c0-1.7-.4-3.4-.4-5.2 0-1.3-.9-2.6-1-3.8 0-.6-1.1-3.7-1.5-3.6-.7.2-1 .9-1.8 1-.4 0-1.4.3-1.8.5-1.3.7-3.1-.2-4.5.4-1 .5-3 0-4.1 0-1.9 0-6.4-1.2-6.4-3.6m26 113.5v13.8c0 4.3 1 8.6 1 13v7.2c0 1.7.6 4.6-.3 6-1 1.7-1.9 3.9-3.2 5.4-1.5 1.7.7 3.3 2.3 3.9m.6-9h3.6m2 3.7h10m36-4h5.3m3 4h8.6m-2.3-97.3c.6 2.8 2.5 5.6 2.6 8.3 0 1.5.7 3 .7 4.5 0 1.2-.3 2.7.2 3.8.6 1.2 0 3 .1 4.3.2 1.5.8 3 1 4.6.4 3.4 2.2 5.3 1 8.9a21 21 0 000 15.6c.3.8 1 2 2.1 2.3 1.4.3 2-1.3 2.6-2.3 1.3-2.7 1.2-5.7 1.2-8.6 0-2.3-1-4.3-1.9-6.3-.5-1-.8-2.4-1-3.5-.3-1.3-1.4-2.4-1.4-3.8 0-2.1-1.5-4.3-1.6-6.6 0-1.2-.7-2.2-.7-3.5 0-1.4-.3-2.7-.3-4.1 0-4.9 1.4-12.5-2.7-15.8-1.8-1.4-3.7-.2-5.3-1.7-.7-.5-2.6-1.4-3.4-1.7-1-.2-1.8-1-2.8-1M69 41.6v-7.9c0-.8.2-2 0-2.8 0-.3-2.2-.5-2.6-1-1.2-1.4-1.4-3.4-1.4-5.1 0-1.8 4-1.7 5.2-1.7 1.8 0 3.6 1.2 4.1 2.8.6 1.9-.9 3.2-2.6 4-1 .6-1 1.2-.5 2.5.4 1.1 0 2.4.1 3.6.2 1.2.4 2.1.4 3.3 0 1 .6 1.5.6 2.3m11 1c0-2.8 2-5 2.2-7.6.1-.6 1.9-4.2 1.3-3.7-1.3 1-2-4.6-2-5.2.2-1.9 4.3-1.4 5.4-1 1.6 1 3.3 2 3.3 4 0 1.1.2 1.7-.6 2.4-.7.5-2.2.2-2.7.6-.5.5-.2 2.2-.8 2.9-.6.7-1 1.8-1.5 2.7-.4.8-2.8 3.5-2 4.3m4 2.6a21 21 0 0112-4.6c2 0 2.9 1.5 4.3 2.6.6.5 1.2 1.5 1.8 2 .7.8 1.7 1.7 2.3 2.5 1.3 1.6 3.5 2.6 4.7 4.6.4.8 1 1.5 1.6 2.2.9 1-.5 1.2-1.4 1-3.8-1.1-7.6-4-11.6-4-1.8 0-3.6-.7-5.5-.7-1 0-4.9.1-5.7-.5-.6-.5-1.9 0-1.9-1.3V47c0-.4.8-.3 1-.6.7-.4 2.4.1 3.1 0 1-.3 2.2-.6 3.2-1.1 1.2-.6 4.7-.9 5.7 0 1.3 1.2 2.9 2.3 4.5 3.1 1.8 1 3.3 1.8 4.7 3.2.6.5 1.2 1 1.6 1.6.1.1 1.8 1.4 2 1.4M67 42a23.8 23.8 0 00-5.7-6.2c-.8-.7-3.2-1.7-4.2-1.8-1.8 0-3.5.2-4.9 1.4-1.2 1.1-3.4 1.1-4.8 2.2-2.6 2.1-6.1 3.2-8.4 6.1-.2.3-1.2 1.6-.8 1.6 1 0 1.9.3 2.7.3 2 0 3.7.3 5.8.3h12.2c.9 0 2.1.3 3 0 .5-.1 1.2-1.2 1.6-1.6 1.6-1.2-2.2-3-3.3-3.3-1.7-.4-3.3-1-5.3-1l-5.6.3c-1.5 0-3.4 1.7-5 2-1.7.4-3.7 1.7-5.4 1.7m59.2 51.6c-1.5.6-3.6 1.6-4.5 3-.6 1.2-.7 2.8-1.4 3.6-.3.5-.2 1-.7 1.4l-1.3 1c-1.2 1.5-1.7 1.5-1.7 3.5 0 3.1 2.6 2.7 4.2 4.4 1 .9 2.1 2 3.3 2.6 1.2.5 2.6 0 3.8.6m-3 8.6h-6.1c-1.5 0-2.1.6-3.4 1-2.7.8-3 4.6-3 7 0 2.2 1.7 3.7 2.3 5.7.6 2.3 2.3 4 3.9 5.5 1.5 1.5 3.9 2.5 5.8 1 1-.8 1.3-2.4 2.1-3.3.9-1 1.7-2.4 1.7-3.6 0-2.5.5-5.5 0-7.8-.3-1-.6-2.4-.7-3.5 0-.8-1.6-3.1-2-1.6m-17.2 29.7c2.3.5 5.1 2.3 7 3.7.6.5 1 1.4 1.6 1.9 1.2.8.6 2.3 1.1 3.4 1.2 2.7-2.4 2.7-3.6 3.7-.7.5-2.5 1.2-3.4 1.2-1 0-2.7 2-2.7 1m6 14.2c-1.3.3-2.1.4-3 1.3-1 1-.2 2 1.2 2 1.2 0 1.2 0 2-.6.9-.7-.2-1.8-.9-2m18.9-12c-2.7.7-4.9 3-6.8 4.9-1.8 1.8-1.5 4-1.5 6.4 0 4.6 5.1 6.8 8.8 4.7 1.9-1.1 2.4-4.2 3-6 .8-2.2.6-4.7.1-6.8-.4-1.7-3-3-4.6-3.1-1.3-.1-5.5-1.2-6.3.3m12-25.5c-2 .5-5 2.8-5 5v5.8c0 1.4 1.8 3 3 3.5 1.7.8 3.5.6 5.4.6 3.5 0 7 0 10 1.4 1 .4 1.7.9 2.7 1.2.5.2 2.4.5 2.7.9.4.5 4.6.4 5.3 0 3-1.3 2-8.8.3-11a15.4 15.4 0 00-10-4.4c-1 0-1.8-.6-2.7-.6-1.9 0-3.6-1.4-5.6-1.4-2.2 0-4.3-.3-6.5-.3-.7 0-6.1.2-5.3 1m41 29.4c0 3.2 1 6.1 1 9.3l.3 7.1c0 .2-6.4-.6-7-1-1-.5-2.4-.9-3.4-1.1-.8-.3-3-1.5-3.1-2.4-.1-.7-1.3-1.9-1.6-2.6-.5-1.1.1-2.5 1-3.3l2.2-2.7c.7-1 .5-2.5 1.2-3.4 1.5-2 4-2.5 6.3-1.8 1 .3 1.5 1.5 1.8 2.4.3 1.1 1.6 1.7 2 2.8m-21.5 27.2a28.7 28.7 0 00-5.9-9c-.8-.9-2.3-2-3.5-2-1.9 0-2.7 1-4.3 1.7-2.4 1-4.5 2.4-6.7 3.6-1.4.9-2.7 1.6-2.8 3.3 0 .5-.4 4.2 0 3.4m48 22.4c-1.5-.2-3.8-.9-5 .5-.4.6 0 3 0 3.8 0 1.1 1 3 1.7 3.7 1.2 1.2 2.3.3 3.6.3m-15.5-28c0 5.1.7 10 .7 15.2l-.2 13.8c0 1.2.5 4.5-.2 5.4-1 1.3-1.4 2.6-2.2 4-.5 1-1.9 4 .1 4.2h2.4c.7 0 1.2.5 1.9.5M30.7 133l-.5-.1-.1-.4v-2.3l-1-.3-1.1-.2a3 3 0 00-.3 1l-.1.3a11.9 11.9 0 01-.3 1.3l-.2.5c-.5 0-.7-.1-.8-.4.1-.2.3-.7.4-1.7l.6-3.2a162.3 162.3 0 011.5-6.8c.2-.8.5-1.3.8-1.3.2 0 .4 0 .5.2l.4 3.5.3 3.7.2 2.7c.2 1.2.2 2.2.2 2.9 0 .4-.2.6-.6.6zm-1-3.9h.3l-.1-2-.4-5v-.1c-.2.1-.3.7-.6 1.6a66.1 66.1 0 00-.8 5.3c.5.2 1 .2 1.6.2zm6.4 4.2c-.4-.2-1-.2-1.6-.2l-.6.2-.4-.2a84.8 84.8 0 010-8.4v-.2-1.7c0-1.1.2-1.7.7-1.7l.3.1.1.3v.7l-.1.7a118.7 118.7 0 000 5.1V129.6l-.1 1.5c0 .8.2 1.2.6 1.2h.7c.7 0 1 .2 1 .5 0 .1 0 .2-.2.3l-.4.2zm2.4 0c-.2 0-.4-.2-.5-.3a.7.7 0 01-.3-.4l.2-.4.3.1h.5c.2 0 .4 0 .5-.2l.4-.8.3-1.5a5 5 0 00-.8-2.5l-.2-.4a20.8 20.8 0 01-1-2l-.2-1.4c0-.6.1-1.1.4-1.7l.5-.7.7-.2c.3 0 .5 0 .6.2.2.1.3.3.3.5l-.1.2-.3.1-.4-.1c-.3 0-.5.3-.6.7-.2.4-.2.8-.2 1l.1 1.1.5 1 .4.7.6 1.2.4 1.1.1 1.4c0 .7-.1 1.4-.5 2a2 2 0 01-.7.9c-.3.2-.6.3-1 .3zm6.2 0c-.3 0-.6 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.3a18 18 0 01-.2-2.8v-2l.2-1.8c0-.6.2-1.1.4-1.7 0-.2.2-.4.3-.5l.5-.2a3 3 0 012.2 1c.3.3.5.6.6 1l.4 1.5.1 1.6v2.1c0 3.5-.8 5.2-2.4 5.2zm0-.7l.6-.3.4-.7a16.6 16.6 0 00.4-5.7l-.2-2v-.4a2 2 0 00-.4-1.2c-.3-.3-.6-.5-1-.5-.5 0-.7.3-.9.7l-.1 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zM35.5 156c-.2 0-.3 0-.4-.2l-.1-.4-.1-.3v-.1a99.1 99.1 0 00-3.2-9.2v9.2l.1.1.1.2c0 .2 0 .3-.2.4l-.4.2c-.3 0-.5-.4-.5-1.1v-3a240.4 240.4 0 010-6.5c0-.6.3-1 .7-1.4v.1h.1c.3 0 .7.5 1 1.4l1 2.5 1 3.6.2.7.7 2c.2-2.5.3-5.6.3-9.1v-.2-.3c0-.3.1-.5.4-.5.2 0 .3 0 .4.2l.2.5v1.3a142.2 142.2 0 01-.7 9.7l-.6.2zm5.8.2c-.3 0-.6 0-.9-.3-.3-.2-.5-.4-.6-.8-.4-.7-.6-1.5-.7-2.3a18 18 0 01-.1-2.8v-2l.1-1.8c0-.6.2-1.1.4-1.7l.3-.5.5-.2a3 3 0 012.3 1l.6 1 .3 1.5.1 1.6v2.1c0 3.5-.7 5.2-2.3 5.2zm-.1-.7l.6-.3c.2-.1.3-.4.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.8.7c-.2.4-.2.9-.2 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm-15.8 23.8c-.4 0-.8 0-1.1-.2-.2-.1-.3-.3-.3-.4l.1-.4.3-.1.5.1.5.2.6-.3.5-.8a4.8 4.8 0 000-3.2c-.1-.6-.3-1.2-.6-1.7l-.3-.6a120.9 120.9 0 01-1.1-2.5l-.3-1.7.2-1.2.7-1c.3-.3.7-.4 1.1-.4.3 0 .5 0 .7.2.2 0 .3.2.4.4l-.3.4c-.3 0-.5 0-.7-.2l-.6.3a2 2 0 00-.4 1.4 5.8 5.8 0 00.6 2.7l1.3 2.5a7 7 0 01.7 3c0 .9-.2 1.6-.6 2.3-.2.4-.5.7-.8.9-.3.2-.7.3-1 .3zm7.3-.1c-.4-.2-1-.2-1.6-.2l-.6.2-.4-.2a84.8 84.8 0 010-8.4v-.2-1.7c0-1.1.2-1.7.6-1.7l.3.1.2.3v.7l-.1.7a118.7 118.7 0 00-.1 5.1V177.1c0 .8.1 1.2.5 1.2h.8c.6 0 1 .2 1 .5l-.2.3-.4.2zm4.1 0c-.3 0-.6 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.3a18 18 0 01-.2-2.8v-2l.2-1.8c0-.6.2-1.1.4-1.7 0-.2.2-.4.3-.5l.5-.2a3 3 0 012.2 1l.7 1 .3 1.5.1 1.6v2.1c0 3.5-.7 5.2-2.4 5.2zm0-.7l.6-.3.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.9.7l-.1 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm5.4.1v-.7V176.7a77.3 77.3 0 01-.5-8.7c-.7 0-1.1-.1-1.3-.3-.2 0-.2-.2-.2-.3l.1-.2.4-.2 1.3.1 1.2.1H43.5c.3 0 .5.2.5.4l-.1.4-.5.1a3 3 0 01-.4 0l-.4-.1v.2c0 1 0 2.8.3 5a62.8 62.8 0 010 5.6l-.3.1-.4-.2zm6.8.3c-.4 0-.6-1-.6-3V174v-.3-.2h-1l-.5-.1v2a30.8 30.8 0 000 3v.5l-.5.2c-.2 0-.3-.3-.4-.7a9 9 0 01-.2-1.8v-1.4V173.2v-.4l.1-1.1a55.5 55.5 0 00-.1-4l.1-.5.4-.1c.4 0 .6.3.6 1v2.3l-.1 2.2 1 .1h.6v-.2a43.7 43.7 0 00-.2-5.1c0-.1 0-.3.2-.3l.4-.2.3.1h.2c0 1.8 0 4 .2 7l.1 4.5c0 .1 0 .3-.2.4l-.4.1zm-10 12.5c0 3.3-.2 6.7 0 10 0 2.5 2.6 4.6 3.5 6.6 1.7 3.9 8.5 4.5 12 3.3 4.7-1.8 7.6-6.2 9.5-10.6 1.4-3.1 3.4-5.8 4.8-8.8m-5.2 0c1.2-.4 8.7-3.8 8.7-1.7v7';

  var animalPig = 'M24 8c3.4 0 6.4-.3 9.2-1.5 2.9-1.3 6.3-1 9.5-1 2.8 0 5.3-1 8.1 0 1.1.3 2.3.3 3.2.9L57 8m3.3-1.3c-2.8.6-4.3.7-4.3 4l-.3 3c0 1.3 1 1.9 1.6 2.7.6.8 3 2 3.9 2.3 1.8.5 1.8 3.3 3.3 4.2 1.2.8 2.1 1.8 2.8 3.2a17 17 0 002.8 4.1c1.4 1.7 3.3 3.5 5.6 2.5.9-.4 1.7-.8 2-1.8.2-1 0-2.5.4-3.4a19 19 0 00.9-5.8v-6c0-2.3-.1-4.7-1.2-6.7-.2-.4 0-.9-.2-1.4 0-.4-.8-1-1-1.6-.4-.7-1-2-1.8-2.4-2.7-1.7-7-3.5-10.1-2-4 1.8-7.6 4-10.7 7.3M79 13c4 0 7.3-1.1 11.2-1.1h12.7c2.7 0 5.6 2.9 8 4.1 2.2 1.2 5 2.6 6.7 4.3.8.8.7 1.1 1.6 1.6.8.4 1.2 1 1.7 1.5l3 3.8c.8 1.2 1.8 3.2 1.9 4.7 0 .7.5 1.6.7 2.3.2.9-.2 1.9.2 2.8.7 1.5.5 3.3.8 4.9.4 1.8.4 3.8.4 5.7 0 3.3.5 6.9-.6 10-1 3-2 5.4-3.6 8.1-1.1 2-3.6 3.2-5 5-1.2 1.5-.5-2.3-.4-2.8.1-.4-1 2.6-1 3.3-.2 3-2.5 5.5-2.5 8.4 0 4-1.2 8-3.2 11.4-.7 1.3-6.6 4-7.8 2.5-2.2-2.7-1.8-6.1-1.8-9.5l-.3-9c0 2.1-.2 4-.7 5.8-.2.5-4.3.2-5 .2-1.4 0-8.7-.3-8.8 1.4-.2 2 1.8 6.2 3.3 7.4 1.7 1.4 5.4 3.1 7.1.9 2-2.6 3.7-4.4 3.7-8 0-.3.2-1.9-.2-2-.4-.1-2.3-.2-2.6.2-.5.6-3.7.1-4.6.6-1.3.5-3.2.2-4.6.2-1.7 0-3.3.4-4.8.4h-10c-1.4 0-3-.4-4.5-.4-2.3 0-2.7-.2-1.7-2.4a17 17 0 001.2-5.8c0-1.5.9-3 1.3-4.3.3-1 .3-1.9 0-.1 0 1-.6 2.1-.6 3.2A34.3 34.3 0 0169 80c0 .3-.2 2.1-.4 2.4-.8.9-.6 3.1-1.6 3.9-.6.5-1.3 2.2-1.9 3-.7.9-1.4 2-2.5 2.7-1.4.7-2.9 1-4.4 1-1.9 0-2.5-.5-3.3-2.1-.6-1.4-.4-3-.8-4.4-.3-1-.2-3.5-.8-4.3-.7-1-.2-4-.2-5.2v-4.7M50 78c-3.6-.3-6.3-3-9.5-4.3-1.6-.6-1.2-1.8-2-2.9-.8-.9-1.1-2.2-1.6-3.3-.7-1.4-1.7-2.3-2.8-3.4-2-1.9-4-3.3-6.4-4.7-1-.6-2.8-1.4-3.7-2.2-1.2-1-1.6-2-2.6-3-1.7-2-2-4.5-3.7-6.4a9.7 9.7 0 01-1.5-4.3c0-1 .1-3.6-.4-4.3-1.3-1.7-.6-6.5-.6-8.8V21m8.8-6.7c-2.4 1-3.9 2-5.6 3.7-1 1.1-3 3.2-4.3 3.8-1.5.6-3 2.4-4.1 3.5a33.8 33.8 0 00-4 5c-.5.7-2.5 3.8-2.5 2.3 0-1.4-1-3.3-1.4-4.6-.4-1.5 0-3-.5-4.5-.3-1-.6-2-.6-3 0-2-.1-3.5.9-5.3 1-1.8 1.6-3.7 2.6-5.5.7-1.2 2-2.5 3-3.6C10 3.4 13.2 1.3 16 5c1.7 2.2 4.1 2.7 6 4.5 1 1 1.9 2.4 1.9 3.8 0 .9.1 1.7-.4 2.4-.4.5-1.4 1.3-1.4.1M37 70c0 3.8-.3 6.4 2.2 9.4.5.6 1.2 3.1 1.2 3.9.1 1.6 1.2 3.1 2 4.5 1.5 2.1 3.5 3.7 5.2 5.7C48.8 95 54 93 54 91.2M125 29c4.1 0 10-.7 12.1-4.2 1-1.7 1.3-7-.2-8.6-1-1-6.4-3.8-7.8-2.3-1 1.2-1.9 1.8-1.9 3.4 0 1.5.2 3 .4 4.3.3 2.3 5.3 3.3 7.3 3.3 3.6 0 6.2-2.4 8-5 1.3-2.1 1.5-5.1.4-7.3-.9-1.8-2.6-4.5-4.5-5.6M56.5 32c-2.1 0-3.4-.2-5 .6-.5.2-2.3 1.2-1 1.8 1.1.5 3.4 3.2 5.4 1.7 1.4-1 2-4.2-1.6-2.9-.9.3-1.5 1-1.2 1.6.3.6 2.8-1 1.8-1.5-2.3-1.4-5.6 2.3-1 2.3 1.4 0 1.4-1.3 1.1-2-.4-.7-2.4 0-2.4.8 0 3.4 5.5-1.7 2.7-2-1.2-.2-3.6.7-3.6 1.5 0 .5-.2 2.6 1.6 1.5 4-2.4-2.4-4-2.1-1.3.1 1.6 6.7-.3 4.5-1.6-1.6-1-6.8.7-4.9 2.1 2.2 1.7 6.2.7 5.2-1.5-.7-1.6-6.4.2-3.9 1.9 3.7 2.3 5.3-2.4 2.7-2.4-3.4 0-3.1 3.5-.7 4.2 2 .6 2.4-.3 2.4-1.4 0-1-1-1.3-2.4-1.6m-31 1.4c.4-1 1.6-3.6.2-4.4-1.2-.7-1.8-.2-2.7.8-1.8 1.8 1 4.7 2.8 3.1 1.7-1.6.3-5.3-1.3-2.7-.3.6-1.4 1.6-.5 2.4 1 .9 2.5 2.6 3.7.8 1-1.3 3-5.2-.4-5.2-2 0-3.4 2.9-2 4.6 1.8 2.3 5.3-2 3.7-3.6-1.7-1.6-4.8-.4-4.8 1.8 0 3.3 4.5-1 2.5-2-2.7-1.5-4.3 1-4.2 3.2 0 .8 1.7 1.4 2.4 1.6.8.2 1.8-2.1 1.8-2.8 0-1.2.4-2.4-1-2.4-1.7 0-2 .6-2 2.2 0 3.2 3.5 4.1 4.3.8.2-1 .6-1.8-1-1.8-.7 0-2.5-.3-2.8.6-.7 2.5 1.7 3.4 3.1 1.6 2.7-3.3-3.3-2.3-4.8-1.8m17 2l2 .2c.5 0 1.3 0 1.8.2l1 .3c.2.1.6.4.9.4.4 0 1.2.8 1.6 1 2 1 2.6 3.6 2.6 5.7v1.6c0 .5-.5 1.1-.7 1.6-.5 1-1.5 1.5-2.5 2-1.1.6-2 1-3.3 1.4-1 .3-2.3 0-3.3.5-.5.2-1.3 0-1.8 0-.6 0-1.1-.2-1.7-.3-.8-.1-2.6-1-3-1.8l-1.1-1.2c-.4-.4-.3-1.1-.8-1.4-.3-.3-.4-1.2-.5-1.5-.2-.5-.3-1.1-.3-1.7 0-1.1.3-2 .9-3l.9-1.2c.2-.4 1-.6 1.4-1 1-.7 1.7-1.4 3-1.4L36 34h1.7m-2.5 8.3C33.9 41 33 42.8 33 44c0 .8.2.9 1 .9s1.2-1.8 1.2-2.4c0-.4-.3-1.5-1-1-.6.5-.5 1.3-.5 2 0 3.8 3.5-.8 1.9-1.6-1.8-.9-2.1 2.2-1 2.2.8 0 1-2 .9-2.5 0-.3-.5-.6-.8-.6-.5 0-.6.2-.8.6-.2.6-.6 3 .3 3.1 1.1.2 1.7-.6 1.4-1.7-.3-.7-1.3-.5-1.5.1-.2 1 0 2 .7.8.2-.5.2-.8.2-1.3 0-.4-.4.2-.5.3v1.4c0 .2.1.5.3.3v-1.2c0-.4-.4.2-.4.4 0 .3.3.2.3-.1 0-.5-.1-.8-.7-.8s-.6 1.6-.1 1.8c1 .4.9-2.1.6-2.6-.8-1.2-1 .5-1 1 0 .7.7 1.8 1 .5 0-.1.6-2.3.2-2.4-1-.3-1.1.9-1.1 1.6 0 .4.3 2.3 1.1 1.3.4-.5.5-2.2.3-2.8-.3-.8-1.3.4-1.3.8 0 .5-.2 2.6.7 2.3.4-.1.6-1 .6-1.4 0-.6-.4-.6-.8-1-1-.6-.7 1.3-.5 1.9m7.9-2c.1-.8.2-1-.5-1.4-.8-.4-1.1.6-1.1 1.2 0 .3 0 1.1.4 1.2.7.1 1-1.3 1.2-1.8 0-.5 0-1.2-.8-1-.2 0 0 1.4 0 1.6 0 .7.3 1 .8 1.1.4.2.4-.1.4-.5 0-.5 0-.7-.5-1-.4-.2-.8-.4-1.2-.3-.3 0-.2.7-.2 1 0 .3.6.5.9.5.7-.1.7-1.5.8-2 0-.5-.2-.5-.5-.1s-.4 1-.4 1.4c0 .4.2.7.3.2 0-.6 0-1.1-.4-1.5-.6-.4-1 1.3-.4 1.4.5.2.8-1.5.3-1.8-.4-.3-.4 0-.4.5 0 .2-.1 1.2.1 1.3.4.2.6.2.8-.2.2-.3.5-1 .1-1.4-.7-.6-.9 1-.9 1.3 0 .3.3.6.7.7.2.2.5-1.2.5-1.4 0-1-1-.6-1.2.1 0 .5 0 1.1.5 1.3.6.1.5 0 .7-.6 0-.2.3-1 0-1.2-.2-.1-.6-.2-.8 0-.2.3-.2.8-.2 1.2 0 .2.6.4.8.2.5-.5 0-2-.4-.7 0 .3-.2 1 0 1.4.2.4.7.3.8-.1.1-.7-.1-1-.6-1.3-.2-.2-.7-.4-.7 0 0 .2-.1 1.2.1 1.3.5 0 .8 0 .8-.6 0-.3.1-1-.4-1-.4 0-.5 0-.6.4-.1.3 0 .6.3.7.4 0 .5-.8.6-1 .3-.8-.2-1.3-.6-.4-.3.6-.5 2.2.3 2.4.8.2.8-1 .8-1.5 0-.3-.5-.5-.7-.5-.5 0-.6 0-.7.5 0 .5-.2.7.4 1 .6.2.5-.4.5-.8s0-.5-.5-.7c-.3-.1-.2.5-.2.6m98.8 42.7c-.2 0-.7-1.3-1.4-3.7l-2.2-8v5.9l.1 2.6a53.4 53.4 0 010 2.8 1 1 0 01-.5.1c-.2 0-.4 0-.4-.3v-.5l.1-.7a65 65 0 00-.2-5.6v-2.3a36.7 36.7 0 01.1-3.3V71c0-.6.1-.9.4-.9.2 0 .4.3.6.8a145.2 145.2 0 013 10.9v-3l.1-3.1v-5.4c0-.3.3-.4.6-.4s.5.2.5.7l-.1.6a148.9 148.9 0 01-.1 6.7v5.5c0 .2 0 .3-.2.5-.1.2-.2.3-.4.3zm5.1 0c-.3 0-.6 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.4a18 18 0 01-.2-2.7v-2c0-.3 0-1 .2-1.8 0-.6.2-1.1.4-1.7 0-.2.2-.4.3-.5l.5-.2a3 3 0 012.2 1c.3.3.5.6.6 1l.4 1.5.1 1.6V79c0 3.5-.8 5.2-2.4 5.2zm0-.7l.6-.3.4-.7a16.6 16.6 0 00.4-5.7l-.2-2v-.4a2 2 0 00-.4-1.2c-.3-.3-.6-.5-1-.5-.5 0-.7.3-.9.7l-.1 1.5v1.9l-.1.8a34 34 0 00.4 4.6c.2.8.5 1.3.9 1.3zm5.4.1V83 81.7a77.3 77.3 0 01-.5-8.7c-.7 0-1.2-.1-1.3-.3-.2 0-.2-.2-.2-.3l.1-.2.4-.2 1.3.1 1.2.1H151.2c.3 0 .5.2.5.4s0 .3-.2.4l-.4.1a3 3 0 01-.4 0l-.4-.1v.2c0 1 0 2.8.3 5a62.8 62.8 0 010 5.6l-.4.1-.3-.2zm10.5.5c-.3 0-.5 0-.7-.2l-.2-.4-.1-1.9-.1-.3-1.8-.3-.3 1.7c0 .5-.2 1-.3 1.1l-.4.2-.4-.1a.4.4 0 01-.2-.4v-.1a80 80 0 002.3-11.6h.6c.1 0 .3 0 .4.2.1 0 .2.1.2.3 0 .9.1 2.3.4 4a35.4 35.4 0 01.5 5l.2 1.1.1 1.1c0 .3 0 .5-.2.6zm-1.2-3.5V80l-.4-4.1-.2-1.9-1 6.4 1.6.3zm-23.3 26.7c-.4 0-.8 0-1.1-.2-.2-.1-.3-.3-.3-.4l.1-.4.3-.1.5.1.5.2.6-.3.5-.8a4.8 4.8 0 000-3.2c-.1-.6-.3-1.2-.6-1.7l-.3-.6a120.9 120.9 0 01-1.1-2.5l-.3-1.7.2-1.2.7-1c.3-.3.7-.4 1.1-.4.3 0 .5 0 .7.2.2 0 .3.2.4.4l-.3.4c-.3 0-.5 0-.7-.2l-.6.3a2 2 0 00-.4 1.4 5.8 5.8 0 00.6 2.7l1.3 2.5a7 7 0 01.7 3c0 .9-.2 1.6-.6 2.3-.2.4-.5.7-.8.9-.3.2-.7.3-1 .3zm7.3-.1c-.4-.2-1-.2-1.6-.2l-.6.2-.4-.2a84.8 84.8 0 010-8.4v-.2-1.7c0-1.1.2-1.7.6-1.7l.3.1.2.3v.7l-.1.7a118.7 118.7 0 00-.1 5.1V105.1c0 .8.1 1.2.5 1.2h.8c.6 0 1 .2 1 .5l-.2.3-.4.2zm4.1 0c-.3 0-.6 0-.8-.3-.3-.2-.5-.4-.7-.8-.3-.7-.5-1.5-.6-2.4a18 18 0 01-.2-2.7v-2l.2-1.8c0-.6.2-1.1.4-1.7 0-.2.2-.4.3-.5l.5-.2a3 3 0 012.2 1l.7 1 .3 1.5.1 1.6v2.1c0 3.5-.7 5.2-2.4 5.2zm0-.7l.6-.3.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.9.7l-.1 1.5v2.7a34 34 0 00.3 4.6c.2.8.5 1.3.9 1.3zm5.4.1v-.7V104.7a77.3 77.3 0 01-.5-8.7c-.7 0-1.1-.1-1.3-.3-.2 0-.2-.2-.2-.3l.1-.2.4-.2 1.3.1 1.2.1H154c.3 0 .5.2.5.4l-.1.4-.5.1a3 3 0 01-.4 0l-.4-.1v.2c0 1 0 2.8.3 5a62.8 62.8 0 010 5.6l-.3.1-.4-.2zm6.8.3c-.4 0-.6-1-.6-3V102v-.3-.2h-1l-.5-.1v2a30.8 30.8 0 000 3v.5l-.5.2c-.2 0-.3-.3-.4-.7a9 9 0 01-.2-1.8v-1.4V101.2v-.4l.1-1.1a55.5 55.5 0 00-.1-4l.1-.5.4-.1c.4 0 .6.3.6 1v2.3l-.1 2.2 1 .1h.6v-.2a43.7 43.7 0 00-.2-5.1c0-.1 0-.3.2-.3l.4-.2.3.1h.2c0 1.8 0 4 .2 7l.1 4.5c0 .1 0 .3-.2.4l-.4.1z';

  var animalSloth1 = 'M41.7 87.8c-3.5.7-8 .8-11.4.8-3.3 0-6.2 1-9.4 1.2-1.3 0-2.8 1.7-4.3 2-1.6.4-2.5 2-3.8 2.8-2.4 1.4-4.3 3.7-6.2 5.6-2 2-1.6 6.2-1.6 9 0 2.9 1.5 6 3.6 8 5 5 12.6 4.8 19.2 4.8 3.6 0 7.2-.4 10.6-.4 1.6 0 3.2-.5 4.7-.8 1-.2 1.8-.7 2.8-.8 1-.2 1.5-1.5 2.7-1.6 1-.1 3.8-1.9 4.5-2.6.5-.7 1.8-.6 2.4-1.3.6-.7 1.4-1 2-1.8 2.4-2.5 2.5-6.3 2.5-9.6 0-1.6.2-3.8-.9-5-1.4-1.7-3-3-4.4-4.7-2.3-2.3-4.4-5.6-8.1-5.6-2 0-4-.8-6-.8h-7.2c-4.5 0-8.3 2.2-12.5 3.6M4.2 106.3c0 .7-.5 4.1 0 4.8.4.5.8 2.2.8 2.8 0 2.3 1.5 4.8 1.6 7.1.2 2.5 1.5 5 2 7.4.4 1.4 1.8 2.7 2.1 4.3a10 10 0 001.7 3c1.6 1.7 2.4 4 3.8 6 1.1 1.4 4 2.7 4.3 4.6.2 2.2 3.6 2 4.5 3.1 1.6 2 4.8 3 6.8 4.8 3.2 3 7.6 6 11.9 6.4 2.2.3 4.1 2 6.3 2.5 3.4.7 6.6 2.3 10 3.2 5.1 1.3 11 1.7 16.3 1.7 4 0 7.6-.8 11.6-.8 3.4 0 6.5.2 9.4-1.4 2.4-1.4 5.9-3.2 7.9-5.2.9-.8 2.2-2 3.3-2.3 1.8-.6 3.1-2.8 4.9-3 2-.2 3.7-1 5.5-2 1.2-.7 2.4-1.9 3.7-2.4 2.2-.8 5.3-4.3 6.2-6.4 1.3-2.8 3.5-5.2 5-8 .5-1.2 1.3-2.4 1.9-3.6.5-1.3 1.3-3 1.6-4.3 1.1-5 1.7-9.8 1.7-15 0-2.6-.4-5-.4-7.7 0-1.7-.2-5.5-1.3-6.8-1-1.4-.6-4.6-2.2-5.9-.8-.6-2.5-4.6-2.6-5.7-.3-2.1-2-4.8-2.7-7-.7-2-2-3.6-3.5-5.1-2.8-2.8-8.2-3.4-12-3.4-2.1 0-3.8.8-3.8 3.3 0 2.4 1.8 2.8 3.9 3.3 1.6.3 3.3 3.4 3.4 4.8.1 1.5.9 2.4 1.6 3.7.3.6 1 2 1.5 2.5.9.7 1.7 5 1.8 6 .1 2.3 1.2 4.5 1.2 6.8v8.4c0 1.3-1.2 2.4-1.2 3.7 0 1-1 1.3-1.2 2.2-.6 2.4-3.8 2.7-5.7 2.7-2.3 0-5 1.4-7.2 2-1 .3-2.5.2-3.6.4-.9.2-3-.4-3.8.1-1.2 1-4.8.3-6.4.3-2 0-1.4-.4-1.4-2.2 0-1.3.3-2.2.5-3.4.3-1.8 1.1-3.6 1.1-5.4v-4.9c0-1.3.4-2.5.4-3.9 0-.8-.7-1.8-.8-2.6-.2-3-1.3-6.5-1.6-9.4-.1-.7-1.1-2-1.6-2.6-.7-.8-.6-2.4-1-3.3-.6-1-.8-2-1.3-2.9-.5-1-1.4-1.2-2-2.2-.6-1.5-1.8-4.5-3.7-4.5-1.3 0-5.6-1.3-6.4 0-.6 1-1.4 1.7-1.9 2.8-.2.5-.3 3.3.2 3.7.7.6 1.1 2 2 2.4a4 4 0 011.6 1.7c.3.5 0 1.5.3 2 2.9 3.5 4 9.4 4 13.9v7.4c0 2.2-1.2 4.7-1.2 6.7 0 1.2-2.5 4.6-3.7 4.7-1 0-1.9 1.2-2.8.7-1.1-.5-2.3-1.1-3.5-1.1-2.2 0-4.4-.8-6.7-.8-1 0-6 0-6.5-.6-1-1.1-.9-5.3-.9-6.8 0-2.4.5-4.5.5-7M51 92v-8m15.6 13.7v-8V87l-.4 2.5c-.6 3.6.4 7.3.4 10.8 0 3.4 1.8 6.6 1.8 10 0 1.3.8 3.7 1.6 4.6 1 1.2 1 4.7 1 6.1m35 0c-1-4.4-2.5-9.1-2.5-13.7 0-1.7-.3-3.7-.3-5.6 0-1.5.6-3 0-4.4-.9-2.4 1-4.9 1-7.1 0-2.3 1-5.3 1.8-7.2m-11 3v3M2 68c2.5.5 4.4 2.1 6.7 2.6s4.6 1 7 1c1 0 2 .5 2.9.9 1.4.6 3.7.8 5.3 1 1.9.3 4 .3 5.8.7 1.7.5 4.7.4 6.3.4h6.3c4.4 0 8.6.4 13.1.4 1.4 0 5.2-.3 6.1-1.3 1-1.2 4.2-1 5.7-1 3.8 0 8.1-1 12-.3 1.8.4 3.5 1.1 5.5 1.1 2.4 0 4.6.4 7 .4 2 0 4.3-.4 6.6-.4 1.2 0 5 1.2 5.7 0m16-.5c3.4 0 7 .9 10 2.3l2 .5h1.1c.3.3-1.1 1-.5 1 2 .4 4.3 0 6.3 0 6.7 0 13.3-.6 20.1-.6m1 12.8c-1.5-.2-3.4-.6-4.9-.7-.6 0-2.8.6-3.2.2-1.1-1.2-4.5-1.2-6.1-1.2-2 0-13-.9-13.8.3m-13-3.5c-5-.2-9.5 0-14.4 0-1.1 0-2 .7-3.2.7-1.1 0-2 .2-3 .4-2 .4-3.4.8-5.4.8m-16 0c-3-.4-5.8-.8-8.7-.8-2 0-4.1-.8-6.1-.8-4.6 0-9.2-1.2-13.7-1.2-4.3 0-8.4-1.6-12.8-1.6-2 0-4.8-1.2-6.9-1.6L26 79c-.6 0-3.2-.2-3.5-.5-.8-1-4.7-.7-6-1.3-1-.4-2.6 0-3.2-1-.4-.6-1.3-1.9-2.2-2-1.2 0-1.5-.7-2.6.7-.6.7-1.8 1.8-2.8 1.8-2.2 0-3.2 2.8-4.5-.2-.3-.7 2.4-2.3 3-2.7.8-.6-.7-1.7-1.1-2-1.5-1.5-3.3-2.4-1-4.5 1.4-1.2 3.4.6 4.5 1.4 1.2 1 4.6 1.1 6.2 1.1M77 74.4c-.4-.2-1-.6-1.4-.6l-.7-.2c-.4-.3-1-.6-1.5-.6-1.3 0 0 2 0 2.5.2.3 1 1.4 0 1-.3-.2-.8-.6-1.2-.6-1.1 0-2.4 1-1.4 2 .5.5 1 .6 1.6.7.2 0 1 .3.7.3l-.7-.5c-1-.5-2.5-.4-2.4 1 0 .2 1.5 1 1.8 1l.8.3c.3.1.8 0 1.1.2 1 .4 1.7 1.1 2.2 2.1m34.4-5c-1.2 0-2.3-.3-3-1.3-.9-1.2.5-1.2 1.3-1.2.4 0 1-.1 1.3.1l-1-.7c-.5-.2-2-1.5-1-2 .3 0 1.5-.5 1.7-.3.2.4 1.1.3 1.2.8.1.3.2.5.4.6.3.2-.1-.2-.2-.4-.2-.5-.6-.8-.7-1.3-.1-.5-.3-.7.3-1 .4-.4 1-.3 1.5-.3s1.7 1 1.9 1.6M99 74a5 5 0 011.1-2.5c.3-.3.6-.3 1-.5.4-.1.5.3.7.6.3.3.3 1.4.3 1.8v-.6c0-.3.4-.6.5-.9.3-.5 1.4-1 1.7-.4.4.7.4 1.3.4 2 0 .4.2-.6.4-.9.2-.3.4-.3.8-.3 1.2 0 .8.5 1.1 1.4M56 75c.1-.6.4-1.2.8-1.6.5-.5 1.1.2 1.2.5l.2.4c.2.2.3-.7.4-.8.3-.3.3-1 1-1 .5 0 1 .2 1.2.8v.6l.7-1.2A2 2 0 0163 72c.4 0 .7.6.9.8M152 86c-3.6 0-6.8-1.6-10.2-2.5C140 83 138 82 136 82m-23-1c-1.3 0-3.5.3-4.6-.6-.2-.2-1.3-.3-1.6-.3L105 80m-2 3c-2 0-3.7-.7-5.7-.7-1 0-2.4.3-3.3-.3m5-4h-5m-26 4c-1.6 0-3.4.2-5-.2-1.1-.3-2-1.2-3-1.6-.5-.2-1-1.2-1.6-1.2H57m-30-2l2.3.1 1 .2c.7 0 1.4.4 2 .4 1.3 0 3 .4 4.2.8l.7.3h1.4c1.3 0 2.4.3 3.7.5l2.2.2c.6 0 1 .5 1.5.5m4-1h3m-43-7H7m136 8h2.6l1.8.1c.5.3 2 .9 2.6.9M34.6 102c-.8-.5-3.7-1.6-4.2 0-.2 1-.7 2.5-1.2 3.2-.3.4-.3 1.2 0 1.6.4.7 1 .5 1.4 1 .6.4 2.9 0 3.6 0 1.4 0 2.4-.8 3.6-.9 1.4 0 1.2-2 1.2-3 0-1.3-1.6-1.4-2.3-2-.8-.7-2.3-.3-3.3-.9m-3.9 1c-1.3 1.8-2.3 4-2.3 6.4l-.2 3c0 .9 1 1.8 1.1 2.6.5 1.7 1.6 4.3 3.8 4.3.8 0 1.6.6 2.5.7.9 0 2.9-1.2 3.7-1.6 1-.4 2.4.2 3.4-.4 1.1-.6 1.5-.8 1.5-2.3 0-2.3.1-4.8-.5-7-.2-.6-.6-2-1-2.5l-1-1c-.4-.4-.6-.2-1.2-.5-.7-.3-1.7-.6-2.3-1-1-.8-1.8-.7-3-.7m-29 .8c3.2-3 7.4-3.7 11.7-3.7 1.7 0 5-.5 6.1 1 .4.5 1 .7 1.2 1.4 0 .3.2 1.1.4 1.3.5.4.6 1.9.6 2.5 0 .8-1 1-1 1.7 0 .2-.1 1-.3 1.1l-1.4 2c-.6.5-1.2 1.3-1.6 2-.4.8-1.3 1-1.8 1.4-.6.6-1.5.7-2.1 1.2-.3.2-.7.2-1 .5-.4.3-1.3 1-1.8 1.1-1 .4-1.9.6-3 .6-.8 0-1.6.3-2.6 0m7.3-12.2c-1 .4-1.3.6-1.5 1.9 0 .7 1.2.3 1.5 0 .6-.3 0-1.1-.5-1-.6.1-.2 1.2.5.9.4-.2 1.1-1.6.4-1.6-.6 0-1 .6-1 1.4 0 .6.9-1 .1-1-.7 0 0 1.8.4 1.3.3-.4.2-1.5-.3-1.5s-.9.6-.4 1.3c.2.4.8-1.3 0-1.7-.6-.3-1 .2-.7 1.1.3.7 1.1.7 1.3-.1 0-.6-1.2-2-1.4-1.6-.2.4 0 1.8.5 1.1s.2-1.7.2-.9c0 .5.5 1.5.8.7.3-.7-.7-.8-.6-.1.1 1 .7-.2.7-.7 0-.6-.8.3-.8.8 0 .8.4.9 1 .8.5 0-.1-1.1-.2-.8-.2.8 1 1 .4.3-.3-.4-1-.3-1 .3 0 2.8 1.9-.5.8-.5-.6 0-.5 1.4.2 1.2.6-.2.3-2.2.1-2-.2.6-.2 1.8.6 1.7.6 0-.3-1.3-.8-1.3l-.5.2c0-.1 0-1-.3-.6-.4.4.4 1.6.7 1m38-12.3c-5.2 0-14.4 4.6-9.5 10.7.6.8 2.2 1.6 3 2 1.6.9 3 1.3 4.7 1.3h2.2c1 0 1.2 0 2-.6.6-.5 1.6-.2 2.2-.7 1-1 1.7-1.6 2.5-2.8m-10.8-4c-1.4 3.4 2 .4.2-.5-1.2-.7-1.7 2.6.2 2 1-.4-.1-1.2-.4-1.4-.7-.6-.6 1-.3 1.4 1.3 1.3 1.4-2.2 0-2-.6 0-.8 1.8-.1 2 .6.1 1.3.1 1.1-.6-.1-.7-.4-1.7-1.3-1.4-.5 0-.3 1.7.3 1.7 1.5.1 0-3.5-1.4-1.5s1.8 3.1 1.7.3zm0 0c0-.6-1.2-2-1.3-1 0 .4.4 2.8 1 1.4.1-.4.6-2-.1-2.2-.7-.2-1 0-1.2.5-.7 2.2 2.6 2.1.6.2-1.1-1-1 1.1-1 1.7 0 1 .3 1.5 1.5 1.4.8 0-1.3-2.8-1.3-.8 0 2.5 2.5-1 .5-1-.6 0-1.3 1.7-.9 1.4.5-.3.6-1.3.4-1-.6.6 0 2-.3.5 0-.3-.3.1-.4.1-.1 0-1-.5-.6-.5M28 50.4c-1.1 0-2.1-.2-3-.6-.5-.3-.7-.7-.7-1 0-.4 0-.7.2-1 .2-.2.5-.4.9-.4l1.4.4 1.2.4c.6 0 1.2-.3 1.6-.8.5-.5 1-1.2 1.2-2a13 13 0 00.2-8.7c-.4-1.6-1-3-1.8-4.5l-.7-1.5-2-3.8-1-3a15 15 0 01-.8-4.5c0-1.1.2-2.2.6-3.3.4-1 1-1.8 1.8-2.5.8-.8 1.8-1.2 3-1.2a3 3 0 011.7.5c.5.3.9.7 1.1 1.3l-.8 1c-.8 0-1.4-.2-1.9-.5-.5 0-1 .3-1.5.9a5.1 5.1 0 00-1.2 3.5 15.4 15.4 0 001.8 7.3l3.4 6.7a18.5 18.5 0 011.8 8.2c0 2-.5 4-1.5 6-.6.9-1.3 1.6-2.1 2.2a5 5 0 01-2.9.9zm19.4-.4c-1.1-.4-2.5-.6-4.2-.5a3 3 0 01-1.7.4c-.4 0-.7-.1-1-.5-.2-.3-.4-.7-.4-1l.3-10.8.3-10.7v-.3l-.3-4.5c0-3 .5-4.6 1.6-4.6.4 0 .6.1.9.4.2.2.3.5.3.8v1.8c-.2.8-.2 1.4-.2 1.8a315.9 315.9 0 00.1 11.6c-.2.5-.2 1.2-.2 2v.6l-.1 3.8V44c0 2.2.4 3.3 1.5 3.3a345.6 345.6 0 002 0c1.7 0 2.6.4 2.6 1.4 0 .3-.1.6-.4.8l-1 .4zm11.1.1c-.8 0-1.6-.2-2.3-.8a5.7 5.7 0 01-1.7-2c-1-2-1.6-4.2-1.8-6.5a48 48 0 01-.4-7.2v-.9-4.4l.3-5c.2-1.5.6-3 1.1-4.4.3-.7.5-1.1.9-1.5.3-.3.7-.5 1.2-.5a8 8 0 016 2.6 11 11 0 011.7 3 17 17 0 011 3.7c.2 1.3.3 2.8.3 4.3v5.8C65 45.5 63 50 58.7 50zm-.2-2c.6 0 1.1-.2 1.6-.7.5-.5.8-1 1-1.9.7-1.6 1-3.4 1.2-5.3a44.2 44.2 0 00-.2-9.9 78 78 0 01-.3-5.5V24c0-1.3-.5-2.3-1.2-3.2a3.4 3.4 0 00-2.8-1.3c-1 0-1.8.6-2.1 1.8-.3 1-.5 2.3-.5 3.9v5l-.1 2.2.1 5.2a42 42 0 001 7c.6 2.3 1.3 3.5 2.3 3.5zm14.6.3v-1.9l-.1-1.8v-1.6a723.8 723.8 0 01-1.5-23.3c-1.8-.1-3-.3-3.5-.6-.4-.3-.6-.6-.6-.9 0-.2.2-.5.5-.7a2 2 0 011-.3c1 0 2 0 3.3.2l3.3.2h.8c1 0 1.5.4 1.5 1.2 0 .3-.2.7-.5 1-.3.1-.7.3-1.1.3-.3 0-.7 0-1.3-.2l-1-.2v.5c0 2.9.3 7.4.8 13.6.6 5.9.8 10.4.9 13.7 0 .4-.2.7-.6 1-.3.3-.7.4-1 .4l-1-.6zm18 .7c-1 0-1.6-2.6-1.7-8v-2.6l.1-2.3v-.6-.9-.2c-.2-.1-.2-.2-.2-.3h-.9l-1.5-.1-1.6-.2v5.5a82 82 0 00.4 7.8c0 .5-.2 1-.4 1.3-.3.4-.6.5-1 .5-.6 0-1-.6-1.3-1.7-.3-1.3-.4-2.8-.4-4.8v-3.9l.1-3.4v-1.5-4.1a148.1 148.1 0 00-.2-10.8c0-.4 0-.7.3-1 .3-.3.6-.4 1-.4 1 0 1.5 1 1.5 2.8v6l-.1 6 2.6.2h1.8v-.6c0-1.5 0-3.8-.3-6.8l-.3-6.8c0-.4.1-.7.4-1 .3-.2.6-.3 1-.3l1 .2.4.2c0 4.6.2 10.6.5 18.2l.5 12.2c0 .4-.2.8-.5 1-.4.3-.7.4-1.2.4zm9.8-7.2c-.3 0-.6-.4-1-1.2-.2-.8-.4-2-.4-3.7a99.3 99.3 0 01.2-7.2l-.1-7.8-.2-8c0-.4.2-.9.7-1.2a2 2 0 011.3-.6c.4 0 .6.1.9.3.2.3.3.5.3.9 0 2.8-.1 6.6-.4 11.5a198.5 198.5 0 00-.6 15.1c0 .8-.1 1.3-.2 1.5-.1.3-.3.4-.5.4zm-.9 8.2c-.3 0-.7-.1-1-.5-.4-.3-.6-.8-.6-1.3 0-.6.2-1 .6-1.5.4-.4.9-.7 1.4-.7.6 0 1 .3 1.4.7.4.4.6 1 .6 1.6 0 1.2-.8 1.7-2.4 1.7z';

  var animalSloth2a = 'M78 89c-6.4 1.6-10.3 8.7-14 13.5-1.6 2-2.4 4.9-4 7-1.6 2-2.8 5.5-4.1 8-2.6 5-3.5 11.7-6.8 16.2-.8 1.2-1.5 3.7-2 5.1l-1.5 4c-.4 1.8-1 3.7-1.7 5.3-1.2 2.6-1.7 5.9-2.3 8.6-1.5 7-3.6 14.4-3.6 21.6v12.3c0 3 0 6.3.7 9 .8 2.9.2 6 .8 8.8.2 1.2 0 2.5.3 3.7.3 1.3 1.4 2.7 1.5 4 0 1.6-.4 3.6.3 5l.8 2.8c.4 2.1 1.8 4 2.5 6.1m-.4-46.7v7.6c0 1.5.7 2.7.7 4 .2 2.3 1.1 4.2 1.1 6.5 0 2 .7 4.3.8 6.2.2 3 0 6.1 0 9.1 0 2-.3 4-.4 5.8 0 1.7-.1 5.1-1.2 6.5A32.9 32.9 0 0142 233c-1 1.1-2.9 3-4.3 3.3-1.7.3-2.6 1.4-4.5 1.4-1.3 0-3.7 0-5.1.4-1.6.3-1 4.3-1 5.6 0 1-.3 2.2 1 2.4 1.2.2 2.7.4 3.8 1 1.4.6 3.9.7 5.2.8h5.6c3.7 0 7.2-1.8 10.8-2.6 3-.7 6-4.2 7.8-6.4 1.5-1.8 3-3.5 4.4-5.4 1.4-1.7 0-4.2 1.1-6.2 1.1-1.9.6-4.5 1.9-6.5a14 14 0 001.6-6c0-2.6-.3-4.9-.3-7.4 0-2.2 1.3-3.7 1.4-5.7.2-3.3.4-6.7.4-10 0-1.4-.2-3 0-4.3.3-1.5 1-3 1.1-4.6.2-3 0-5.7 0-8.7 0-1.7.2-5.1-.5-6.7-1-2-.2-5.6-.2-7.8 0-1.6-.4-3.3-.7-4.9-.3-1.6-1.2-3.5-1.2-5 0-1.9-.6-4.4-1-6.3-.3-1.2-.3-3.9-1.5-4.5M50.7 249c0 2.8 1.4 11.7-1.3 13.8-1.3 1-2 4.1-2.3 5.6-.4 1.4-1.1 2.8-1.1 4.4 0 3.1.6 8.2 4.5 8.2 3.5 0 7-.4 10.5-.4 3.6 0 7.4-.7 10.2 1.8 3.2 2.8 5.8 1.9 5.8-2.5 0-1.9 0-2.8-1.4-4.1a10 10 0 00-3.6-2.1c-4.7-.3-4 4.1-5.8 6.9m10.2-5.6c2.8 0 4 0 5.8 1.4 1.2.9 1.3 2.8 2.4 3.5.7.4.5 1.4-.6 1-.6-.2-1.6-.7-2.3-.7-1.9 0-3.7-.3-5.7-.3m11.2-1.9c1.4-.3 2.9.2 2.9-1.5 0-.7-.3-1.6-1-2.1-1-1-2.5-1.3-3.4-2.2-1-.9-3.2-1-4-2-1-1.4-3.5-1-4.7-2-1.7-1.4-2.5-1.2-2.5-3.9 0-1.8.6-3.6.7-5.3.2-2.1 1.5-4.2 1.5-6.4 0-1 .3-1.7.3-2.7 0-1-.2-1.5 1-1 1 .7 3.6.6 4.8.6 2.2 0 4-.2 6-.7 1.8-.4 3.4-1 5.3-1a11 11 0 004.8-1.4c1.6-.9 3.8-.6 5.4-1.6l5.1-3.1c3.9-2.1 6.5-5.3 9.3-8.5.6-.6 1.7-1.1 1.8-2 0-1.5.7-3 1-4.5.4-1.7.3-3.2.9-5 .6-2 .6-4 .6-6s-.6-3.7-.7-5.6c-.1-1.3-1.3-3.2-2-4.5-.5-1-.6-2.1-1.1-3-.4-.6-1.2-1.5-1.3-2.3-.1-1.6-2.4-4.4-3.4-5.7-1.1-1.4-1.5-3.4-2.9-4.7-2.4-2.5-3.8-6.4-6.5-8.6-.8-.6-.9-2.2-1.3-3-.4-1-1-1.6-1.5-2.5-.9-1.7-2.2-3.2-3.2-4.9-.8-1.5-.8-3-1.5-4.5-.5-1.1-1-4-2-4.8-1-.9-.5-3.8-.5-5.2 0-2-1-3.5-1-5.4v-11.6c0-2 .8-3.7 1-5.7.4-2.7 1.8-5.4 2.9-7.8.5-1.4 1.5-2.8 1.9-4.2.2-.8 1.2-1.5 1.6-2.2.4-.8.5-1.9 1.2-2.5 1.7-1.7-2.1-1.4-3.4-1.4-1.8 0-3.9-1-5.8-1s-3.7-.3-5.5-.4a17 17 0 01-5.2-1c-.2-.2-1.6-.4-2-.5-.7-.2-1.3-.6-1.9-1.1-1-1-2.6-2.4-3-3.8-.2-1.1-1.3-3.4-2-4.3-.7-.8-.8-3.3-.8-4.5 0-1.6-.4-3.6.8-4.8 1-1.1 2.5-1.4 3.6-2.6.7-.7 1.6-1.2 2.4-2 .6-.5 2.2-1.2 2.6-1.9 1.2-2.1 3.3-1.3 5-2 1.3-.6 3.6-.7 5-.7h5.2c1.6 0 2.9 1 4.5 1 1.8 0 3.3.8 4.9.8 3 0 7 1.8 8 5.1.6 2.2 2.1 3.4 2.1 5.8 0 1.7.4 3.5.4 5.4 0 3.3-4.5 5.8-6.7 7.6-1.5 1.1-3.3 1.8-5 2.5-1.2.6-3 2.2-4.3 2.4-.9.2-1.4.8-2.3.8h-2.7c-1 0-4.6 1-5 0m-15-8.4c3-.5 7-2.1 8.7-4.6.8-1.2 2.7-2 3.5-3.4.7-1.1 1.8-3.5.8-4.6-.9-1-2.4-2.3-3.8-2.3h-5.7c-1.2 0-4.2 1-5 2-.9 1-3.7 1.6-3.7 3.5 0 1.7-.4 3.7-.4 5.5m11.6-5.6c-1.7 0-2.3-.2-3.5.8-.6.5 1.3.4 1.5.4 1 0 1-.2 1-1.2-.1-.6-1.3.1-.4.5 1.2.5 2.2.7 3.5.7.9 0-.4-.4-.8-.4-1.1 0-.7-.3-.4-1.2.2-.7 0-2.8-.1-1.9-.2 1.9-2.2.4-2.6 2.1 0 .4.6-.3.9-.5.6-.6-1 0-1.2.3-.4.9.1 1.2.8 1.2 0 0-.2.3-.1.6.1.5.4-.5.5-.6.8-.4 0-.4.2-.4 1 0 .7-.7.7-1.5m14.5-2c-2.5 0-3.9 2-5 4-1.3 2.2-.6 4.5-1.3 6.8-.3.8-1 1.9-.7 2.9.4 1 1.8 2.6 3 2.6 1.3 0 5.9.7 6.9 0 1.7-1.4 3.6-2.2 4.7-4 .5-1 .2-2.5.2-3.5s-.7-2-.7-3c0-1.6-2.8-4.1-4.1-4.9-1.7-1-4.6-2.3-6-.3m-.6 1.4c.8 3.2 2.1 3.6 5.3 3.6 1 0 1.5-1 1.9-1.8.6-1.4.3-1.7-.8-2.7-1.4-1.1-3.3-1-5-1.4-1.8-.5-2.8 1.8-3.9 2.3m22.3 9.9c-3.1-1.8-7.8-3.9-8-7.8-.2-1.6-.5-4 0-5.5.6-2.1 3.7-2 5.5-2 2.4 0 3.7-.2 5.3 1.4 1 1 1.9 3 1.9 4.5v5.8c0 .9.1 2.1-.5 2.8-.5.6-1.6 1-1.8 1.5M110 97c3.5 5.6 2.4.3 1 .8-2.2.7 1.3 2.2 2 2.2m-19 47c4.7 3.4 10 7 16 7h11c3.2 0 7-.1 9.8-1.6 2.3-1.3 4.8-2.4 7.3-3.4 1.1-.6 3.2-1.5 4-2.5.4-.5 1.2-.7 1.7-1.1 1-.8 1.7-2 2.8-2.7 1.5-.8 2.2-2.6 3.7-3.4 1.7-1 2.2-3.5 3.5-4.8 3.4-3.3 5-6.1 5-10.7v-4.4c0-.9.5-3.7 0-4.5-1-1-1-2.9-2-4-.7-.9-1.1-1.8-1.7-2.8-1.4-2.5-3.9-3.7-6.3-4.9-1.9-.9-6.8-2.2-8.6-.5-.8.8-1.8 1-2.6 1.8-1 1-1.8 2.2-2.1 3.6-.2.7-.8 1.4-.8 2.2 0 1.5-.4-.8-.4-.8a8 8 0 01-1.4-3.2c-.4-1.5-.4-2.9-.4-4.4 0-2 1-1.6 2.2-2.5.6-.5 3.5-.5 4.3 0 1 .5 1.9 1.6 2.4 2.7m-7.2-6.8c-1.6-1.1-3-1.9-4.6-2.7-1.8-1-3-1.3-2.5-3.3.3-1.5.6-2.5 1.8-3.6 1.3-1.3 2.4-1 4.2-1 2.3 0 3.4 7 3.4 9l.4 2.2c.2.6.8-1.1 1.3-1.7 1-1.2.9-3.4.9-5s.7-3.6.7-5.3c0-1.2.5-4-.2-4.8-1-1-1.5-2.5-3-2.9-1.6-.5-2.8 0-4.4 0-1.3 0-1-.1-1 .7 0 .7.3 1.8.7 2.3.2.2.4 2.1.5 2.4 0 1 .3 1.7.3 2.7 0 1.3.8 3.6 1.4 4.8.7 1.2 2 3.4 2 4.8m6-10.9c3.3.7 5.4 2.7 8.2 4.4 1 .6 1.8 1.6 2.9 2.2 1 .6 3 1.8 3.7 3 1.3 2.2 4 4.2 5.7 6.3l2.8 3.4c.7.8.8 2.8 1.5 3.4 1 .8 1 3.9 1 5 0 2 1 3.6 1 5.5.1 3.2 1.1 6.4 1.1 9.6 0 2.9 0 6-.7 8.6l-3.7 11.7c-.3 1.2-1.7 2.5-2.3 3.7a52.3 52.3 0 01-10.1 11c-2.5 2-5.4 3.2-7.8 5.1a20.5 20.5 0 01-8.3 3.8c-2.5.3-5 2.5-7.7 2.5-3 0-5.9 1.2-8.7 1.9-1.2.2-2.7.3-4 .3-2.3 0-4.4.6-6.7.8-3 .1-6 1.8-9 1.8m-76 70c-3.4 0-9.5.5-11.6-3.5a21 21 0 01-2.4-10.2c0-3.3.8-.6 2.5-.4 1.5.2 3.7 1.2 5 1.8 1.4.6 3.8 1.1 5.1 1.2 1 0 1.6.1 2.4.6.8.5-1-.2-1.4-.5-1.6-1.3-3.2-.6-4.1-2.7-.3-.6 0-6 0-6 1.3 0 4 3 5 4 .6.8 1.5 1.5 2.3 2.1.4.3 1.2 1.4 1.6 1.4.7 0 1.7 0 2.2.6.4.4.9-2.6 1-2.9.6-1.4 0-4.1 0-5.7 0-1.7.2-.3.6.6l1.4 2.8c.8 1.7 2 3.6 2.4 5.3M89.7 251c0 2.9-.3 5.7-.4 8.5v3.1c0 1.1-.9 1.6.4 2.1 2.1.7 3.7 2.7 6 2.9h6.1c2 0 3.3-1.7 5-2.2 2-.6 3.6-1.5 5.7-1.5a8 8 0 015.2 1.5c1.4.8 1.9 4 2.3 5.4.4 1.4-4.1.6-4.8 0a7.6 7.6 0 00-5.4-1.8c-1.8 0-1-.2-1-1.6 0-1.4.9-1.6 0-.5-.3.4 0 2.7-.6 2.9-1 .2-2.2 0-3.2 0-1.6 0-1 .2-1.8 1.2-.5.5-1 2-1.4 2.6l-1.3 2.4c-.8 1.6.8 1 1.7 1.2.8.1 5.5 1.7 5.5.1 0-1.7 0-5.9-1.8-6.8m4.2 5.4c1 0 5.9.6 5.9-.9 0-1.1-.3-4-1.8-4-1.5-.1-2.7-.8-4.4-.8-2 0-3-.6-4.8.4M62.5 61.5c-.6.3-1.1.2-1.6-.3l-3-5.7c-1-2-2.1-4.7-3.4-7.8l-.5-1.3a45.5 45.5 0 00-3.2-6.3c-1.6-2.5-2.8-3.5-3.6-3-.5.4-.4 1.1.4 2.3.2.3.7 1 1.7 2l-.1.4c-.2.7-.4 1.1-.6 1.3-.8.5-1.7-.2-2.9-2l-.2-.4a8 8 0 01-1-2V37a3 3 0 011.4-1.7 4 4 0 011.7-.6c.6 0 1.1 0 1.7.2.8.4 1.7 1.2 2.6 2.4l1 1.5c1.5 2.4 2.8 5.3 3.7 8.6a47.2 47.2 0 006.8 13.4l-.8.6-.1.2zm2.9 4.5c-.5.3-.9.3-1.3.2-.5-.1-.9-.4-1.1-.8-.3-.3-.3-.8-.2-1.3.1-.6.4-1 .8-1.2.3-.3.7-.3 1.3-.1.5.1.9.3 1.1.7.6 1 .4 1.9-.6 2.5z';

  var animalWhale = 'M32.2 42a26 26 0 00-17 6.1c-2.1 1.7-2.8 3.8-4.6 5.7-2.5 2.7-3.8 6-6 8.8C1.2 66.9.9 72.8.9 78.1c0 1.7 2.8 4.5 3.7 6 1.1 2.1 4.2 3.4 6.3 4 3 1 6 1.2 9 2.2l7.6 2.7c2.2.7 5 1.1 7.4 1.1 1.4 0 2.5-.4 3.7-.7.6-.2 1-.7 1.6-.8 1-.2.1-.6-.2-.2-.3.4-2.9 1-3.5 1-1 0-2.9.6-3.7 1.1a14 14 0 01-6.9 1.2h-8.4c-1.7 0-6 0-6.9-1.6m-.3-4.3c-2.4.6-6.7 3.3-5.2 6.3a17.3 17.3 0 0012.2 7.4c1.7.1 3.9 1 5.5 1.8 3 1.3 6 1 9.4 1 6 0 13.3 1 19.2-.6l8.9-2.6c1.6-.4 4.5-.9 5.6-2.1 1-1.3 4.4-1.4 5.8-2.2m-.7-3.5l4.9 4.5c.9.9 3.3 2.1 4.5 2.2 4.2.2 8.3 1.1 12.7 1.1 3 0 5.9-.7 8.8-1.1 1.2-.2 2.3-.3 3.2-1.1 2-1.8 4.6-1.9 4.6-4.8 0-2-4.5-1-5.8-1.7-2-.9-4.8-.7-6.6-2.3-1.4-1.3-3.4-2-4.9-3.4-1.4-1.2-4-2-5.8-2m11 3.1c5.1-1.8 8.2-5.7 11.7-9.4 2-2 4.4-3.7 6.3-5.8 1.3-1.5 2.2-3.3 3.5-4.7 2.3-2.4 4-6.8 5.4-9.8.2-.4.4-2 .6-1.6.6 1 1.6 1.9 2.7 2.3 2.2.6 4.8.6 7 .4 3.8-.2 9.7-1.6 12.6-4.2 3-2.7 6.6-3.6 9-7 .7-1.1 2.4-2.3 2.3-3.7 0-.5-3.6.4-4.3.4-2.7 0-6.4.5-8.5-1.2-2.3-1.8-6.3-1.5-9.1-1.5-.7 0-4.1 1.7-3.5.9 1.2-1.4.7-3 0-4.4-.7-1.4-1.6-2.3-1.6-4 0-1.2-.5-3.5 0-4.6 1-2.3 3-6.8 0-8.2-2.4-1-7-.2-8.7 1.4-2.5 2.3-5.2 4.5-7 7.5-1.5 3-3.1 6-3.1 9.4v5.1c0 1 .5 4.4 1.1 4.7m6-5.5c-1.8.4-6.4 1.6-7.5 3-.8 1-3.1 2-4.3 2.1-1.7.2-3.4 1.4-5.1 1.6-2.1.3-3.5 1.3-5.8 1.1-3.5-.4-8.3-.9-11.5-2.6l-4-2c-1.3-.7-2-2-3.4-2.7-3.2-1.6-6.6-1.3-9.8-2.7-1.6-.7-3.6-.2-5.3-1-1-.7-3.3-1.5-4.5-1.5-1.3 0-2.7-.7-4-.7-1.9 0-3.5-.4-5.4-.4H45c-2.3 0-2.7.6-4.5 1.5m-6.3 5.1c-.3 2.2 0 3.6 2.4 3.6 1.6 0 3.4.2 4.9-.6.9-.5 2.9-1.5 2-2.8-1.2-1.4-3-1-4.6-1m-1.5 1.2v-9.2c0-1.5-.6-2.4-1.1-3.8-1.8-5-5.3-5-9.9-5m11.8 16V33.7c0-1.3-.8-5-.8-3.7m1.5 15.3c0-7 2-13.3 9-15.7m-6.6 0c1.2-1.6 2.3-2.5 4-3.5m-13.4 1.2c-.5-.4-5.2-2.7-4.3-3.2m2.3 11.4c-1.8-.3-3.5-.9-5.2-1.4-1.3-.3-2.7 0-4-.4-1.2-.3-5.5.5-6-.6m32.9.4h6.2m4.7 47c-2 0-3.5.3-3.5 2.6 0 1.4 1.5 2.5 2.7 2.5 3.2 0 2.3-5.3 0-6.3-1.6-.8-1.5 2-.5 2.6 1.6 1 3 1 2.9-1 0-1-2.8-2.4-3.1-1-.2.9.5 3.6 1.4 1.8.7-1.3-.2-3.1-1.7-3.1-2 0-1.8 1-1.7 2.7 0 1.6 3.1 1.8 3.1-.2 0-1.2-2-2.3-3-1.3-1.5 1.5 1.5 2.7 2.4 2.7.8 0 .6-.6.6-1.2 0-1.3-.8-1.2-2-1.2-2.2 0-1.9.5-1.9 2.6 0 1.8 3.2 3 3.2 1.5 0-1.7 0-2.4-2-2.5-2.6 0 2.6.6 3.7.4 1.3-.3-.6-2.7-1.7-2.7-1.5 0-.9 1.5.5 1.5 1.9 0 1-2-.2-2.4-2-.7-1.8 1.3-1.5 3 .2 1 2.7 1.6 2.7.2 0-.8.2-1.3-.6-1.8-.3-.2-2-.4-2.1 0-.6 2.2 2 2.7 3.5 2.6.6 0 .4-1 .4-1.4 0-1.3-.8-1.6-2.1-1.7-1.5-.2-1.5 3.6-1 4.7.8 1.6 3.6-.7 2-1.8-1.1-.8-3-1-4.5-1-1.2 0-.5.9.2 1.1 1 .3 5.5.6 4.4-1.5-.8-1.6-4.6-1.2-2.2-.5 3.6 1.1.8-2 0-.7m-2.3-5c1.8 0 7.6-.6 8.3 2 .4 1.4 1.5 3.2 1.5 4.6m26.7-63c-.3 0-.7-1.2-1.5-3.6l-2.2-8v5.9a53.4 53.4 0 010 5.4 1 1 0 01-.3.1c-.3 0-.4 0-.4-.3v-.5-.7a65 65 0 00-.2-5.6V8.6a36.7 36.7 0 01.2-3.3V5c0-.6 0-.9.4-.9l.5.8c.4.9 1 2.5 1.6 4.7a145.2 145.2 0 011.5 6.2V4.4c.1-.3.3-.4.6-.4.4 0 .5.2.5.7v.6a148.9 148.9 0 01-.2 6.7v5.5c0 .2 0 .3-.2.5 0 .2-.2.3-.3.3zm5 .1c-.2 0-.5 0-.8-.3-.2-.2-.5-.4-.6-.8-.4-.7-.6-1.5-.7-2.3a18 18 0 01-.1-2.8v-2l.1-1.8c0-.6.2-1.1.4-1.7l.4-.5.4-.2a3 3 0 012.3 1l.6 1 .3 1.5.2 1.6V13c0 3.5-.8 5.2-2.4 5.2zm0-.7l.6-.3c.2-.1.3-.4.4-.7a16.6 16.6 0 00.4-5.7l-.1-2v-.4a2 2 0 00-.5-1.2c-.3-.3-.6-.5-1-.5s-.7.3-.8.7L94.8 9v2.7a34 34 0 00.4 4.6c.2.8.4 1.3.8 1.3zm4.9.5c-.2-.6-.3-1.5-.3-2.6v-1.6a32.3 32.3 0 000-2v-.1l.2-1.6v-.8a19.6 19.6 0 00-.1-2.6l.1-.4.3-.2h.8c.4 0 .7 0 1 .2l.5.7c.2.5.4 1 .4 1.7a27.6 27.6 0 01-.2 2.1l-.2.4-.3.4c-.1.2-.4.4-.8.5l-.6.3V16l.1 1.7c0 .2 0 .3-.2.4l-.4.1-.3-.2zm.8-6.4c.7 0 1-1 1-3v-.8l-.1-.4-.3-.2a.9.9 0 00-.4-.1h-.2v1a88 88 0 000 3.1v.4zm4.7 6.5l-.5-.1a.6.6 0 01-.2-.4v-.9-.3-2.3a92.8 92.8 0 010-6v-.8c0-.9.2-1.3.7-1.3l1.4.3c.5.1.7.3.7.5l-.1.4-.4.2-1.3-.4a12.5 12.5 0 010 2.1l-.1 1.3v.3h.7c.6 0 .9.1.9.4 0 .2 0 .3-.2.4l-.4.1h-1a19.3 19.3 0 010 3 36.6 36.6 0 000 2.6h1.4c.4 0 .7.1.7.4 0 .2-.1.3-.3.4a1 1 0 01-.5.1h-1.5z';

  var sloth = 'M78 89c-6.4 1.6-10.3 8.7-14 13.5-1.6 2-2.4 4.9-4 7-1.6 2-2.8 5.5-4.1 8-2.6 5-3.5 11.7-6.8 16.2-.8 1.2-1.5 3.7-2 5.1l-1.5 4c-.4 1.8-1 3.7-1.7 5.3-1.2 2.6-1.7 5.9-2.3 8.6-1.5 7-3.6 14.4-3.6 21.6v12.3c0 3 0 6.3.7 9 .8 2.9.2 6 .8 8.8.2 1.2 0 2.5.3 3.7.3 1.3 1.4 2.7 1.5 4 0 1.6-.4 3.6.3 5l.8 2.8c.4 2.1 1.8 4 2.5 6.1m-.4-46.7v7.6c0 1.5.7 2.7.7 4 .2 2.3 1.1 4.2 1.1 6.5 0 2 .7 4.3.8 6.2.2 3 0 6.1 0 9.1 0 2-.3 4-.4 5.8 0 1.7-.1 5.1-1.2 6.5A32.9 32.9 0 0142 233c-1 1.1-2.9 3-4.3 3.3-1.7.3-2.6 1.4-4.5 1.4-1.3 0-3.7 0-5.1.4-1.6.3-1 4.3-1 5.6 0 1-.3 2.2 1 2.4 1.2.2 2.7.4 3.8 1 1.4.6 3.9.7 5.2.8h5.6c3.7 0 7.2-1.8 10.8-2.6 3-.7 6-4.2 7.8-6.4 1.5-1.8 3-3.5 4.4-5.4 1.4-1.7 0-4.2 1.1-6.2 1.1-1.9.6-4.5 1.9-6.5a14 14 0 001.6-6c0-2.6-.3-4.9-.3-7.4 0-2.2 1.3-3.7 1.4-5.7.2-3.3.4-6.7.4-10 0-1.4-.2-3 0-4.3.3-1.5 1-3 1.1-4.6.2-3 0-5.7 0-8.7 0-1.7.2-5.1-.5-6.7-1-2-.2-5.6-.2-7.8 0-1.6-.4-3.3-.7-4.9-.3-1.6-1.2-3.5-1.2-5 0-1.9-.6-4.4-1-6.3-.3-1.2-.3-3.9-1.5-4.5M50.7 249c0 2.8 1.4 11.7-1.3 13.8-1.3 1-2 4.1-2.3 5.6-.4 1.4-1.1 2.8-1.1 4.4 0 3.1.6 8.2 4.5 8.2 3.5 0 7-.4 10.5-.4 3.6 0 7.4-.7 10.2 1.8 3.2 2.8 5.8 1.9 5.8-2.5 0-1.9 0-2.8-1.4-4.1a10 10 0 00-3.6-2.1c-4.7-.3-4 4.1-5.8 6.9m10.2-5.6c2.8 0 4 0 5.8 1.4 1.2.9 1.3 2.8 2.4 3.5.7.4.5 1.4-.6 1-.6-.2-1.6-.7-2.3-.7-1.9 0-3.7-.3-5.7-.3m11.2-1.9c1.4-.3 2.9.2 2.9-1.5 0-.7-.3-1.6-1-2.1-1-1-2.5-1.3-3.4-2.2-1-.9-3.2-1-4-2-1-1.4-3.5-1-4.7-2-1.7-1.4-2.5-1.2-2.5-3.9 0-1.8.6-3.6.7-5.3.2-2.1 1.5-4.2 1.5-6.4 0-1 .3-1.7.3-2.7 0-1-.2-1.5 1-1 1 .7 3.6.6 4.8.6 2.2 0 4-.2 6-.7 1.8-.4 3.4-1 5.3-1a11 11 0 004.8-1.4c1.6-.9 3.8-.6 5.4-1.6l5.1-3.1c3.9-2.1 6.5-5.3 9.3-8.5.6-.6 1.7-1.1 1.8-2 0-1.5.7-3 1-4.5.4-1.7.3-3.2.9-5 .6-2 .6-4 .6-6s-.6-3.7-.7-5.6c-.1-1.3-1.3-3.2-2-4.5-.5-1-.6-2.1-1.1-3-.4-.6-1.2-1.5-1.3-2.3-.1-1.6-2.4-4.4-3.4-5.7-1.1-1.4-1.5-3.4-2.9-4.7-2.4-2.5-3.8-6.4-6.5-8.6-.8-.6-.9-2.2-1.3-3-.4-1-1-1.6-1.5-2.5-.9-1.7-2.2-3.2-3.2-4.9-.8-1.5-.8-3-1.5-4.5-.5-1.1-1-4-2-4.8-1-.9-.5-3.8-.5-5.2 0-2-1-3.5-1-5.4v-11.6c0-2 .8-3.7 1-5.7.4-2.7 1.8-5.4 2.9-7.8.5-1.4 1.5-2.8 1.9-4.2.2-.8 1.2-1.5 1.6-2.2.4-.8.5-1.9 1.2-2.5 1.7-1.7-2.1-1.4-3.4-1.4-1.8 0-3.9-1-5.8-1s-3.7-.3-5.5-.4a17 17 0 01-5.2-1c-.2-.2-1.6-.4-2-.5-.7-.2-1.3-.6-1.9-1.1-1-1-2.6-2.4-3-3.8-.2-1.1-1.3-3.4-2-4.3-.7-.8-.8-3.3-.8-4.5 0-1.6-.4-3.6.8-4.8 1-1.1 2.5-1.4 3.6-2.6.7-.7 1.6-1.2 2.4-2 .6-.5 2.2-1.2 2.6-1.9 1.2-2.1 3.3-1.3 5-2 1.3-.6 3.6-.7 5-.7h5.2c1.6 0 2.9 1 4.5 1 1.8 0 3.3.8 4.9.8 3 0 7 1.8 8 5.1.6 2.2 2.1 3.4 2.1 5.8 0 1.7.4 3.5.4 5.4 0 3.3-4.5 5.8-6.7 7.6-1.5 1.1-3.3 1.8-5 2.5-1.2.6-3 2.2-4.3 2.4-.9.2-1.4.8-2.3.8h-2.7c-1 0-4.6 1-5 0m-15-8.4c3-.5 7-2.1 8.7-4.6.8-1.2 2.7-2 3.5-3.4.7-1.1 1.8-3.5.8-4.6-.9-1-2.4-2.3-3.8-2.3h-5.7c-1.2 0-4.2 1-5 2-.9 1-3.7 1.6-3.7 3.5 0 1.7-.4 3.7-.4 5.5m11.6-5.6c-1.7 0-2.3-.2-3.5.8-.6.5 1.3.4 1.5.4 1 0 1-.2 1-1.2-.1-.6-1.3.1-.4.5 1.2.5 2.2.7 3.5.7.9 0-.4-.4-.8-.4-1.1 0-.7-.3-.4-1.2.2-.7 0-2.8-.1-1.9-.2 1.9-2.2.4-2.6 2.1 0 .4.6-.3.9-.5.6-.6-1 0-1.2.3-.4.9.1 1.2.8 1.2 0 0-.2.3-.1.6.1.5.4-.5.5-.6.8-.4 0-.4.2-.4 1 0 .7-.7.7-1.5m14.5-2c-2.5 0-3.9 2-5 4-1.3 2.2-.6 4.5-1.3 6.8-.3.8-1 1.9-.7 2.9.4 1 1.8 2.6 3 2.6 1.3 0 5.9.7 6.9 0 1.7-1.4 3.6-2.2 4.7-4 .5-1 .2-2.5.2-3.5s-.7-2-.7-3c0-1.6-2.8-4.1-4.1-4.9-1.7-1-4.6-2.3-6-.3m-.6 1.4c.8 3.2 2.1 3.6 5.3 3.6 1 0 1.5-1 1.9-1.8.6-1.4.3-1.7-.8-2.7-1.4-1.1-3.3-1-5-1.4-1.8-.5-2.8 1.8-3.9 2.3m22.3 9.9c-3.1-1.8-7.8-3.9-8-7.8-.2-1.6-.5-4 0-5.5.6-2.1 3.7-2 5.5-2 2.4 0 3.7-.2 5.3 1.4 1 1 1.9 3 1.9 4.5v5.8c0 .9.1 2.1-.5 2.8-.5.6-1.6 1-1.8 1.5M110 97c3.5 5.6 2.4.3 1 .8-2.2.7 1.3 2.2 2 2.2m-19 47c4.7 3.4 10 7 16 7h11c3.2 0 7-.1 9.8-1.6 2.3-1.3 4.8-2.4 7.3-3.4 1.1-.6 3.2-1.5 4-2.5.4-.5 1.2-.7 1.7-1.1 1-.8 1.7-2 2.8-2.7 1.5-.8 2.2-2.6 3.7-3.4 1.7-1 2.2-3.5 3.5-4.8 3.4-3.3 5-6.1 5-10.7v-4.4c0-.9.5-3.7 0-4.5-1-1-1-2.9-2-4-.7-.9-1.1-1.8-1.7-2.8-1.4-2.5-3.9-3.7-6.3-4.9-1.9-.9-6.8-2.2-8.6-.5-.8.8-1.8 1-2.6 1.8-1 1-1.8 2.2-2.1 3.6-.2.7-.8 1.4-.8 2.2 0 1.5-.4-.8-.4-.8a8 8 0 01-1.4-3.2c-.4-1.5-.4-2.9-.4-4.4 0-2 1-1.6 2.2-2.5.6-.5 3.5-.5 4.3 0 1 .5 1.9 1.6 2.4 2.7m-7.2-6.8c-1.6-1.1-3-1.9-4.6-2.7-1.8-1-3-1.3-2.5-3.3.3-1.5.6-2.5 1.8-3.6 1.3-1.3 2.4-1 4.2-1 2.3 0 3.4 7 3.4 9l.4 2.2c.2.6.8-1.1 1.3-1.7 1-1.2.9-3.4.9-5s.7-3.6.7-5.3c0-1.2.5-4-.2-4.8-1-1-1.5-2.5-3-2.9-1.6-.5-2.8 0-4.4 0-1.3 0-1-.1-1 .7 0 .7.3 1.8.7 2.3.2.2.4 2.1.5 2.4 0 1 .3 1.7.3 2.7 0 1.3.8 3.6 1.4 4.8.7 1.2 2 3.4 2 4.8m6-10.9c3.3.7 5.4 2.7 8.2 4.4 1 .6 1.8 1.6 2.9 2.2 1 .6 3 1.8 3.7 3 1.3 2.2 4 4.2 5.7 6.3l2.8 3.4c.7.8.8 2.8 1.5 3.4 1 .8 1 3.9 1 5 0 2 1 3.6 1 5.5.1 3.2 1.1 6.4 1.1 9.6 0 2.9 0 6-.7 8.6l-3.7 11.7c-.3 1.2-1.7 2.5-2.3 3.7a52.3 52.3 0 01-10.1 11c-2.5 2-5.4 3.2-7.8 5.1a20.5 20.5 0 01-8.3 3.8c-2.5.3-5 2.5-7.7 2.5-3 0-5.9 1.2-8.7 1.9-1.2.2-2.7.3-4 .3-2.3 0-4.4.6-6.7.8-3 .1-6 1.8-9 1.8m-76 70c-3.4 0-9.5.5-11.6-3.5a21 21 0 01-2.4-10.2c0-3.3.8-.6 2.5-.4 1.5.2 3.7 1.2 5 1.8 1.4.6 3.8 1.1 5.1 1.2 1 0 1.6.1 2.4.6.8.5-1-.2-1.4-.5-1.6-1.3-3.2-.6-4.1-2.7-.3-.6 0-6 0-6 1.3 0 4 3 5 4 .6.8 1.5 1.5 2.3 2.1.4.3 1.2 1.4 1.6 1.4.7 0 1.7 0 2.2.6.4.4.9-2.6 1-2.9.6-1.4 0-4.1 0-5.7 0-1.7.2-.3.6.6l1.4 2.8c.8 1.7 2 3.6 2.4 5.3M89.7 251c0 2.9-.3 5.7-.4 8.5v3.1c0 1.1-.9 1.6.4 2.1 2.1.7 3.7 2.7 6 2.9h6.1c2 0 3.3-1.7 5-2.2 2-.6 3.6-1.5 5.7-1.5a8 8 0 015.2 1.5c1.4.8 1.9 4 2.3 5.4.4 1.4-4.1.6-4.8 0a7.6 7.6 0 00-5.4-1.8c-1.8 0-1-.2-1-1.6 0-1.4.9-1.6 0-.5-.3.4 0 2.7-.6 2.9-1 .2-2.2 0-3.2 0-1.6 0-1 .2-1.8 1.2-.5.5-1 2-1.4 2.6l-1.3 2.4c-.8 1.6.8 1 1.7 1.2.8.1 5.5 1.7 5.5.1 0-1.7 0-5.9-1.8-6.8m4.2 5.4c1 0 5.9.6 5.9-.9 0-1.1-.3-4-1.8-4-1.5-.1-2.7-.8-4.4-.8-2 0-3-.6-4.8.4M31.6 88.4c-1 .6-2 1-2.9 1-.5 0-1 0-1.1-.4-.2-.3-.3-.6-.3-1 0-.2.2-.5.5-.7a4 4 0 011.4-.4l1.2-.3c.6-.4.9-.9 1-1.6.2-.7.1-1.5-.1-2.4a13 13 0 00-4.5-7.4 23 23 0 00-3.8-2.8l-1.5-1a321 321 0 01-3.6-2.1l-2.5-2a15 15 0 01-3-3.4c-.6-1-1-2-1.3-3-.2-1.1-.1-2.2.2-3.2.2-1.1.9-2 1.9-2.6a3 3 0 011.7-.4c.6 0 1.2 0 1.6.4l-.1 1.3c-.7.4-1.3.6-1.9.6-.4.3-.7.9-.8 1.5a5.1 5.1 0 00.8 3.7 15.4 15.4 0 005.5 5.2l6.4 3.8a18.5 18.5 0 015.9 6c1.1 1.8 1.7 3.8 1.9 5.9 0 1-.2 2.1-.6 3a5 5 0 01-2 2.3zm16.3-10.6c-1.2.3-2.5.9-4 1.8a3 3 0 01-1 1.2c-.4.2-.8.3-1.2.1-.4-.1-.7-.3-.9-.7-1.4-2.2-3.3-5.3-5.5-9.2-2.3-4.2-4.2-7.2-5.4-9.2l-.2-.3a52.3 52.3 0 01-2.7-3.7c-1.6-2.5-2-4.1-1-4.7.3-.2.6-.2 1-.1l.7.4.8 1.7.9 1.6a315.3 315.3 0 006.2 9.7c.2.5.4 1.1 1 1.8l.2.5 2 3.3 2 3.3c1.1 1.9 2.1 2.5 3 2l.3-.2.5-.4.9-.6c1.5-1 2.4-1 3-.2v1l-.6.9zm9.4-5.8c-.7.4-1.5.6-2.4.5-.9 0-1.7-.3-2.6-.8a19 19 0 01-4.8-4.5 48 48 0 01-4.2-6l-.5-.7c0-.1-.1-.2-.2-.1l-.4-.8-1.8-2.8-2.3-4.4c-.7-1.4-1.1-2.8-1.4-4.4-.2-.6-.2-1.2 0-1.6 0-.5.3-.9.7-1.1a8 8 0 016.5-1c1 .3 2 .9 3 1.6 1 .8 1.9 1.6 2.7 2.6 1 1 1.8 2.2 2.6 3.5l.2.3 1.4 2.3 1.6 2.3c4.9 7.7 5.5 12.8 1.9 15zm-1.2-1.6c.4-.3.8-.8 1-1.4 0-.7 0-1.4-.2-2.2-.3-1.8-1-3.4-1.8-5.1a44.1 44.1 0 00-5.4-8.3 78 78 0 01-3.2-4.5L46 48c-.7-1-1.6-1.6-2.7-2a3.4 3.4 0 00-3 .4c-1 .5-1.2 1.5-.9 2.7A20.5 20.5 0 0042 54l.7 1 1.1 2 1.1 1.9 2.9 4.3c1.4 2 3 3.7 4.6 5.4 1.7 1.7 3 2.3 3.8 1.8zm12.4-7.5l-1-1.6-1-1.5-.8-1.4a724.7 724.7 0 01-13.6-19 8.7 8.7 0 01-3.4 1.4c-.4 0-.7-.1-.9-.4-.1-.2-.1-.5 0-.8.2-.4.5-.7.8-.9l2.8-1.6 3-1.5.2-.2.4-.2c.8-.5 1.4-.5 1.8.2.2.3.3.6.1 1-.1.4-.4.7-.7 1-.3 0-.6.2-1.1.5l-1 .3.1.2.1.3c1.5 2.4 4.2 6 8 11 3.6 4.7 6.2 8.4 8 11.2.1.3.2.7 0 1.1-.1.4-.3.7-.7 1l-1-.1zm15.7-9c-1 .6-2.8-1.4-5.6-5.8l-1.4-2.4-1.2-1.9-.3-.5-.4-.8-.3-.1-.2-.1c-.2 0-.4.2-.7.5l-1.4.6-1.5.6 3 4.7a82.1 82.1 0 004.4 6.5c.3.4.4.8.4 1.3 0 .4-.3.7-.6 1-.5.3-1.2 0-2-.9-1-.8-1.9-2.1-3-3.8l-2-3.3c-.5-1-1-2-1.7-3l-.4-.6-.4-.6-.6-.8-.1-.2-1.4-2.5a148 148 0 00-6-9c-.2-.3-.3-.7-.2-1 0-.4.2-.7.5-1 1-.5 1.9 0 2.9 1.7l3 5 3.2 5.2c.5-.1 1.3-.5 2.3-1.2l1.5-1-.2-.5-3.9-5.6c-1.7-2.2-3-4.1-4-5.6-.1-.3-.2-.6 0-1 0-.3.3-.6.6-.8a3 3 0 011-.3h.4c2.4 3.8 5.8 8.8 10.1 15l6.9 10c.2.5.2.9 0 1.3 0 .3-.3.7-.7.9zm11.9-16c-.3.2-.8 0-1.4-.5a12 12 0 01-2.4-2.9 99.1 99.1 0 01-3.7-6.2l-4.2-6.6-4.3-6.6c-.3-.4-.4-.9-.2-1.4.2-.6.4-1 .9-1.2.2-.2.5-.3.8-.2.4 0 .6.3.8.6 1.5 2.3 3.4 5.7 5.7 10a199.3 199.3 0 007.6 13c.4.7.6 1.2.6 1.5 0 .2 0 .4-.2.5zm3.6 7.4c-.3.2-.7.3-1.2.2-.4-.1-.8-.4-1-.9-.4-.4-.5-1-.4-1.5.1-.6.4-1 .8-1.3.5-.3 1-.4 1.6-.2.5.1 1 .5 1.3 1 .6 1 .3 1.9-1 2.7z';

  function clicked() {
    var slothArrays = MorphSVGPlugin.stringToRawPath(sloth);
    state.glassBottle.path = slothArrays;
    renderAnimals();
    select('#sloth-reveal').classed('show', true);
    select('#sloth-reveal-delay').classed('show', true);
    selectAll('.sloth-button').classed('clicked-true clicked-false', false);
    select(this).classed("clicked-".concat(this.dataset.answer), true);
  }

  function slothReveal() {
    selectAll('.sloth-button').on('mousedown', clicked);
  }

  var dataset00Grid = 'M11 66.5 L787 66.5 M35.5 14 L35.5 381 M98.5 14 L98.5 381 M166.5 14 L166.5 381 M239.5 14 L239.5 381 M295.5 14 L295.5 381 M369.5 14 L369.5 381 M450.5 14 L450.5 381 M522.5 14 L522.5 381 M592.5 14 L592.5 381 M634.5 14 L634.5 381 M723.5 14 L723.5 381';

  var dataset01Id = 'M13 17.6c-.1 0-.3.1-.3.3l-.2.3.2.5c0 .2 0 .3.3.4.1.2.3.2.5.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5l-.1-.5a.6.6 0 00-.5-.2c-.2 0-.4 0-.5.2zm1 7l.2.4.1.5-.1.5V28.3c0 .2 0 .4-.2.5l-.5.2c-.2 0-.3 0-.5-.2a.6.6 0 01-.1-.5l-.2-.3v-.4c0-.3 0-.5.2-.5l-.2-.7.1-.6v-.3a4 4 0 010-1v-.3-.5-.7-.4l-.1-.3V22l-.1-.6v-.6l.2-.4h.4c.5 0 .8.2.8.8l.2.3v.3l-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3.5l-.2.2a1 1 0 01-.6 0c-.1.2-.2.2-.4.3a1 1 0 01-.4.2h-.5l-.4-.1a.8.8 0 01-.3-.2 1 1 0 01-.6-.1l-.2-.3-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4l-.1-.5v-.4l-.2-.4V25v-.7-.4-.3l.2-.3v-.1-.2l.2-.2.1-.5.4-.3v-.4l.4-.3.5-.2c.2-.3.5-.4.8-.4h.8l.6.1h.5c.2 0 .2.1.3.2v-.2-.5-.4-.1-.2l-.1-.2V19v-.3-.4a1 1 0 01.1-1c.1-.2.3-.3.5-.3s.4.1.5.3a.6.6 0 01.2.5l.2.6-.1.3v1.3l.1.4-.1.3v.5l.1.3v.7l-.1.6.1.5v.5l-.1.3.1.6v.3l.1.6-.1.6.1.6v.5l-.2.2v.3l.1.5-.1.4-.5.2-.4-.1a.7.7 0 01-.2-.5v-.2l-.1-.1zm-2-.7h.6c0-.1 0-.2.2-.2l.4-.1h.2V27l.2-.2.2-.2v-.3l.1-.5v-.5-.7-.7-.6l-.2-.7.1-.4h-.3a.8.8 0 01-.3-.1H19h-.7-.1l-.4.3-.3.1v.3l-.2.3-.2.1c0 .2 0 .3-.2.3v1.1l-.1.9.1.3.1.4v.3c.2.1.3.3.3.5.1 0 .2 0 .3.2.3 0 .5.1.7.3zM17.5 93v-.7a10 10 0 001.4-.2 40.7 40.7 0 000-5v-2l-1.5 1-.4-.3a193.2 193.2 0 002.4-1.7h.4a115 115 0 01.1 8l.5.2h.6l.2.7H17.5zm3.9 25.2l.4.8H17v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zM17 144.6v-.5h.6a11 11 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H18l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.4.5.4.5.6 1 .6 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm4.8 23l.1.5-.8.1a2956.7 2956.7 0 010 2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.6 5.6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a180.8 180.8 0 00-.2 4.8h.8zm-4-.2l2.4.1a84.4 84.4 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm2.9 21.3v.5l-1.2.1H18l-.5 3 .7-.2c.6 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3c0-.3.2-.4.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zm0 25.8l.1.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a26 26 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.4 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm1.2 28.6l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm4 23.5c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm-2.5 34.4l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.3 17.3 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM15.5 327v-.7a10.7 10.7 0 001.4-.2 40.7 40.7 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H15.5zm4.2-3.9c0-1.7.2-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .6 0 1 .3.2.2.5.5.6.8l.5 1.1.2 1.3.1 1.3c0 .6 0 1.2-.3 1.9-.1.6-.4 1.2-.8 1.7s-.8.7-1.3.7c-1.8 0-2.7-1.4-2.7-4.3zm2.5-4a1.7 1.7 0 00-1 .5c0 .1 0 .3-.2.5a4.2 4.2 0 00-.3 1.7 85.4 85.4 0 010 2.4l.2 1c.1.4.3.7.5.9.3.2.5.3.9.3s.8-.3 1.1-1c.4-.6.5-1.3.5-2 0-2.8-.6-4.2-1.7-4.2zm-1.9 28c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset02Quality = 'M46.6 25.2l-.1-.5v-.4-.5-.6-.2l.3-.6.2-.3h.2c0-.2.1-.3.3-.4 0-.1 0-.3.2-.4l.4-.2c.1-.3.3-.5.7-.6h.5c0-.2.2-.2.4-.3h.7c.4 0 .8 0 1.2.2.1-.2.3-.3.5-.3l.4.1.2.4V22l.1.4v.5l-.3.3c.2.1.3.3.3.6 0 .1 0 .3-.2.4v.5l-.1.2.2.5-.1.4.1.3v.8c.1 0 .2 0 .3.2l.2.5v.1c0 .2 0 .4-.2.5l-.5.1v.8l.1.6V31.7c-.1.2-.3.4-.5.4H52c-.2 0-.4 0-.5-.2l-.1-.6V31l-.2-.3v-.5l.1-.4a2.5 2.5 0 010-1H51h-.2l-.5.2c-.2 0-.3 0-.5-.2H49a1 1 0 01-.5-.5c-.5 0-.8-.3-1-.8l-.4-.1a.7.7 0 01-.3-.5 1 1 0 01-.2-.6v-.2a.8.8 0 010-.9zm3.3-3.6s-.1.2-.3.2a1 1 0 01-.6.1l-.1.3-.3.2a2 2 0 01-.6.7c0 .2 0 .5-.3.7v.9l.1.3.1.4v.8l.4.3.2.4c.3 0 .6.2.8.5h1.5l.5-.1V27l.1-.1-.2-.6.1-.3v-.3-.4l-.1-.4.1-.6v-.3-.4-.4c0-.2 0-.5.2-.8V22v-.5h-.7-.4a.7.7 0 01-.5 0zm7.3 7.1a1 1 0 01-.3 0h-.4l-.4-.2a.8.8 0 01-.3-.3.8.8 0 01-.3-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2l-.1-.6v-.3-.4a.6.6 0 01-.2-.7l-.1-.4.1-.4a.6.6 0 01-.2-.5v-.3a.8.8 0 010-.5V23l-.1-.4v-.3-.4c0-.3 0-.4.2-.6V21l.1-.5.5-.2.5.2.2.5-.1.6.2.5c0 .1 0 .3-.2.4l.1.4v1.5l.2.4V25.7l.2.2v.5l.1.2v.3l.2.1s.1.1 0 .2h.5l.1.2.6-.2h.3l.3-.2h.6l-.1-.5c0-.2 0-.3.2-.3l-.1-.6c0-.3 0-.6.2-.7a1 1 0 01-.2-.5l.1-.4v-.3-.4l.2-.3-.2-.7v-.5l-.1-.5c0-.2 0-.4.2-.5l.4-.2c.2 0 .4.1.5.3.2.1.3.4.2.7l.2.2v.4l-.1.5c.2.2.3.4.3.7 0 .1 0 .2-.2.3l.2.4c0 .1 0 .3-.2.4l.1.4c0 .1 0 .3-.2.5l.2.4-.3.5c.2.1.2.2.2.4l-.1.7.1.4v.6c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.3-.5v-.1a1 1 0 01-.5.1h-.2l-.4.2-.3-.1-.2.2h-.3-.1zm5.2-6l-.1-.3c0-.2 0-.4.2-.5 0-.1 0-.3.2-.4l.4-.4h.3l.5-.4.6-.1h.2l.5-.2.3.1.5-.1c.3 0 .5 0 .7.2.2.1.4.3.4.5.2 0 .3.1.4.3l.2.5c.2.2.3.3.3.5l.1.6-.1.6.2.5V25l.1.3v.2a2.2 2.2 0 010 .4l-.1.4v.5l-.1.5v.2c0 .3 0 .4-.3.6 0 .1 0 .3-.2.3l-.4.2c-.1 0-.2 0-.3-.2l-.7.2H66l-.7.1H64h-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3-.4-.4-.4c0-.3 0-.5.4-.8 0-.2.2-.4.4-.5l.6-.2c0-.2.2-.3.4-.3l.7-.1.3-.1H66l.6-.3h.2V23a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.3-.3l-.5.1h-.3a1 1 0 01-.4 0l-.5.1c-.1.2-.3.3-.5.3l-.4.5-.5.2c-.2 0-.4-.1-.5-.3zm.9 3.7l.2.3v.3l.1.1.1.2H65c.2 0 .4 0 .5.2l.4-.2h.5c.1-.3.3-.4.5-.4l.2-.3v-.3l-.1-.3.1-.5a.8.8 0 01-.2-.5l.1-.4-.3.1-.2-.1-.4.1h-.3l-.5.1H65c-.2.1-.3.2-.4.1l-.3.3-.4.1-.2.3h-.3v.3l-.1.5zm8.3.6l.2.5-.1.5-.2.3c0 .2 0 .4-.2.5l-.5.2-.3-.1a.6.6 0 01-.3-.3V28v-.6-.4-.6-.5-.6a1 1 0 010-.4l.1-.6-.1-.6.1-.5a.6.6 0 01-.2-.5v-.1a.7.7 0 01-.1-.5v-.4-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3V19v-.4-.3a.6.6 0 01-.1-.4c0-.2 0-.4.2-.5l.5-.2.4.1.2.4c.2 0 .2.3.2.5v.2l.2.5c0 .1 0 .3-.2.4.1 0 .2 0 .2.2v.3c0 .2 0 .4-.2.5l.2.4-.1.4V22l.2.5-.1.3V27zm2.2-9.4c-.2 0-.3.1-.4.3v.3l.1.5c0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v3.3c0 .2 0 .4-.2.5l-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5V28l-.1-.4.1-.5v-.7-.6-.3a4 4 0 010-1v-.3-.5-.7l-.1-.4v-.3-.3l-.2-.6c0-.2 0-.4.2-.6v-.4h.5c.5 0 .7.2.7.8l.2.3.1.3-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3l.2-.1h.2c.2 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1c-.2-.1-.2-.2-.2-.3a.9.9 0 01-.5-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4L78 26v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4l.1-.4a1 1 0 010-.8v-.2a.7.7 0 010-.4v-.3a1 1 0 01-.4 0h-.4-.3c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.5l.1-.4.5-.2h2v-.5l.1-.3-.1-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.5c.1 0 .2 0 .3.2l.5.1.1.4c0 .1 0 .3-.2.5l-.4.2-.3-.1-.4.1-.4-.1a1 1 0 01-.3 0h-.3l.1.4c0 .1 0 .3-.2.4l.2.5c0 .2 0 .3-.2.5l.2.4-.1.4.1.6V26l.2.4c.2.2.3.3.3.5.2.1.3.3.3.6v.1h.2l.4.1h.4zm6.7-1.5l-.3.3c0 .5-.1.7-.3.8l-.3.6a1 1 0 01-.4.4v.2l-.1.3-.2.3c0 .4-.1.7-.6 1.1 0 .3 0 .5-.2.6a1 1 0 01-.6.3c0 .2 0 .3-.3.4a1 1 0 01-.5.3l-.6.3c-.3.2-.5.2-.6.1-.2 0-.4 0-.6-.2a.7.7 0 01-.2-.5l.1-.4.4-.1h.1c.3-.3.6-.4.7-.4h.2s0-.2.2-.3l.5-.3v-.3l.4-.3v-.1c0-.2 0-.4.2-.6l.4-.4a.6.6 0 01-.4-.5l-.3-.3-.1-.4v-.3a.7.7 0 01-.3-.2L84 26v-.3l-.3-.3-.1-.3c-.2-.1-.2-.3-.2-.5v-.3A1.3 1.3 0 0183 23a.8.8 0 01-.3-.3 1 1 0 010-1c-.3 0-.4-.3-.4-.5 0-.3 0-.5.3-.7h.3l.5.1.3.4.2.4a1.5 1.5 0 010 .7c.4.4.6.7.6 1v.3l.2.3.1.4.2.4v.3c.2 0 .3.1.3.3l.1.4c.2 0 .3.2.3.3v.4c.2 0 .2.2.2.4l.1-.4.2-.2v-.3-.2l.2-.2c0-.2 0-.4.2-.5v-.2-.3l.2-.2-.1-.4v-.4l.3-.3-.1-.6c0-.3 0-.6.2-1v-.3-.3a.8.8 0 01.8-.8c.2 0 .3 0 .4.2.2 0 .2.3.2.5l.1.5c0 .4 0 .7-.2 1v.5c0 .2 0 .5-.3.7v.3l.1.3-.1.5c0 .1 0 .4-.4.9l.1.3v.3zM66.5 197v-.7a10.7 10.7 0 001.4-.2 40.7 40.7 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H66.5zm3.9 77.2l.4.8H66v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zm0-182l.4.8H66v-.3-.4l.7-1a44.9 44.9 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 11.9 11.9 0 001.6 0 27 27 0 011.7 0zm-.6 205.4l.1.5-.8.1a2956.7 2956.7 0 010 2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.6 5.6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9l1 .2a180.8 180.8 0 00-.2 4.8h.8zm-4-.2l2.4.1a84.4 84.4 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm4-155.8l.1.5-.8.1a2956.7 2956.7 0 010 2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.6 5.6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9l1 .2a180.8 180.8 0 00-.2 4.8h.8zm-4-.2l2.4.1a84.4 84.4 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm3.8-30.9l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a26 26 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm1.2 210.6l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm3-80.5c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm2.4-72.2c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm-2.5 60.4l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.3 17.3 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM68.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset03FAcidity = 'M130.5 197l-1-.2 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm2.1-1.5l.6.3.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1 1.1l.1-.5h.5a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.2-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.2v-.6h.3c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.3 1-.3.4-.6.6-1 .6.4.2.8.5 1 1 .3.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.7-.2-2.5-.5zm-3 70l.2.4c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.3 6c0 .6.1 1.1.4 1.5.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm4.7 1c.2 0 .4 0 .6.2l.2.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.6l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.5-.6.6 0 1.2.3 1.6.7.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3 5.2 5.2 0 01-.7 2l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.6.1-1 .4-.2.3-.3.6-.3 1 0 .7.1 1.3.4 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM130.5 93l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm2.1-1.6l.6.3.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.4.7l.4.8h-4.8v-.3-.4l.8-1a45 45 0 012-2.1l.8-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.5-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 11.8 11.8 0 001.6 0 27 27 0 011.6 0zM130.5 301l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm2.1-1.6l.6.3.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1 1.1l.1-.5h.5a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.2-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.2v-.6h.3c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.3 1-.3.4-.6.6-1 .6.4.2.8.5 1 1 .3.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.7-.2-2.5-.5zm-4.1-155.5l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm2.1-1.6l.6.3.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm6.5-.9c0 .9-.2 1.5-.6 2-.5.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.3-.3-.6-.5-1-.6zM124.5 119v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H124.5zm4.3 0v-.7a10.7 10.7 0 001.3-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 114.6 114.6 0 01.1 8l.5.2h.7l.2.7h-3.7zm4.3-1.5c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.4.7l.4.8H134v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zm-8 206.4c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm3.5 6.7c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7 75.8 75.8 0 010 2.4c0 .3 0 .7.2 1 0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-7.9-69.9l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm1.4-2.4c0-1.7.3-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.9 0-2.8-1.4-2.8-4.3zm2.5-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7 75.8 75.8 0 010 2.4c0 .3 0 .7.2 1 0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-3.1-72.5c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm3.5 6.7c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5 1.5v-.7a10.7 10.7 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.6 1-.3-.3.6-.5.8-.7.6-.6a6.6 6.6 0 00.8.1 115.1 115.1 0 010 8l.6.2h.6l.2.7h-3.7zm-4.6 52l-1-.2 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm2.1-1.5l.6.3.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.9-.8 3-1.8 3.3-3.1-.3.2-.7.3-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.5-.6.7 0 1.2.3 1.6.7.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3l-.2 1-.5 1-.8.8-1 .7-1.5.6zm3.4-6c0-.7-.2-1.2-.4-1.5a1 1 0 00-1-.5c-.3 0-.6.1-1 .4-.2.3-.3.6-.3 1 0 .7.1 1.3.4 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM132.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zM118 22l-.5-.1a.6.6 0 01-.2-.5c0-.2.1-.3.3-.5l.6-.1h.4v-.6-.4-.4c0-.3 0-.6.2-.8l.3-.4c.1-.2.3-.3.5-.3l.3-.4.7-.2.5-.1h1l.7.1c.3.2.4.4.4.6 0 .1 0 .3-.2.4l-.6.2-.4-.1h-.6l-.3.1h-.3c-.2.3-.4.4-.6.4v.5l-.2.4.1.5-.1.4h.2c.1 0 .3 0 .4.2l.5-.1h.4l.4.2.1.4c0 .2 0 .4-.2.5 0 .2-.2.2-.4.2h-1.1l-.3.1v.2l-.1.5V23.3l.2.4V25l.2.5-.1.4a.6.6 0 010 .7l.1.6c0 .2 0 .3-.2.4a32.2 32.2 0 00.2 1c0 .3-.2.5-.7.5-.2 0-.4-.2-.5-.5-.2-.3-.2-.6-.2-1V27v-.5-.3l-.1-.3.1-.4-.2-.2V25c0-.3 0-.4.2-.5l-.2-.6v-.3l.2-.2a1 1 0 01-.3-.7l.1-.4h-.2l-.5-.1zm6.4-4.5l-.3.3-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.3c.3-.2.5-.4.5-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.5-.2c-.2 0-.3 0-.5.2zm1 7c.2.1.2.2.3.4v1.5l-.1.4a1.7 1.7 0 010 1.2v.2l-.1.5-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7.1-.6v-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.2-.7V22v-.6-.6c0-.2 0-.3.2-.4h.4c.5 0 .7.2.7.8l.2.3.1.3c0 .3 0 .5-.2.6l.1.3v1.6l-.1.4zm5 1.5l-.2.4-.3.2c0 .3-.2.6-.5.7 0 .2 0 .4-.2.6l-.4.5c0 .2-.2.4-.3.5-.1.2-.3.3-.5.3s-.3 0-.4-.2a.6.6 0 01-.2-.5l.3-.7.1-.5.4-.4.1-.5c.1-.2.3-.2.4-.2v-.4c.1-.2.3-.3.4-.3l.2-.4.2-.3a.6.6 0 01-.3-.6c-.2 0-.3 0-.4-.2a.7.7 0 01-.2-.5v-.2s-.2 0-.3-.2a.5.5 0 01-.1-.4 2 2 0 01-.4-.2l-.2-.3a1 1 0 01-.5-.6c-.3-.3-.5-.5-.5-.8v-.3c.2-.3.4-.5.6-.5.2 0 .4.1.5.3l.4.5.6.3.3.6v.1c.3.2.5.5.6 1 .2 0 .3.1.5.3l.3.5v-.2l.3-.2.2-.2v-.4l.4-.3v-.2-.4h.3l.2-.6.4-.2c0-.2 0-.4.2-.5.2-.2.3-.2.5-.2s.3 0 .4.3c.2.1.2.3.2.4 0 .2 0 .4-.3.5V22.1l-.4.2c0 .2 0 .3-.3.3 0 .4-.2.8-.6 1 0 .3 0 .5-.2.7a1 1 0 01-.4.4v.4l.3.3.1.4c.1 0 .2 0 .3.2l.1.3c.4.2.6.4.6.7v.2s.2 0 .3.2l.1.4.2.1.2.4v.6l-.1.3-.4.2c-.4 0-.6-.3-.8-.8l-.4-.4-.3-.6-.5-.5-.3-.6a.5.5 0 01-.4-.4zm11.2-3.4l.3.4.2.7c0 .3-.2.6-.5.7-.1.1-.2.3-.4.3l-.4.2a1 1 0 01-.5-.1l-.3.1h-1.5a1 1 0 01-.5 0h-.5a1 1 0 01-.4 0l-.7.1a1 1 0 01-.4 0v.7l.2.6.1.2.3.3s.2 0 .3.2l.2.3.2-.1h.3l.1.1h.3l.4.1h.5l.2-.2.5-.1.3-.3h.5c.2 0 .4 0 .6.3v.3c0 .3 0 .5-.3.6 0 0-.2 0-.3.2l-.3.2h-.3c-.2.2-.4.3-.7.3a1 1 0 01-.3 0l-.5.1h-.5-.2l-.4-.2c-.6 0-1-.1-1.1-.5-.2 0-.4-.1-.5-.3l-.4-.5a.7.7 0 01-.4-.5v-.3h-.1v-.3-.2l-.2-.7c0-.2 0-.4.2-.5l-.1-.4V24l.3-.4v-.2l.2-.4.3-.2v-.2c0-.4.2-.7.7-.8 0-.2 0-.3.3-.5.2-.2.4-.3.6-.2 0-.2 0-.2.3-.3.2 0 .3-.1.4 0 0-.2.3-.3.5-.4l.4-.1h.7l.1.2.6.2c.2 0 .3.2.3.5h.5l.6.5.2.8v.2zm-2.4 1l.8-.1h.6l-.3-.2a1 1 0 010-.5v-.2h-.4a2.7 2.7 0 01-.5-.6l-.3-.1-.3-.3-.2.1a1 1 0 01-.3 0l-.3.2h-.3l-.4.6a1 1 0 01-.4.3l-.2.5-.4.4h.1l.6-.2h.4l.3.2.9-.3.6.3zm8.5 4.4l-.3.2a1 1 0 01-.6 0c0 .2-.2.2-.3.3a1 1 0 01-.5.2h-.2-.2l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.2-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.3-.4l-.2-.5v-.4l-.1-.4V25v-.7-.4-.3c0-.1 0-.2.2-.3v-.1-.2l.2-.2.1-.5.3-.3.1-.4.4-.3.4-.2c.2-.3.5-.4.9-.4h.8l.6.1h.5l.2.2v-.2l.1-.5V20v-.1l-.1-.2v-.2-.3l-.1-.3v-.4a1 1 0 01.2-1c0-.2.3-.3.5-.3l.4.3a.6.6 0 01.2.5c.2.2.3.3.3.6l-.1.3v.6a.7.7 0 01-.1.7l.1.4v4.6l.2.6c0 .2 0 .4-.2.6l.2.6-.1.5-.2.2.1.3v.9l-.5.2-.4-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.7H146.3c0-.1 0-.2.2-.2l.3-.1h.2V27l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.2a.8.8 0 01-.3-.1h-.3-.9-.2l-.3.3-.3.1-.1.3-.1.3-.2.1c0 .2-.1.3-.2.3v1.1c0 .5 0 .8-.2.9l.2.3v.7l.4.5c.1 0 .2 0 .3.2.3 0 .5.1.7.3zm-32.5 15.4l-.1-.4c0-.2 0-.4.2-.5 0-.1 0-.3.2-.4l.4-.4h.3c0-.2.2-.3.5-.4l.6-.1h.2l.4-.2.4.1.5-.1c.3 0 .5 0 .7.2l.4.5c.2 0 .3.1.4.3l.2.5.3.5.1.6-.1.6.2.5V45l.1.3v.2a2.8 2.8 0 010 .4l-.1.4v.5l-.1.5v.2c0 .3-.1.4-.3.6l-.2.3-.4.2c-.1 0-.3 0-.3-.2l-.7.2h-.2l-.7.1h-1.4-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3l-.1-.4V46v-.4c0-.3.2-.5.5-.8 0-.2.2-.4.4-.5l.5-.2c.1-.2.3-.3.5-.3l.7-.1.3-.1h1.1l.6-.3h.1c0-.2 0-.3.2-.4a.8.8 0 01-.4-.2 1 1 0 01-.2-.5.6.6 0 01-.4-.3l-.4.1h-.3a1 1 0 01-.4 0l-.5.1c-.1.2-.3.3-.5.3l-.4.5-.5.2c-.2 0-.4-.1-.5-.3zm.9 3.6l.2.3-.1.3.2.1.1.2H115.7c.2 0 .3 0 .5.2l.4-.2h.5c.1-.3.3-.4.5-.4l.2-.3-.1-.3V46l.1-.5a.8.8 0 01-.2-.5v-.4l-.2.1-.2-.1-.4.1h-.4l-.4.1h-.2c-.2.1-.3.2-.5.1 0 .2-.1.3-.2.3l-.4.1-.3.3h-.3l.1.3-.1.5zm11.2 2.2a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.3 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.3-.4l-.7-.1a.8.8 0 01-.3-.5c-.3-.2-.5-.6-.6-1.2l-.2-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2l.1-.5.3-.4v-.2c0-.2 0-.3.2-.5l.3-.2c0-.2.2-.3.3-.5l.5-.2c.3-.3.5-.4.7-.4l.4-.3h.4l.4-.1h1l.2.1h.3l.2.3c.1 0 .3 0 .4.2.2 0 .3.2.3.4l.1.3c.2 0 .3.2.4.4l.1.4a.6.6 0 01-.6.6c-.1 0-.3 0-.5-.2l-.4-.6a1.1 1.1 0 01-.7-.4h-.4l-.4.1h-.3c-.1.1-.3.3-.6.3l-.4.4-.4.1v.5l-.3.3-.2.1.1.5c0 .2 0 .5-.2.9l.1.3a1.2 1.2 0 010 .5l.2.3.1.4c.3 0 .5.2.7.3.2.2.3.3.3.5l.4-.2.3.1.3.3h.2l.4.1.3-.2.5-.2.2-.2a.9.9 0 01.6 0c0-.2.3-.3.5-.3s.4 0 .5.2c.2.1.3.3.3.5l-.3.6a1 1 0 01-.7.2 1 1 0 01-.2 0v.1l-.5.3a1 1 0 01-.4 0zm3.6-11c-.2 0-.3.1-.4.3l-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v1.9a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5V48l-.1-.4.1-.5v-.7-.6-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.2-.7V42v-.6-.6c0-.2 0-.3.2-.4h.4c.5 0 .7.2.7.8l.2.3.1.3-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3.5l-.3.2a1 1 0 01-.6 0c0 .2-.1.2-.3.3a1 1 0 01-.5.2h-.4l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1l-.2-.3-.4-.1a.6.6 0 01-.3-.5.8.8 0 01-.3-.4l-.1-.5v-.4l-.2-.4V45v-.7-.4-.3l.2-.3v-.1-.2l.2-.2.1-.5.3-.3.2-.4.3-.3.4-.2c.3-.3.5-.4 1-.4h.7l.6.1h.5l.2.2v-.2l.1-.5V40v-.1l-.1-.2v-.2-.3-.3-.4a1 1 0 010-1l.6-.3c.2 0 .3.1.5.3a.6.6 0 01.1.5c.2.2.3.3.3.6l-.1.3v2.5l.1.3v.7c0 .3 0 .5-.2.6l.2.5v.5l-.2.3.2.6v.3l.1.6c0 .2 0 .4-.2.6l.2.6v.5l-.3.2.1.3.1.5c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5v-.2l-.1-.1zm-2-.7h.5l.3-.2.3-.1h.2l.1-.2.2-.2.2-.2v-.3-.5-.5-.7-.7-.6-.7-.4h-.3a.8.8 0 01-.3-.1h-.5-.7-.2l-.3.3-.3.1v.3l-.2.3-.2.1c0 .2-.1.3-.2.3v1.1l-.1.9v.3l.2.4v.3c.1.1.3.3.3.5.1 0 .2 0 .3.2.3 0 .5.1.7.3zm5.4-9.8c-.2 0-.3.1-.4.3l-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.2-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.3 0-.4 0-.5.2zm1 7l.2.4v3.3l-.2.5-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7.1-.6v-.3a3.9 3.9 0 010-1v-.3-.5-.7l-.1-.4v-.3-.3l-.2-.6c0-.2 0-.4.2-.6v-.4h.5c.5 0 .7.2.7.8l.2.3.1.3c0 .3 0 .5-.2.6l.1.3v1.6l-.1.4zm6.2 3h.1l.2-.1h.2c.1 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1-.3-.3a.9.9 0 01-.4-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4c-.2 0-.2-.3-.2-.5v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4-.4a1 1 0 010-.8l.2-.2a.7.7 0 01-.2-.4v-.3a1 1 0 01-.3 0h-.7c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.3 0-.5-.2a.8.8 0 01-.1-.5l.1-.4.5-.2H143.7v-.5-.3-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.5c.1 0 .2 0 .3.2l.5.1.1.4c0 .1 0 .3-.2.5l-.4.2-.3-.1-.5.1-.3-.1a1 1 0 01-.4 0h-.3l.2.4c0 .1 0 .3-.2.4l.1.5-.1.5.2.4c0 .1 0 .3-.2.4l.2.6V46l.2.4.2.5c.2.1.4.3.4.6v.1h.2l.4.1H146.8zm6.7-1.5s0 .2-.2.3c0 .5-.1.7-.4.8 0 .2 0 .4-.2.6a1 1 0 01-.4.4v.2l-.1.3-.2.3c0 .4-.2.7-.6 1.1 0 .3 0 .5-.2.6a1 1 0 01-.6.3c0 .2-.1.3-.3.4a1 1 0 01-.6.3l-.5.3c-.3.2-.5.2-.6.1-.2 0-.4 0-.6-.2a.7.7 0 01-.2-.5l.1-.4.4-.1h.1c.3-.3.5-.4.7-.4h.2s0-.2.2-.3l.4-.3s0-.2.2-.3l.3-.3v-.1l.1-.6.5-.4a.6.6 0 01-.4-.5l-.3-.3-.1-.4v-.3a.7.7 0 01-.3-.2l-.1-.5v-.3l-.3-.3-.1-.3c-.2-.1-.3-.3-.3-.5v-.3a1.3 1.3 0 01-.3-1.2.8.8 0 01-.3-.3 1 1 0 010-1c-.3 0-.5-.3-.5-.5 0-.3.2-.5.4-.7h.3l.4.1c.2.1.3.3.3.4l.3.4a1.5 1.5 0 010 .7c.4.4.5.7.5 1v.3c.2 0 .3.2.3.3 0 .1.1.3 0 .4.2.1.3.2.3.4v.3l.3.3.1.4.3.3v.4l.2.4.1-.4.2-.2v-.3-.2l.2-.2c0-.2 0-.4.2-.5v-.2-.3l.2-.2-.1-.4v-.4l.3-.3-.1-.6c0-.3 0-.6.2-1l-.1-.3.1-.3a.8.8 0 01.8-.8c.2 0 .3 0 .4.2l.2.5.1.5c0 .4 0 .7-.3 1v.5c0 .2 0 .5-.2.7v.3l.1.3-.1.5-.4.9v.6z';

  var dataset04VAcidity = 'M183.3 27V27.9l-.4.4c0 .2-.1.4-.3.5l-.4.2a.7.7 0 01-.6-.3c-.2 0-.3-.2-.3-.4V28l-.2-.2a.7.7 0 01-.1-.4v-.2l-.2-.2v-.3a.5.5 0 01-.4-.2v-.3-.3l-.3-.4v-.6c-.2 0-.2-.1-.3-.2a.7.7 0 010-.4.8.8 0 01-.5-.4 1 1 0 01-.2-.6l-.2-.2v-.4a2 2 0 01-.4-.4 1 1 0 01-.1-.6c-.2-.2-.2-.4-.2-.6 0-.1 0-.3.2-.5l.5-.2c.2 0 .3.1.5.3 0 .1.2.3.1.4l.3.2a.8.8 0 010 .5c.3.2.4.4.4.6v.2l.3.3c.1.2.2.4.1.6.3.1.4.3.4.7l.3.3v.5l.3.4c.1.1.2.3.1.5.2.1.3.3.2.5l.2.1v-.4l.3-.3v-.2l.2-.3v-.2l.1-.4v-.3-.4l.2-.3v-.2c0-.2 0-.5.2-.6v-.3c0-.2 0-.4.2-.5v-.4a1.5 1.5 0 01.3-.9c0-.1 0-.2.2-.3l.3-.1c.2 0 .3 0 .5.2l.2.4v.6l-.1.4c0 .2-.2.3-.3.4v.3l-.1.6v.8l-.3.4v.3c0 .3 0 .5-.2.6V26l-.2.3v.4l-.2.2zm7.2 1.8l-.6.2-.4-.1h-.6c-.4 0-.7 0-.9-.3h-.1a.6.6 0 01-.6-.3l-.4-.1-.2-.4a.8.8 0 01-.4-.3 1 1 0 01-.2-.6.5.5 0 01-.3-.2 1 1 0 010-.5V26l-.2-.7.3-.6-.2-.3v-.4l.3-.2v-.4l.3-.3v-.1-.3l.3-.2v-.1c0-.3 0-.5.2-.6.2-.2.4-.3.5-.2 0-.2 0-.3.2-.4l.5-.2h.3l.4-.3.5-.2h.3l.6-.1.5.1.2.4c.2 0 .4 0 .6.2.2 0 .3.2.3.3l.8.5c.2.3.3.5.3.8v.2c.5 0 .7.5.6 1.4l.2.5-.2.6a.9.9 0 010 .7l-.3.2v.4l-.4.5v.2c0 .3-.2.5-.6.6l-.2.4-.6.2c-.1.2-.3.3-.6.3h-.2zm-1.5-1.1l.5-.1h.2l.3-.2h.4l.6-.3h.1l.1-.3.2-.2.1-.3.3-.3.1-.5a.7.7 0 010-.6l.3-.3a.5.5 0 01-.2-.3l.1-.4-.4-.4V23c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.4l-.4-.1c-.2-.1-.2-.2-.2-.4h-.3c-.3 0-.4 0-.6-.2l-.4.3a1 1 0 01-.5 0c0 .2-.1.3-.3.5l-.5.2v.6l-.2.2-.1.5-.4.3v.8s0 .2-.2.3c.3.2.4.5.4.8v.5h.2v.3c.3 0 .5.2.7.4l.4.1.3.3zm7.6-.7l.2.5v.5l-.3.3-.1.5-.5.2-.4-.1a.6.6 0 01-.2-.3l-.1-.5.1-.6v-.4-.6l-.1-.5.1-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4v-.4l.1-.6-.1-.6V20v-.2-.3-.4-.4-.3a.6.6 0 01-.2-.4c0-.2.1-.4.3-.5l.5-.2.3.1.3.4.2.5v.2l.2.5-.2.4.1.2.1.3c0 .2 0 .4-.2.5l.1.4v1.1l-.1.2.2.5v1.9l-.1.7v.9l.1.5v.5zm2.1-4.2l-.1-.4c0-.2 0-.4.2-.5 0-.1 0-.3.2-.4l.4-.4h.3l.5-.4.6-.1h.2l.5-.2.3.1.5-.1c.3 0 .5 0 .7.2.2.1.4.3.4.5.2 0 .3.1.4.3l.2.5c.2.2.3.3.3.5l.1.6-.1.6.2.5V25l.1.3v.2a2.1 2.1 0 010 .4l-.1.4v.5l-.1.5v.2c0 .3 0 .4-.3.6 0 .1 0 .3-.2.3l-.4.2c-.1 0-.2 0-.3-.2l-.7.2h-.2l-.7.1h-1.4-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3-.4-.4-.4c0-.3 0-.5.4-.8 0-.2.2-.4.4-.5l.6-.2c0-.2.2-.3.4-.3l.7-.1.3-.1h1.1l.6-.3h.2V23a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.3-.3l-.5.1h-.3a1 1 0 01-.4 0l-.5.1c-.1.2-.3.3-.5.3l-.4.5-.5.2c-.2 0-.4-.1-.5-.3zm.9 3.6l.2.3v.4c.2 0 .2.1.2.2H201.2c.2 0 .4 0 .5.2l.4-.2h.5c.1-.3.3-.4.5-.4l.2-.3-.1-.3V26l.1-.5a.8.8 0 01-.2-.5l.1-.4-.3.1-.2-.1-.4.1h-.3l-.5.1h-.2c-.2.1-.3.2-.4.1l-.3.3-.4.1-.2.3h-.3v.3l-.1.5zm10.6 1.2h.1l.2-.1h.1c.2 0 .4 0 .5.2l.1.4v.4l-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.6-.2l-.4-.1-.2-.3a.9.9 0 01-.4-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4c-.2 0-.3-.3-.3-.5v-.4a.6.6 0 01-.1-.5l.1-.4a.7.7 0 01-.2-.5l.1-.3v-.4-.4a1 1 0 010-.8l.1-.2a.7.7 0 01-.1-.4v-.3a1 1 0 01-.3 0h-.7c-.2 0-.4 0-.6-.2l-.4.1c-.1 0-.3 0-.4-.2a.8.8 0 01-.2-.5l.2-.4.4-.2H207.1v-.5-.3-.4c0-.3 0-.5.2-.6v-.5l.5-.1.4.1.2.4-.2.4c.1 0 .2.2.2.5v.3l-.1.2v.7h1.4c.2 0 .3 0 .4.2l.4.1.2.4c0 .1 0 .3-.2.5l-.5.2-.3-.1-.4.1-.4-.1a1 1 0 01-.3 0h-.3l.2.4-.2.4.1.5-.1.5.2.4c0 .1 0 .3-.2.4l.2.6V26l.1.4c.2.2.3.3.3.5.2.1.3.3.3.6l.1.1h.2l.3.1h.4zm2-10l-.3.3-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.3c.3-.2.5-.4.5-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.5-.2c-.2 0-.3 0-.5.2zm1 7c.2.1.2.2.3.4v1.5l-.1.4a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.1 0-.3 0-.4-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7v-.6-.3a4 4 0 010-1v-.3-.5l.1-.7a1.5 1.5 0 01-.2-.7V22l-.1-.6.1-.6.1-.4h.4c.5 0 .8.2.8.8l.2.3V24.3l-.1.4zm3.5 2.4l.2.5-.1.5-.2.3c0 .2 0 .4-.2.5l-.5.2-.3-.1a.6.6 0 01-.3-.3V28v-.6-.4-.6-.5-.6a1 1 0 010-.4l.1-.6v-.6-.5a.6.6 0 01-.2-.5v-.1a.7.7 0 01-.1-.5v-.4-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3.1-.4v-.4-.3a.6.6 0 01-.2-.4c0-.2 0-.4.2-.5l.5-.2.4.1.2.4c.2 0 .3.3.3.5v.2l.1.5-.1.4.1.2v.3l-.1.5V22l.2.5-.1.3.1.5-.1.5V26l.1.5-.1.5zm8.5-4.3l.3.4.2.7c0 .3-.2.6-.5.7-.1.1-.2.3-.4.3l-.4.2a1 1 0 01-.5-.1l-.3.1H222a1 1 0 01-.5 0h-.5a1 1 0 01-.4 0l-.7.1a1 1 0 01-.4 0v.7c.1.2.2.4.1.6l.2.2c.1 0 .2.1.2.3.2 0 .3 0 .4.2l.2.3.2-.1h.3l.1.1h.3l.3.1h.6l.2-.2.4-.1.4-.3h.4c.3 0 .5 0 .7.3v.3c0 .3 0 .5-.3.6 0 0-.2 0-.3.2l-.3.2h-.3c-.2.2-.4.3-.7.3a1 1 0 01-.3 0l-.5.1h-.5-.2l-.4-.2c-.6 0-1-.1-1.1-.5l-.6-.3-.3-.5a.7.7 0 01-.4-.5v-.3h-.1v-.3-.2l-.2-.7.1-.5v-.4-.5l.3-.4v-.2l.2-.4.3-.2v-.2c0-.4.2-.7.7-.8 0-.2 0-.3.3-.5.2-.2.4-.3.5-.2 0-.2.2-.2.4-.3.1 0 .3-.1.4 0 0-.2.2-.3.5-.4l.4-.1h.7l.1.2.6.2c.2 0 .3.2.3.5h.5l.6.5.2.8v.2zm-2.4 1l.8-.1h.5l-.2-.2a1 1 0 010-.5v-.2h-.4a2.7 2.7 0 01-.5-.6l-.3-.1-.3-.3-.2.1h-.4c0 .1 0 .2-.2.2h-.3l-.4.6a1 1 0 01-.4.3l-.2.5-.4.4.7-.2h.4l.3.2c.3-.2.5-.3.8-.3.3 0 .5.1.7.3zm-41.1 19l-.1-.3c0-.2 0-.4.2-.5 0-.1 0-.3.2-.4l.4-.4h.3c0-.2.2-.3.5-.4l.6-.1h.2l.4-.2.4.1.5-.1c.3 0 .5 0 .7.2l.4.5c.2 0 .3.1.4.3l.2.5.3.5.1.6-.1.6.2.5V45l.1.3v.2a2.8 2.8 0 010 .4l-.1.4v.5l-.1.5v.2c0 .3-.1.4-.3.6l-.2.3-.4.2c-.1 0-.3 0-.3-.2l-.7.2h-.2l-.7.1h-1.4-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3l-.1-.4V46v-.4c0-.3.2-.5.5-.8 0-.2.2-.4.4-.5l.5-.2c.1-.2.3-.3.5-.3l.7-.1.3-.1h1.1c.2-.2.3-.3.6-.3h.1c0-.2 0-.3.2-.4a.8.8 0 01-.4-.2 1 1 0 01-.2-.5.6.6 0 01-.4-.3l-.4.1h-.3a1 1 0 01-.4 0l-.5.1c-.1.2-.3.3-.5.3l-.4.5-.5.2c-.2 0-.4-.1-.5-.3zm.9 3.7l.2.3-.1.3.2.1.1.2H184.2c.2 0 .3 0 .5.2l.4-.2h.5c.1-.3.3-.4.5-.4l.2-.3-.1-.3V46l.1-.5a.8.8 0 01-.2-.5v-.4l-.2.1-.2-.1-.4.1h-.4l-.4.1h-.2c-.2.1-.3.2-.5.1 0 .2-.1.3-.2.3l-.4.1-.3.3h-.3l.1.3-.1.5zm11.2 2.2a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.3 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.3-.4l-.7-.1a.8.8 0 01-.3-.5c-.3-.2-.5-.6-.6-1.2l-.2-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2l.1-.5.3-.4v-.2c0-.2 0-.3.2-.5l.3-.2c0-.2.2-.3.3-.5l.5-.2c.3-.3.5-.4.7-.4l.4-.3h.4l.4-.1h1l.2.1h.3l.2.3c.1 0 .3 0 .4.2.2 0 .3.2.3.4l.1.3c.2 0 .3.2.4.4l.1.4a.6.6 0 01-.6.6c-.1 0-.3 0-.5-.2s-.3-.3-.3-.6a1.1 1.1 0 01-.8-.4h-.4l-.4.1h-.3c-.1.1-.3.3-.6.3l-.4.4-.4.1v.5l-.3.3-.2.1.1.5c0 .2 0 .5-.2.9l.1.3a1.2 1.2 0 010 .5l.2.3.1.4c.3 0 .5.2.7.3.2.2.3.3.3.5l.4-.2.3.1.3.3h.2l.4.1.3-.2.5-.2.2-.2a.9.9 0 01.6 0c0-.2.3-.3.5-.3s.4 0 .5.2c.2.1.3.3.3.5l-.3.6a1 1 0 01-.7.2 1 1 0 01-.2 0v.1l-.4.3a1 1 0 01-.5 0zm3.6-11c-.2 0-.3.1-.4.3l-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v1.9a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5V48l-.1-.4.1-.5v-.7-.6-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.2-.7V42v-.6-.6c0-.2 0-.3.2-.4h.4c.5 0 .7.2.7.8l.2.3.1.3-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3.5l-.3.2a1 1 0 01-.6 0c0 .2-.1.2-.3.3a1 1 0 01-.5.2h-.4l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1l-.2-.3-.4-.1a.6.6 0 01-.3-.5.8.8 0 01-.3-.4l-.1-.5v-.4l-.2-.4V45v-.7-.4-.3l.2-.3v-.1-.2l.2-.2.1-.5.3-.3.2-.4.3-.3.4-.2c.3-.3.5-.4 1-.4h.7l.6.1h.5l.2.2v-.2l.1-.5V40v-.1l-.1-.2v-.2-.3-.3-.4a1 1 0 010-1l.6-.3c.2 0 .3.1.5.3a.6.6 0 01.1.5c.2.2.3.3.3.6l-.1.3v2.5l.1.3v.7c0 .3 0 .5-.2.6l.2.5v.5l-.2.3.2.6v.3l.1.6c0 .2 0 .4-.2.6l.2.6v.5l-.3.2.1.3.1.5c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5v-.2l-.1-.1zm-2-.7h.5l.3-.2.3-.1h.2l.1-.2.2-.2.2-.2v-.3-.5-.5-.7-.7-.6-.7-.4h-.3a.8.8 0 01-.3-.1h-.5-.7-.2l-.3.3-.3.1v.3l-.2.3-.2.1c0 .2-.1.3-.2.3v1.1l-.1.9v.3l.2.4v.3c.1.1.3.3.3.5.1 0 .2 0 .3.2.3 0 .5.1.7.3zm5.4-9.8c-.2 0-.3.1-.4.3l-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.2-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.3 0-.4 0-.5.2zm1 7l.2.4v3.3l-.2.5-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7.1-.6v-.3a3.9 3.9 0 010-1v-.3-.5-.7l-.1-.4v-.3-.3l-.2-.6c0-.2 0-.4.2-.6v-.4h.5c.5 0 .7.2.7.8l.2.3.1.3c0 .3 0 .5-.2.6l.1.3v1.6l-.1.4zm6.2 3h.1l.2-.1h.2c.1 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1-.3-.3a.9.9 0 01-.4-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4c-.2 0-.2-.3-.2-.5v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4-.4a1 1 0 010-.8l.2-.2a.7.7 0 01-.2-.4v-.3a1 1 0 01-.3 0h-.7c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.3 0-.5-.2a.8.8 0 01-.1-.5l.1-.4.5-.2H212.2v-.5-.3-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.5c.1 0 .2 0 .3.2l.5.1.1.4c0 .1 0 .3-.2.5l-.4.2-.3-.1-.5.1-.3-.1a1 1 0 01-.4 0h-.3l.2.4c0 .1 0 .3-.2.4l.1.5-.1.5.2.4c0 .1 0 .3-.2.4l.2.6V46l.2.4.2.5c.2.1.4.3.4.6v.1h.2l.4.1H215.3zm6.7-1.5s0 .2-.2.3c0 .5-.1.7-.4.8 0 .2 0 .4-.2.6a1 1 0 01-.4.4v.2l-.1.3-.2.3c0 .4-.2.7-.6 1.1 0 .3 0 .5-.2.6a1 1 0 01-.6.3c0 .2-.1.3-.3.4a1 1 0 01-.6.3l-.5.3c-.3.2-.5.2-.6.1-.2 0-.4 0-.6-.2a.7.7 0 01-.2-.5l.1-.4.4-.1h.1c.3-.3.5-.4.7-.4h.2s0-.2.2-.3l.4-.3s0-.2.2-.3l.3-.3v-.1l.1-.6.5-.4a.6.6 0 01-.4-.5l-.3-.3-.1-.4v-.3a.7.7 0 01-.3-.2l-.1-.5v-.3l-.3-.3-.1-.3c-.2-.1-.3-.3-.3-.5v-.3a1.3 1.3 0 01-.3-1.2.8.8 0 01-.3-.3 1 1 0 010-1c-.3 0-.5-.3-.5-.5 0-.3.2-.5.4-.7h.3l.4.1c.2.1.3.3.3.4l.3.4a1.5 1.5 0 010 .7c.4.4.5.7.5 1v.3c.2 0 .3.2.3.3 0 .1.1.3 0 .4.2.1.3.2.3.4v.3l.3.3.1.4.3.3v.4l.2.4.1-.4.2-.2v-.3-.2l.2-.2c0-.2 0-.4.2-.5v-.2-.3l.2-.2-.1-.4v-.4l.3-.3-.1-.6c0-.3 0-.6.2-1l-.1-.3.1-.3a.8.8 0 01.8-.8c.2 0 .3 0 .4.2l.2.5.1.5c0 .4 0 .7-.3 1v.5c0 .2 0 .5-.2.7v.3l.1.3-.1.5-.4.9v.6zm-27.5 147c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V193.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.7-6.8v.5l-1.2.1h-1.4a53 53 0 01-.5 3l.7-.2c.7 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3c0-.3.2-.4.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zm5.9 6c0 .8-.2 1.4-.6 1.8-.5.4-1 .7-2 .7-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.3 1.2-.3.3-.6.5-1 .5.4 0 .7.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.6c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zM195.5 271c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V271.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm2.5 1.6l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm3.2-4c0-1.7.2-3 .6-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7 51.1 51.1 0 010 2.4c0 .3 0 .7.2 1 0 .4.3.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-11.7-178c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V89.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm2.5 1.6l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm3.7-.1v-.7a10 10 0 001.4-.2 39.9 39.9 0 000-5v-2l-1.6 1-.3-.3.6-.5a316.3 316.3 0 011.8-1.2h.4a114.5 114.5 0 010 8l.6.2h.6l.2.7h-3.7zM194.5 297c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm6.5-.9c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm7.5-.3l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.7.9c.4.6.6 1.4.6 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.5 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7 0 1.2.3 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm-13-157.4c0-1.7.3-3 .7-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.5-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V141.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.4.7l.4.8H202v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zm5.8-1.6c0 .9-.2 1.5-.6 2-.4.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.2-1.1.4-1.6.3-.5.6-.7 1-.8-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.3 1.2-.3.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.4-.7.4-1.2s-.1-.9-.4-1.2c-.4-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .4 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-.9.2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zM194.5 115c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V115.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm6.5-.9c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm8.3 5.8c0 .9-.2 1.5-.6 2-.4.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.3 1.2-.3.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.2-.5a2 2 0 00-1.1.6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zM195.5 323c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V323.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.6-7l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a27 27 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm8.9-1v.6l-.8.1a525.6 525.6 0 01.1 2.7c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a9.7 9.7 0 01-1.6 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2l3.1-4.9c.3 0 .6 0 1 .2a185.5 185.5 0 00-.1 4.8h.8zm-4 0h2.4a83 83 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zM196.5 245c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V245.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm2.5 1.6l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1l-3.2 7.8zm4.6 0l-.9-.3 3.2-7.7c-1.9 0-3-.1-3.7-.2l-.2-.5 2.5-.1h2.3v1l-3.2 7.8zm-13.7-82c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V167.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.6-7l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a27 27 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm8.7-6l.2.5c-1.8.8-3 1.9-3.2 3.2l.9-.3a2 2 0 011.7.9c.4.6.7 1.4.7 2.3 0 .7-.2 1.2-.7 1.6-.4.4-.9.6-1.5.6s-1.1-.2-1.6-.6c-.4-.5-.7-1-.7-1.8a25.3 25.3 0 01.2-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.4.3-.1.5v.5l-.1.6zm-12.3 50.6c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V219.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.4.7l.4.8H203v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zm.3.4l.1-.5h.6a11 11 0 001.4.3c.4 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4 0-.7-.3-1-.3-.2-.6-.3-1-.3H209l-.5.1-.2-.5a11.2 11.2 0 001-.3h1c.6 0 1 .1 1.4.5.3.5.5 1 .5 1.8 0 .4 0 .8-.3 1-.2.4-.6.6-1 .6.4.2.8.5 1 1 .3.4.4.9.4 1.5a3 3 0 01-.4 1.7c-.4.4-.8.7-1.5.7-.9 0-1.7-.2-2.5-.5zm-4.5 124.5c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset05Citric = 'M255 28.6a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.3 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.4-.4l-.6-.1a.8.8 0 01-.3-.5c-.3-.2-.5-.6-.7-1.2v-.2a1.1 1.1 0 01-.1-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2l.1-.5.3-.4v-.2c0-.2 0-.3.2-.5l.3-.2c0-.2.1-.3.3-.5l.5-.2c.3-.3.5-.4.7-.4l.4-.3h.4l.4-.1h1l.2.1h.3l.2.3c.1 0 .3 0 .4.2.2 0 .3.2.3.4l.1.3c.2 0 .3.2.4.4l.1.4a.6.6 0 01-.6.6c-.2 0-.3 0-.5-.2l-.4-.6-.4-.1-.3-.3h-.4l-.4.1h-.3c-.1.1-.3.3-.6.3l-.4.4-.4.1v.5l-.3.3-.2.1.1.5c0 .2 0 .5-.2.9l.1.3a1.2 1.2 0 010 .5l.2.3.1.4c.3 0 .5.2.7.3.2.2.3.3.3.5l.3-.2.4.1.3.3h.2l.4.1.3-.2.4-.2.3-.2a.9.9 0 01.5 0l.6-.3c.2 0 .4 0 .5.2.2.1.3.3.3.5l-.3.6a1 1 0 01-.7.2 1 1 0 01-.2 0v.1l-.5.3a1 1 0 01-.4 0zm3.6-11c-.2 0-.3.1-.4.3l-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v1.9a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5V28l-.1-.4.1-.5v-.7-.6-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.2-.7V22v-.6-.6c0-.2 0-.3.2-.4h.4c.5 0 .7.2.7.8l.2.3.1.3c0 .3 0 .5-.2.6l.1.3v1.6l-.1.4zm6.3 3l.2-.1h.2c.2 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1c-.2-.1-.2-.2-.2-.3a.9.9 0 01-.5-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4l-.2-.5v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4-.4a1 1 0 010-.8l.2-.2a.7.7 0 01-.2-.4v-.3a1 1 0 01-.3 0h-.4-.3c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.5l.1-.4.5-.2H262.7v-.5l.1-.3-.1-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.5c.1 0 .2 0 .3.2l.5.1.1.4c0 .1 0 .3-.2.5l-.4.2-.3-.1-.4.1-.4-.1a1 1 0 01-.3 0h-.4l.2.4c0 .1 0 .3-.2.4l.1.5-.1.5.2.4c0 .1 0 .3-.2.4.2.1.2.3.2.6V26l.2.4c.2.2.2.3.2.5.3.1.4.3.4.6v.1h.2l.4.1h.4zm3.1.6l-.1.6-.5.2c-.2 0-.3 0-.4-.2a.6.6 0 01-.2-.4v-.5-.4-.4l-.1-.1v-.3-.4a.6.6 0 01-.1-.4c0-.2 0-.4.2-.5v-.2-.2a1 1 0 01-.2-.6l.1-.5a.8.8 0 01-.2-.6V23v-.4c0-.1 0-.3.2-.4l-.2-.4v-.5a1 1 0 010-.4c0-.3 0-.4.2-.5 0-.1 0-.2.2-.3l.3-.2c.2 0 .3.1.4.3.2.1.2.3.2.6v.3h.1l.2-.2h.3l.2-.2h.5l.3-.1c.1 0 .3 0 .4.3l.6.1.4.1.3.3c.2.2.3.3.3.6 0 .1 0 .3-.2.5l-.5.2c-.2 0-.4-.1-.5-.3h-.3l-.2-.2h-.2-.7c-.1.2-.3.3-.5.3v.2l-.1.4-.2.3.1.6-.1.4v.2l.2.1v.8l-.1.4V28.2zm4.6-10.6c-.2 0-.3.1-.4.3v.3l.1.5c0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v1.9a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.3 0-.5-.2a.6.6 0 01-.2-.5V28l-.1-.4.1-.5v-.7-.6-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.2-.7V22v-.6-.6c0-.2 0-.3.2-.4h.4c.5 0 .7.2.7.8l.2.3.1.3-.1.6v.3l.1.4v1.2l-.2.4zm6.4 4a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.3 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.4-.4l-.6-.1a.8.8 0 01-.3-.5c-.3-.2-.5-.6-.7-1.2l-.1-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2l.1-.5c0-.2.2-.3.3-.4v-.2c0-.2 0-.3.2-.5l.3-.2c0-.2.1-.3.3-.5l.5-.2c.2-.3.4-.4.7-.4l.3-.3h.5l.4-.1h1l.2.1h.3l.1.3c.2 0 .4 0 .5.2l.3.4.1.3c.2 0 .3.2.4.4l.1.4a.6.6 0 01-.6.6c-.2 0-.4 0-.5-.2l-.4-.6a1.1 1.1 0 01-.7-.4h-.5l-.3.1h-.3l-.6.3-.4.4-.4.1v.2l-.1.3-.2.3-.2.1v.5l-.1.9v.3l.2.4v.1l.1.3.1.4c.3 0 .5.2.7.3.2.2.3.3.3.5l.3-.2.4.1.3.3h.2l.4.1.3-.2.4-.2.3-.2a.9.9 0 01.5 0l.6-.3c.2 0 .4 0 .5.2.2.1.2.3.2.5s0 .4-.3.6a1 1 0 01-.6.2 1 1 0 01-.2 0v.1l-.5.3a1 1 0 01-.4 0zm-26.7 14.2l-.2-.4c0-.2 0-.4.2-.5l.2-.4.4-.4h.4c0-.2.2-.3.4-.4l.7-.1h.1l.5-.2.3.1.6-.1c.2 0 .5 0 .7.2.2.1.3.3.3.5.2 0 .4.1.5.3l.2.5.3.5v1.2l.1.5.1.6v.8a2.1 2.1 0 010 .4v.9c0 .2 0 .4-.2.5v.2c0 .3 0 .4-.2.6 0 .1-.1.3-.3.3l-.3.2c-.2 0-.3 0-.4-.2l-.7.2h-.1l-.7.1H256h-.3-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3l-.1-.4V46v-.4c0-.3.1-.5.4-.8l.4-.5.6-.2c0-.2.2-.3.5-.3l.6-.1.3-.1H257.8l.6-.3h.2l.1-.4a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.4-.3l-.4.1h-.4a1 1 0 01-.3 0l-.5.1-.6.3c0 .2-.2.3-.4.5l-.5.2c-.2 0-.3-.1-.4-.3zm.8 3.6c.2 0 .2.2.2.3v.3l.1.1.2.2h1.1c.2 0 .4 0 .5.2l.4-.2h.6c0-.3.2-.4.5-.4 0-.1 0-.2.2-.3l-.1-.3-.1-.3c0-.2 0-.4.2-.5a.8.8 0 01-.2-.5v-.4l-.2.1-.3-.1-.4.1h-.3l-.4.1h-.3c-.1.1-.3.2-.4.1 0 .2-.1.3-.3.3l-.4.1c0 .1 0 .2-.2.3h-.3v.8zm11.3 2.2a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.4 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.4-.4l-.6-.1a.8.8 0 01-.3-.5c-.3-.2-.6-.6-.7-1.2l-.1-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2-.5l.4-.4v-.2l.1-.5.4-.2c0-.2.1-.3.3-.5l.5-.2c.2-.3.4-.4.6-.4l.4-.3h.5l.3-.1h1.1l.2.1h.2l.2.3c.2 0 .4 0 .5.2l.3.4v.3c.3 0 .4.2.5.4v.4a.6.6 0 01-.5.6c-.2 0-.4 0-.6-.2l-.3-.6a1.1 1.1 0 01-.7-.4h-.5l-.3.1h-.3l-.6.3-.4.4-.4.1v.2l-.1.3-.2.3-.2.1v.5c0 .2 0 .5-.2.9l.2.3v.5l.2.3.1.4c.3 0 .5.2.7.3l.2.5.4-.2.4.1.3.3h.2l.4.1.3-.2.4-.2.3-.2a.9.9 0 01.5 0c.2-.2.3-.3.6-.3.2 0 .4 0 .5.2.2.1.2.3.2.5s0 .4-.3.6a1 1 0 01-.6.2 1 1 0 01-.2 0v.1l-.5.3a1 1 0 01-.4 0zm3.5-11l-.3.3-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.3c.3-.2.5-.4.5-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.5-.2c-.2 0-.3 0-.5.2zm1 7c.2.1.2.2.3.4v1.5l-.1.4v1.4c0 .2 0 .4-.2.5l-.5.2c-.1 0-.3 0-.4-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7v-.6-.3a3.9 3.9 0 010-1v-.3-.5l.1-.7-.1-.4-.1-.3V42l-.1-.6.1-.6.1-.4h.5c.4 0 .7.2.7.8l.2.3V44.3l-.1.4zm6.3 3.5l-.2.2a1 1 0 01-.6 0c0 .2-.2.2-.3.3a1 1 0 01-.5.2h-.2-.2l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.3-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4v-.5-.4l-.2-.4-.1-.8.1-.7v-.4-.3l.1-.3v-.1-.2l.3-.2v-.5l.4-.3.1-.4.4-.3.4-.2c.2-.3.5-.4.9-.4h.8l.5.1h.6l.2.2v-.2l.1-.5-.1-.4v-.1-.2l-.1-.2V39v-.3-.4a1 1 0 01.1-1c.2-.2.3-.3.6-.3l.4.3a.6.6 0 01.2.5c.2.2.2.3.2.6v.6l-.1.3a.7.7 0 010 .7l.1.4v1.8l-.1.6.2.5-.1.5-.1.3.2.6-.1.3.2.6c0 .2 0 .4-.2.6l.2.6-.1.5-.2.2v.3l.2.5c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.7h.6l.2-.2.4-.1h.2V47l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.2a.8.8 0 01-.3-.1h-.3-.9-.2l-.3.3-.3.1-.1.3-.1.3-.3.1-.1.3v1.1c0 .5 0 .8-.2.9l.1.3.1.4v.3l.4.5s.2 0 .3.2c.2 0 .5.1.6.3zm-15.7 145.7c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V193.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.8-.6l.2.5c-1.8.8-2.9 1.9-3.2 3.2l.9-.3a2 2 0 011.7.9c.4.6.7 1.4.7 2.3 0 .7-.2 1.2-.7 1.6-.4.4-.9.6-1.5.6s-1.1-.2-1.6-.6c-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.4.3-.1.5v.5l-.1.6zm-13 76.6c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V271.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.8-2l.1.6-.8.1v2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.2 4.8h.8zm-4 0h2.4a83 83 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm8.8 2.7l.3.8h-4.7v-.3-.4l.7-1a46 46 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.7.2-1 .5c-.4.3-.7.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-.9 2.8 16 16 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zM258.5 89c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V89.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 83 83 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.7 4c0-1.7.2-2.9.6-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7v.7l-.1.7a8.7 8.7 0 00.3 2c0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-11.6 212c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5 1.5v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H269.6zm4.3 0v-.7a10.5 10.5 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 115.1 115.1 0 01.1 8l.5.2h.7l.2.7h-3.7zM260.5 141c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V141.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.7-6.8v.5l-1.2.1h-1.4a53 53 0 01-.5 3l.7-.2c.7 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3c0-.3.2-.4.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zm5-.2l.3.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a25.3 25.3 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7.2 1.2.4 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.4-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm-14-27.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V115.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm8 4.5v.5l-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a9.7 9.7 0 01-1.6 0 18.7 18.7 0 00-1.5 0 5.3 5.3 0 000-.7v-.2a56 56 0 013.1-4.9c.3 0 .6 0 1 .2a185.5 185.5 0 00-.1 4.8h.8zm-4-.2l2.4.1a90.1 90.1 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zm-12.5 207.7c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V323.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.6 7l.3.9h-4.7v-.3-.4l.7-1a46 46 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.7.2-1 .5c-.4.3-.6.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.7-.6.5 0 1 .2 1.4.5.4.4.5.9.5 1.5a4.8 4.8 0 01-.9 2.8 16 16 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm-17.1-81c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V245.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.7 7.9v-.7a10.7 10.7 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.6 1-.3-.3.6-.5.8-.7.6-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 010 8l.6.2h.6l.2.7h-3.7zM258.5 167c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V167.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.7 4c0-1.7.2-3 .6-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.3 4.3 0 00-.3 1.7v.7l-.1.7a8.7 8.7 0 00.3 2c0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-13.6 56c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V219.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.6 7l.3.9h-4.7v-.3-.4l.7-1a46 46 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.7.2-1 .5c-.4.3-.6.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.7-.6.5 0 1 .2 1.4.5.4.4.5.8.5 1.5a4.8 4.8 0 01-.9 2.8 16 16 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm-9.3 125c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset06Sugar = 'M309.4 28.2l-.1.6-.5.2c-.2 0-.3 0-.4-.2a.6.6 0 01-.2-.4v-.5-.4-.4-.1l-.1-.3v-.4a.6.6 0 01-.1-.4c0-.2 0-.4.2-.5v-.2-.2a1 1 0 01-.2-.6c0-.2 0-.4.2-.5a.8.8 0 01-.3-.6l.1-.3v-.4-.4l-.1-.4v-.5a1 1 0 010-.4c0-.3 0-.4.2-.5 0-.1 0-.2.2-.3l.3-.2c.2 0 .3.1.4.3.2.1.2.3.2.6v.3h.1l.2-.2h.3l.2-.2h.5l.3-.1c.1 0 .3 0 .4.3l.6.1.4.1c.2 0 .3.2.3.3.2.2.3.3.3.6 0 .1 0 .3-.2.5l-.5.2c-.2 0-.4-.1-.5-.3h-.3l-.2-.2h-.9c0 .2-.3.3-.5.3v.2l-.1.4-.2.3.1.6-.1.4v.2l.2.1v.8l-.1.4.1.3-.1.4.1.5-.1.4v.7zm10.6-5.5l.3.4.1.7c0 .3-.1.6-.4.7-.1.1-.2.3-.4.3l-.4.2a1 1 0 01-.5-.1l-.3.1h-1.5a1 1 0 01-.5 0h-.5a1 1 0 01-.4 0l-.7.1a1 1 0 01-.4 0l-.1.7c.2.2.3.4.2.6l.2.2c.1 0 .2.1.2.3.2 0 .3 0 .4.2l.2.3.2-.1h.3l.1.1h.3l.3.1h.5l.3-.2.4-.1.4-.3h.4c.3 0 .5 0 .7.3v.3c0 .3 0 .5-.3.6 0 0-.2 0-.3.2l-.4.2h-.2c-.2.2-.4.3-.7.3a1 1 0 01-.3 0l-.5.1h-.5-.2l-.4-.2c-.6 0-1-.1-1.2-.5l-.5-.3-.3-.5a.7.7 0 01-.4-.5v-.3h-.1v-.3-.2l-.2-.7.1-.5v-.4-.5l.3-.4v-.2l.2-.4.3-.2v-.2c0-.4.2-.7.7-.8 0-.2 0-.3.3-.5.2-.2.4-.3.5-.2 0-.2.2-.2.3-.3h.5c0-.2.2-.3.5-.4l.4-.1h.7l.1.2.6.2c.2 0 .3.2.3.5h.5l.6.5.2.8v.2zm-2.4 1l.8-.1h.5l-.2-.2a1 1 0 010-.5v-.2h-.4a2.7 2.7 0 01-.5-.6l-.3-.1-.3-.3-.2.1a1 1 0 01-.4 0c0 .1 0 .2-.2.2h-.4c0 .3-.2.4-.3.6a1 1 0 01-.4.3l-.2.5-.4.4.7-.2h.4l.3.2c.3-.2.5-.3.8-.3.3 0 .5.1.7.3zm9.5 3.4v.3c0 .2 0 .4-.2.5 0 .1 0 .3-.2.4-.1.2-.3.3-.4.3l-.5.3h-1.1l-.6.1a2 2 0 01-.7-.1c-.2 0-.3-.2-.4-.3-.2 0-.4 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.1-.6l-.1-.3.1-.4.4-.1.4.2c.2 0 .3 0 .5.2l.2.5h.3l.3.1.3.3h.5l.3.2.4-.1h.4l.3-.2h.3V27l.1-.5a.7.7 0 01-.3-.2V26h-.3c-.2 0-.3 0-.4-.2a1 1 0 01-.7-.2c-.2 0-.3-.2-.4-.4h-.3l-.6-.1a1 1 0 01-.3-.4l-.6-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 010-.4v-.2a.7.7 0 01.1-.8V22v-.4l.4-.2V21l.5-.3h.4l.2-.3h.4l.3.1.2-.1h.2a.7.7 0 01.5 0h.7l.2.3H326.1l.2.4c.2 0 .4 0 .5.2.2 0 .3.2.2.3.3.2.5.4.5.7l-.2.4c-.1.2-.3.2-.5.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.4a.8.8 0 01-.3-.4l-.3.1a1 1 0 01-.3 0h-.3l-.4.1h-.3v.3h-.4v.3c0 .2 0 .3-.2.5l.2.2.1.4h.1c.4 0 .6 0 .6.3h.2l.5.1.3.4h.5l.3.3h.3c.2 0 .3 0 .5.2l.2.3s.2 0 .3.2v.4h.3V26.4c.2 0 .2.2.2.4v.3l-.2.1zm1.6-9.5l-.3.3-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.4.2.6.2h.3c.3-.2.5-.4.5-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.5-.2c-.2 0-.3 0-.5.2zm1 7c.2.1.2.2.3.4v1.5l-.1.4a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.1 0-.3 0-.4-.2a.6.6 0 01-.2-.5l-.1-.3v-.4l.1-.5-.1-.7v-.6-.3a4 4 0 010-1v-.3-.5l.1-.7a1.5 1.5 0 01-.2-.7V22l-.1-.6.1-.6.1-.4h.4c.5 0 .8.2.8.8l.2.3V24.3l-.1.4zm6.3 3.5l-.2.2a1 1 0 01-.6 0c0 .2-.2.2-.3.3a1 1 0 01-.5.2h-.2-.2l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.3-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4v-.5-.4l-.2-.4-.1-.8.1-.7v-.4-.3l.1-.3v-.1-.2l.3-.2v-.5l.4-.3.1-.4.3-.3.5-.2c.2-.3.5-.4.9-.4h.8l.5.1h.6l.2.2v-.2l.1-.5-.1-.4v-.1-.2l-.1-.2V19v-.3-.4a1 1 0 01.1-1c.2-.2.3-.3.6-.3l.4.3a.6.6 0 01.2.5c.2.2.2.3.2.6v.6l-.1.3v.7l.1.4v1.8l-.1.6.2.5-.1.5-.1.3.2.6-.1.3.2.6-.2.6.2.6-.1.5-.2.2v.3l.2.5c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.7h.6l.2-.2.4-.1h.2V27l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.2a.8.8 0 01-.3-.1h-.3-.9-.2l-.3.3-.3.1-.1.3-.1.3-.3.1-.1.3v1.1c0 .5 0 .8-.2.9l.1.3.1.4v.3l.4.5s.2 0 .3.2c.2 0 .5.1.6.3zm8.1 1.3a1 1 0 01-.3 0h-.4l-.4-.2a.8.8 0 01-.2-.3.8.8 0 01-.4-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2l-.1-.6v-.3-.4a.6.6 0 01-.2-.7l-.1-.4.1-.4a.6.6 0 01-.2-.5l.1-.3a.8.8 0 01-.1-.5V23l-.1-.4.1-.3v-.4l.1-.6V21c0-.2 0-.4.2-.5l.4-.2.5.2.2.5-.1.6.2.5-.1.4v.9l.1.6v.4l.1.4v.2l.1.5v.4l.1.2v.3l.1.2v.3l.3.1v.2h.4l.1.2.7-.2h.2l.4-.2h.5v-.5l.1-.3v-.6l.1-.7a1 1 0 01-.1-.5V24v-.3-.4l.2-.3-.2-.7v-.5-.5l.1-.5.5-.2c.2 0 .3.1.5.3l.2.7.1.2v.4l-.1.5c.2.2.3.4.3.7l-.1.3V25c0 .1 0 .3-.2.5l.2.4c0 .1 0 .3-.2.5l.1.4V28.4c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5l-.1-.1a1 1 0 01-.5.1h-.1l-.4.2-.3-.1-.2.2h-.3-.2zm5.2-6v-.3l.1-.5.2-.4.4-.4h.4c0-.2.2-.3.4-.4l.6-.1h.2l.5-.2.3.1.6-.1c.2 0 .5 0 .7.2.2.1.3.3.3.5.2 0 .4.1.5.3l.2.5.3.5v1.2l.1.5.1.6v.8a2.8 2.8 0 010 .4v.9c0 .2 0 .4-.2.5v.2c0 .3 0 .4-.2.6l-.3.3-.4.2s-.2 0-.3-.2l-.7.2h-.2l-.7.1h-1-.3-.3a1 1 0 01-1-.6c-.3-.2-.5-.6-.5-1v-.3l-.2-.4.1-.4v-.4c0-.3.1-.5.4-.8l.4-.5.6-.2c0-.2.2-.3.5-.3l.6-.1.3-.1H351l.6-.3h.2l.1-.4a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.4-.3l-.4.1h-.4a1 1 0 01-.3 0l-.5.1-.6.3c0 .2-.2.3-.4.5l-.5.2c-.2 0-.3-.1-.5-.3zm1 3.7l.1.3v.3l.1.1.2.2h1.1c.2 0 .4 0 .5.2l.4-.2h.6c0-.3.2-.4.5-.4 0-.1 0-.2.2-.3l-.2-.3V26c0-.2 0-.4.2-.5a.8.8 0 01-.2-.5v-.4l-.2.1-.3-.1-.4.1h-.3l-.4.1h-.3c-.1.1-.3.2-.4.1 0 .2-.2.3-.3.3l-.4.1-.2.3h-.3v.8zm8.2.6l.2.5v.5l-.3.3-.1.5-.5.2-.4-.1a.6.6 0 01-.2-.3l-.1-.5v-.6-.4l.1-.6-.1-.5.1-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4-.1-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3.1-.4v-.4-.3a.6.6 0 01-.2-.4c0-.2 0-.4.2-.5l.6-.2.3.1.2.4c.2 0 .3.3.3.5v.2l.1.5-.1.4.1.2v.3l-.1.5.1.4v1.1l-.1.2.2.5v.8l-.1.5.1.6-.1.7v.9l.1.5v.5zM321 47.1v.3c0 .2 0 .4-.2.5 0 .1 0 .3-.2.4l-.4.3-.5.3h-1.1l-.7.1a2 2 0 01-.6-.1c-.2 0-.3-.2-.4-.3-.2 0-.4 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.2-.6v-.3-.4l.4-.1c.2 0 .3 0 .4.2.2 0 .4 0 .6.2l.2.5h.2l.4.1.2.3h.6l.3.2.4-.1h.4c0-.1.1-.2.3-.2h.3V47l.1-.5a.7.7 0 01-.3-.2V46h-.3c-.2 0-.3 0-.5-.2a1 1 0 01-.6-.2c-.2 0-.4-.2-.5-.4h-.2l-.6-.1a1 1 0 01-.3-.4l-.6-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 01-.1-.4v-.2a.7.7 0 01.2-.8V42v-.4l.3-.2c0-.1 0-.3.2-.4l.3-.3h.5l.2-.3h.3l.4.1.1-.1h.3a.7.7 0 01.4 0h.8l.2.3H320l.2.4c.2 0 .3 0 .5.2.2 0 .2.2.2.3.3.2.4.4.4.7l-.1.4c-.2.2-.3.2-.5.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.4a.8.8 0 01-.3-.4l-.3.1a1 1 0 01-.4 0h-.3l-.3.1h-.3v.3h-.4v.3c0 .2 0 .3-.2.5l.2.2c0 .2.1.3 0 .4h.2c.3 0 .5 0 .6.3h.1l.5.1c.2 0 .3.2.4.4h.5l.3.3h.3c.1 0 .3 0 .4.2.2 0 .3.2.3.3 0 0 .2 0 .2.2l.1.4h.2l.1.4v.2l.2.4v.3l-.2.1zm4 1.6a1 1 0 01-.3 0h-.4l-.4-.2a.8.8 0 01-.3-.3.8.8 0 01-.3-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2l-.1-.6v-.3-.4a.6.6 0 01-.2-.7l-.1-.4.1-.4a.6.6 0 01-.2-.5v-.3a.8.8 0 010-.5V43l-.1-.4v-.3-.4c0-.3 0-.4.2-.6V41l.1-.5.5-.2.5.2.2.5-.1.6.2.5c0 .1 0 .3-.2.4l.1.4v1.5l.2.4V45.7l.2.2v.5l.1.2v.3l.2.1.1.2h.4l.1.2.6-.2h.3l.4-.2h.5l-.1-.5c0-.2 0-.3.2-.3l-.1-.6c0-.3 0-.6.2-.7a1 1 0 01-.2-.5l.1-.4v-.3-.4l.2-.3-.2-.7v-.5l-.1-.5c0-.2 0-.4.2-.5l.4-.2.6.3.2.7v.2l.2.4-.2.5c.2.2.3.4.3.7 0 .1 0 .2-.2.3l.2.4-.1.4v.4c0 .1 0 .3-.2.5l.2.4-.2.5.1.4-.1.7.1.4v.6c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5l-.1-.1a1 1 0 01-.5.1h-.1l-.4.2-.4-.1-.2.2h-.4zm9.6 1.8v-.3c.2 0 .2-.1.3-.2v-.2-.4l.3-.3V49v-.4c0-.2.1-.2.2-.3-.6.3-1 .5-1.2.4h-1.5l-.7-.1a.9.9 0 01-.4-.4l-.8-.4-.4-1a.8.8 0 01-.4-.5 2 2 0 01-.1-.7l.1-.7-.2-.4v-.6c0-.5.1-.9.3-1v-.3l.3-.5c0-.2.2-.3.3-.3v-.4l.4-.2.2-.1c0-.2.2-.3.3-.4l.5-.2.4-.3.7-.1h.6l.5.3.5-.1c.3 0 .5.1.6.4h.3c.2 0 .3 0 .5.2l.2.4v.2l.2.4V43.1l-.2.4a.6.6 0 010 .7v.4l.1.5v.2l.1.5v.5l.2.7c0 .2 0 .3-.2.4l.1.2v.8c0 .3 0 .5-.2.6.1 0 .1.1 0 .2v.7l-.1.3c0 .2-.2.3-.3.3-.1.4-.3.6-.6.7l-.1.4-.4.2c0 .2-.2.4-.6.4l-.4.2h-.5c-.4 0-.7 0-.9-.2l-.4-.2a.8.8 0 01-.3-.3.6.6 0 01-.6-.6l-.1-.4c0-.2 0-.3.2-.5l.5-.1h.4l.2.4c.2 0 .4.1.5.3l.4.2.2-.1h.6l.1-.2.3-.2zm-.7-3c0-.2.2-.2.4-.2h.3s.2 0 .3-.2l.4-.2c-.1 0-.2-.3-.2-.7l.1-.6a1 1 0 01-.1-.5v-.3-.3l.1-.5-.1-.5v-.2a.9.9 0 01-.1-.5v-.5-.2l-.2-.3a1 1 0 01-.4 0l-.2-.3-.4.1a1 1 0 01-.6-.2l-.4.3-.4.2-.2.3-.3.2-.2.4-.2.3v.8l-.3.3.2.3v1l.2.2.1.4v.3l.2.3.1.3.5.1.3.3.5-.2.6.2zm4.4-4.7l-.2-.4.2-.5.3-.4c0-.2.2-.3.3-.4h.4c0-.2.2-.3.4-.4l.7-.1h.2l.4-.2.3.1.6-.1c.3 0 .5 0 .7.2l.4.5c.2 0 .3.1.4.3l.2.5.3.5v1.2l.1.5.1.6v.3l.1.3v.2a2.8 2.8 0 010 .4c0 .2 0 .3-.2.4l.1.5c0 .2 0 .4-.2.5v.2c0 .3 0 .4-.2.6l-.2.3-.4.2c-.2 0-.3 0-.4-.2l-.6.2h-.2l-.7.1h-1.4-.2a1 1 0 01-1-.6c-.4-.2-.6-.6-.6-1v-.3l-.1-.4V46v-.4c0-.3.1-.5.4-.8l.4-.5.6-.2c0-.2.2-.3.5-.3l.7-.1.2-.1h1.2c.2-.2.3-.3.5-.3h.2l.1-.4a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.4-.3l-.4.1h-.4a1 1 0 01-.3 0l-.5.1-.6.3c0 .2-.2.3-.4.5l-.5.2c-.2 0-.3-.1-.4-.3zm.9 3.6l.1.3v.3l.2.1.1.2H340.8c.2 0 .3 0 .4.2l.4-.2h.6c0-.3.3-.4.5-.4 0-.1 0-.2.2-.3l-.1-.3V46v-.5a.8.8 0 01-.1-.5v-.4l-.2.1-.3-.1-.4.1h-.3l-.4.1h-.3c-.1.1-.3.2-.4.1 0 .2-.1.3-.2.3l-.5.1c0 .1 0 .2-.2.3h-.3l.1.3-.1.5zm7.8 1.8c0 .3 0 .5-.2.6l-.4.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.4l.1-.5v-.4-.4l-.1-.1v-.3-.4a.6.6 0 01-.2-.4c0-.2.1-.4.3-.5v-.2-.2a1 1 0 01-.2-.6l.1-.5a.8.8 0 01-.3-.6l.1-.3v-.4l.1-.4-.2-.4.1-.5a1 1 0 010-.4c0-.3 0-.4.2-.5l.1-.3.4-.2.4.3.2.6v.3l.3-.2h.2l.2-.2H348.1l.2-.1c.2 0 .3 0 .5.3l.5.1.5.1.3.3c.2.2.3.3.3.6l-.3.5-.5.2c-.2 0-.3-.1-.5-.3h-.2l-.2-.2h-.2-.8c0 .2-.2.3-.5.3V43.1l-.3.3.2.6c0 .2 0 .3-.2.4l.1.2.1.1v3.1l-.1.4zM326.5 197v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm5.6-6.8l.2.5-1.4.1H334a55 55 0 01-.4 3l.6-.2c.7 0 1.3.3 1.9.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.6.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.1-.3.4-.4h.1c.6.5 1 .7 1.6.7.4 0 .8-.2 1.2-.6.3-.4.4-.8.4-1.3 0-.4-.1-.8-.4-1.1-.3-.4-.7-.5-1.3-.5h-.6a8 8 0 00-1-.4l.5-2.2.5-1.8h3.1zm-10 86.3v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.6 1.7l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.4-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1 .7-1.5.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.4-.3.1-.4a4 4 0 00.1-1.1zM326.5 93v-.7a9.9 9.9 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3a212.1 212.1 0 002.4-1.7h.4a115 115 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm6.4-.9c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6 0-1.1.3-1.6s.6-.7 1-.8c-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .5 1.3.3.3.7.5 1.1.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3 0-.7-.4-1-.2-.3-.5-.5-1-.6zM325.5 297c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm-5.6-151l.4.8H326v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm1-.7c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm5.6-7l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm-3.3-24.3l.4.8H326v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm1-.7c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5 1.5v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3a113.1 113.1 0 002.4-1.7h.4a116.8 116.8 0 010 8l.6.2h.6l.2.7H333zm-6.4 208v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm6.4-.9c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6 0-1.1.3-1.6s.6-.7 1-.8c-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .5 1.3.3.3.7.5 1.1.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3 0-.7-.4-1-.2-.3-.5-.5-1-.6zm-5.5-70.6l.4.8H325v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm1-.7c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7v1.4a8.7 8.7 0 00.2 2c0 .4.3.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-7.8-70.1v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm2.4 1.6l-.9-.3 3.2-7.7-3.7-.2-.1-.5 2.4-.1h2.3v1l-3.2 7.8zm-6.8 51.9v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H326.5zm4.4-1.5c.2 0 .4.1.5.3.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm5.4.7l.3.8H332v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.7.2-1 .5c-.4.3-.6.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.7-.6.5 0 1 .2 1.4.5.4.4.5.8.5 1.5a4.8 4.8 0 01-.9 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm-5 124.9c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset07Chlorides = 'M386.7 28.6a1 1 0 01-.3.3l-.5.1-.5-.1h-.2c-.2 0-.4 0-.5-.2l-.4.1-.5-.1a.8.8 0 01-.3-.4l-.6-.1a.8.8 0 01-.4-.5c-.3-.2-.5-.6-.6-1.2l-.2-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4.1-.6.3-.9v-.2-.5l.4-.4v-.2l.1-.5.3-.2c0-.2.2-.3.3-.5l.6-.2c.2-.3.4-.4.6-.4l.4-.3h.5l.3-.1h1.1l.1.1h.3l.2.3c.2 0 .3 0 .5.2l.3.4v.3c.2 0 .4.2.4.4l.2.4a.6.6 0 01-.6.6c-.2 0-.4 0-.6-.2-.2-.2-.3-.3-.3-.6a1.1 1.1 0 01-.7-.4h-.3-.2l-.3.1h-.4c-.1.1-.3.3-.6.3l-.3.4-.5.1v.5l-.3.3-.1.1v.5c0 .2 0 .5-.2.9l.1.3.1.4v.1l.2.3v.4c.3 0 .6.2.7.3.2.2.3.3.3.5l.4-.2.4.1.2.3h.2l.4.1.4-.2.4-.2.2-.2a.9.9 0 01.6 0c.1-.2.3-.3.5-.3s.4 0 .6.2l.2.5-.3.6a1 1 0 01-.7.2 1 1 0 01-.2 0c.1 0 .1 0 0 .1l-.4.3a1 1 0 01-.5 0zm4.7-.5v.4l-.1.4a1 1 0 01-.6.1c-.2 0-.4 0-.5-.2a1 1 0 01-.2-.6c0-.2 0-.3.2-.4-.2-.1-.2-.3-.2-.6s0-.5.2-.6a.7.7 0 01-.2-.6c0-.2 0-.4.2-.6V25v-.4a.6.6 0 01-.1-.4V24v-.2-.3a.8.8 0 01-.1-.5v-.5a.7.7 0 010-.4v-.5-.4a1 1 0 010-.5v-.4a1 1 0 010-.4v-.5-.4-.4-.4-.3l.2-.4c.2-.2.3-.2.5-.2h.3l.3.4v3l.2.4-.1.3v.2l.1.3c0-.2.2-.3.3-.4h.4c0-.2 0-.3.2-.4a.7.7 0 01.6 0l.4-.2.3.1h.7l.4.1.4.2.2.3.3.5v.2l.1.2v.5c.2.1.3.2.3.5l-.2.4.2.4v1.7l-.1.6.1.5-.1.6v.9c0 .2-.1.3-.3.3l-.4.2-.4-.1-.1-.4a1 1 0 01-.2-.6l.1-.5v-.6-.5-.3-.4-.4-.2a.9.9 0 01-.1-.5v-.3l-.2-.4c0-.2 0-.3.2-.4-.2-.2-.3-.3-.3-.5v-.3h-.2a.6.6 0 01-.2-.3.9.9 0 01-.5 0l-.3.2h-.3l-.3.3-.3.1-.2.4-.3.2v.2l-.1.6.1.3-.1.4v.8l-.1.4.1.4v.4l-.1.4v.4l-.1.3zm8-1.1l.2.5v.5l-.3.3-.1.5-.5.2-.4-.1a.6.6 0 01-.2-.3l-.1-.5v-.6-.4l.1-.6-.1-.5.1-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4-.1-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3.1-.4v-.4-.3a.6.6 0 01-.2-.4c0-.2 0-.4.2-.5l.6-.2.3.1.2.4c.2 0 .3.3.3.5v.2l.1.5-.1.4.1.2v.3l-.1.5.1.4v1.1l-.1.2.2.5v.8l-.1.5.1.6-.1.7v.9l.1.5v.5zm6.3 1.8l-.6.2-.5-.1h-.5c-.4 0-.7 0-.9-.3h-.1a.6.6 0 01-.6-.3l-.4-.1-.2-.4a.8.8 0 01-.5-.3 1 1 0 010-.6.5.5 0 01-.4-.2 1 1 0 010-.5V26l-.2-.7.3-.6c-.2 0-.2-.2-.2-.3v-.4l.3-.2v-.4l.3-.3v-.1-.3l.3-.2v-.1c0-.3 0-.5.2-.6.2-.2.4-.3.5-.2 0-.2 0-.3.2-.4l.5-.2h.3l.3-.3.6-.2h.3l.6-.1.5.1.2.4c.2 0 .4 0 .6.2.2 0 .3.2.3.3l.8.5c.2.3.3.5.3.8v.2c.5 0 .7.5.6 1.4l.2.5-.2.6a.9.9 0 010 .7l-.3.2v.4l-.5.5v.2c0 .3-.1.5-.5.6 0 .2-.1.3-.3.4l-.5.2c-.1.2-.3.3-.6.3h-.2zm-1.5-1.1l.5-.1h.2a.9.9 0 01.7-.2l.6-.3h.1l.1-.3.2-.2.1-.3.3-.3.1-.5a.7.7 0 010-.6l.3-.3a.5.5 0 01-.2-.3l.1-.4-.4-.4V23c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.4l-.4-.1c-.2-.1-.2-.2-.2-.4h-.3c-.3 0-.5 0-.6-.2l-.5.3a1 1 0 01-.4 0c0 .2-.1.3-.3.5l-.5.2v.6l-.2.2c0 .2 0 .3-.2.5l-.3.3v.8s0 .2-.2.3c.3.2.4.5.4.8v.5h.1l.2.3c.2 0 .4.2.5.4l.5.1.3.3zm7.2.5c0 .3 0 .5-.2.6l-.5.2c-.1 0-.3 0-.4-.2a.6.6 0 01-.2-.4l.1-.5v-.4-.4l-.2-.1v-.3-.4a.6.6 0 010-.4l.1-.5v-.2-.2a1 1 0 01-.1-.6v-.5a.8.8 0 01-.2-.6l.1-.3v-.4l.1-.4-.2-.4.1-.5a1 1 0 01-.1-.4c0-.3 0-.4.2-.5l.2-.3.4-.2.4.3.2.6v.3l.2-.2h.3l.2-.2H412.5l.2-.1c.2 0 .3 0 .4.3l.6.1.5.1.3.3c.2.2.3.3.3.6l-.3.5-.5.2c-.2 0-.3-.1-.5-.3h-.3l-.1-.2h-1c0 .2-.2.3-.5.3V23.1l-.3.3.2.6c0 .2 0 .3-.2.4l.1.2.1.1v3.1l-.1.4zm4.5-10.6l-.3.3-.1.3c0 .2 0 .4.2.5 0 .2 0 .3.2.4.2.2.3.2.6.2h.3c.3-.2.5-.4.5-.7l-.2-.5c0-.2 0-.4-.2-.5a.6.6 0 00-.5-.2c-.2 0-.3 0-.5.2zm1 7l.3.4v1.5l-.1.4v1.4c0 .2 0 .4-.2.5l-.5.2c-.1 0-.3 0-.4-.2a.6.6 0 01-.2-.5l-.1-.3v-.4-.5-.7-.6-.3a3.9 3.9 0 010-1v-.3-.5-.7-.4l-.1-.3V22l-.1-.6.1-.6.1-.4h.4c.5 0 .8.2.8.8l.2.3V24.3l-.1.4zm6.3 3.5l-.2.2a1 1 0 01-.6 0c0 .2-.2.2-.4.3a1 1 0 01-.4.2h-.2-.3l-.4-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.3-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4v-.5-.4l-.2-.4-.1-.8.1-.7v-.4-.3l.1-.3v-.1-.2l.2-.2c0-.2 0-.4.2-.5 0-.2.2-.2.3-.3l.1-.4.3-.3.5-.2c.2-.3.5-.4.9-.4h.8l.5.1h.6l.2.2v-.2l.1-.5-.1-.4v-.1-.2l-.1-.2V19v-.3-.4a1 1 0 01.1-1c.2-.2.3-.3.5-.3s.4.1.5.3a.6.6 0 01.2.5c.2.2.2.3.2.6v.6l-.1.3a.7.7 0 010 .7l.1.4v1.8l-.1.6.2.5-.1.5-.1.3.2.6-.1.3.2.6-.2.6.2.6-.1.5-.2.2v.3l.2.5-.2.4-.5.2-.3-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.7h.6l.2-.2.4-.1h.2V27l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.3a.8.8 0 01-.2-.1h-.3-.3-.6-.2l-.3.3-.3.1-.1.3-.1.3-.3.1-.1.3v1.1c0 .5 0 .8-.2.9l.1.3.1.4v.3l.4.5s.2 0 .3.2l.6.3zm11.9-4.7l.3.4.1.7c0 .3-.1.6-.4.7-.1.1-.2.3-.4.3l-.5.2-.4-.1-.3.1H429a1 1 0 01-.5 0l-.6.1a1 1 0 01-.4 0l-.1.7c.2.2.3.4.2.6l.2.2c.1 0 .2.1.2.3.1 0 .3 0 .3.2.2 0 .2.2.2.3l.3-.1h.3v.1h.3l.4.1h.5l.3-.2.4-.1.4-.3h.4c.3 0 .5 0 .6.3l.1.3c0 .3-.1.5-.3.6-.1 0-.2 0-.3.2l-.4.2h-.3c-.1.2-.3.3-.6.3a1 1 0 01-.3 0l-.6.1H429.1l-.5-.2c-.5 0-.9-.1-1-.5l-.6-.3c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.4-.5v-.3h-.2v-.3-.2l-.1-.7.1-.5v-.4-.5l.2-.4.1-.2.2-.4.3-.2v-.2c0-.4.2-.7.6-.8 0-.2.2-.3.4-.5s.4-.3.5-.2c0-.2.2-.2.3-.3h.5c0-.2.2-.3.5-.4l.4-.1H430.8c0 .1.1.2 0 .2l.7.2.3.5h.5l.5.5c.2.2.3.5.3.8v.2zm-2.4 1l.8-.1h.5l-.2-.2a1 1 0 01-.1-.5v-.2h-.3a2.7 2.7 0 01-.5-.6l-.3-.1-.3-.3-.3.1a1 1 0 01-.3 0c0 .1 0 .2-.2.2h-.4c0 .3-.2.4-.3.6a1 1 0 01-.5.3c0 .1 0 .3-.2.5l-.3.4.7-.2h.4l.3.2c.2-.2.5-.3.8-.3.3 0 .5.1.7.3zm9.5 3.4v.3c0 .2 0 .4-.2.5 0 .1 0 .3-.2.4l-.4.3-.5.3h-1.1l-.6.1a2 2 0 01-.7-.1c-.2 0-.3-.2-.4-.3-.2 0-.4 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.2-.6v-.3-.4l.5-.1.4.2c.1 0 .3 0 .5.2l.2.5h.2l.4.1.2.3h.6l.3.2.4-.1h.4c0-.1.1-.2.3-.2h.3V27l.1-.5a.7.7 0 01-.3-.2V26h-.3c-.2 0-.3 0-.5-.2a1 1 0 01-.6-.2c-.2 0-.4-.2-.5-.4h-.2l-.6-.1a1 1 0 01-.3-.4l-.6-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 010-.4v-.2a.7.7 0 010-.8V22c0-.1 0-.3.2-.4 0-.1.1-.2.3-.2V21l.5-.3h.4l.2-.3h.3l.4.1.1-.1h.3a.7.7 0 01.4 0h.8l.2.3H439.2l.2.4c.2 0 .3 0 .5.2.2 0 .3.2.2.3.3.2.4.4.4.7l-.1.4c-.1.2-.3.2-.5.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.4a.8.8 0 01-.3-.4l-.3.1a1 1 0 01-.4 0h-.2l-.4.1h-.3v.3h-.4v.3c0 .2 0 .3-.2.5l.2.2.1.4h.1c.3 0 .5 0 .6.3h.2l.4.1c.2 0 .3.2.4.4h.5l.3.3h.3c.1 0 .3 0 .4.2.2 0 .3.2.3.3 0 0 .2 0 .2.2.1 0 .2.2.1.4h.2l.1.4v.2l.2.4v.3l-.2.1zm-41.7 166c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V193.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.8-.6l.2.5c-1.8.8-2.9 1.9-3.2 3.2l.9-.3a2 2 0 011.7.9c.4.6.7 1.4.7 2.3 0 .7-.2 1.2-.7 1.6-.4.4-.9.6-1.5.6s-1.1-.2-1.6-.6c-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.4.3-.1.5v.5l-.1.6zm4.6 2.7l-.1-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1 .3 1.5.7.5.4.7 1 .7 1.7a17 17 0 01-.1 2.3l-.3 1-.5 1-.7.8-1.1.7c-.4.3-1 .5-1.5.6zm3.4-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.4 1.8.4.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zm-22 79.9c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V271.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm8 4.5v.5l-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a9.7 9.7 0 01-1.6 0 18.7 18.7 0 00-1.5 0 5.3 5.3 0 000-.7v-.2a56 56 0 013.1-4.9c.3 0 .6 0 1 .2a185.5 185.5 0 00-.1 4.8h.8zm-4-.2l2.4.1a90.1 90.1 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zm9-4.9l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.5 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a25.5 25.5 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7 0 1.2.3 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zM400.5 89.2c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V89.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 83 83 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm4 8l-1-.3 3.2-7.7-3.7-.2v-.5l2.4-.1h2.3v1L414 93zm6.8-8.6l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.6-.6-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7a8 8 0 011.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm-19 206.6c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm8.6 5.5c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6 0-1.1.3-1.6s.6-.7 1-.8c-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .5 1.3.3.3.7.5 1.1.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3 0-.7-.4-1-.2-.3-.5-.5-1-.6zm3.4 8.2v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H417.6zM399.5 141c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V141.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm4 8l-1-.3 3.2-7.7-3.7-.2v-.5l2.4-.1h2.3v1L413 145zm3.2-.5l.1-.5h.5a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm-18.7-29.5c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V115.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.8 8.1l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.4-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.5-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1 .7-1.5.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.4-.3.1-.4a4 4 0 00.1-1.1zm6.8 3.4c0 .9-.2 1.5-.6 2-.5.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1.1.8.3.5.4 1 .4 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.3-.3-.6-.5-1-.6zm-20 212.3c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V323.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.7 4c0-1.7.2-3 .6-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.9.5l-.2.5a4.3 4.3 0 00-.3 1.7v.7l-.1.7a8.7 8.7 0 00.3 2c0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.5 7l.4.9h-4.8v-.3-.4l.8-1a44 44 0 012-2.1l.8-1.4c.3-.5.4-1 .4-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.8.2-1.1.5c-.3.3-.6.8-.7 1.5l-.5-.2c0-.7.2-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-.9 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.6 0zm-21.1-81c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V245.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm4 8l-1-.3 3.2-7.7-3.7-.2v-.5l2.4-.1h2.3v1L414 249zm3.7-.1v-.7a10.7 10.7 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H417.7zM399.5 167c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V167.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm4 8l-1-.3 3.2-7.7-3.7-.2v-.5l2.4-.1h2.3v1L413 171zm7.9-8.4v.5l-1.2.1h-1.4a55 55 0 01-.5 3l.7-.2c.7 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zM398.5 219c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V219.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5-2.4c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4l.2 1c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm7.8-.6l.2.5c-1.8.8-2.9 1.9-3.2 3.2l.9-.3a2 2 0 011.7.9c.4.6.7 1.4.7 2.3 0 .7-.2 1.2-.7 1.6-.4.4-.9.6-1.5.6s-1.1-.2-1.6-.6c-.4-.5-.6-1-.6-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.4.3-.1.5v.5l-.1.6zm8.7-5.8l.1.5-1.3.1h-1.4a55 55 0 01-.5 3l.7-.2c.7 0 1.3.3 1.8.9.6.5.8 1.1.8 1.8s-.2 1.3-.8 1.8c-.5.4-1.1.7-1.9.7-.7 0-1.5-.3-2.2-.8l.2-.3c.1-.3.2-.4.4-.4h.1c.5.5 1 .7 1.5.7s1-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.2-.4-.7-.5-1.2-.5h-.6a8 8 0 00-1-.4l.5-2.2c0-.7.2-1.3.4-1.8h3.2zM411.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset08Sulfur = 'M474.4 27.1v.3c0 .2 0 .4-.2.5 0 .1 0 .3-.2.4-.2.2-.3.3-.5.3l-.4.3H472l-.7.1a2 2 0 01-.6-.1c-.2 0-.4-.2-.4-.3-.2 0-.5 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.2-.6v-.3-.4l.4-.1c.2 0 .3 0 .4.2.2 0 .4 0 .5.2.2.2.3.3.3.5h.2l.4.1.2.3h.6l.3.2.4-.1h.4l.2-.2h.4l-.1-.4c0-.2 0-.4.2-.5a.7.7 0 01-.3-.2l-.1-.3h-.2c-.2 0-.4 0-.5-.2a1 1 0 01-.6-.2c-.2 0-.4-.2-.5-.4h-.2l-.6-.1a1 1 0 01-.4-.4l-.5-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 01-.1-.4v-.2a.7.7 0 01.2-.8V22v-.4l.3-.2.1-.4.4-.3h.4l.3-.3h.3l.4.1.1-.1h.3a.7.7 0 01.4 0h.7l.3.3H473.4l.2.4c.2 0 .3 0 .5.2.2 0 .2.2.2.3.3.2.4.4.4.7 0 .2 0 .3-.2.4 0 .2-.2.2-.4.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.5a.8.8 0 01-.2-.4l-.3.1a1 1 0 01-.4 0h-.3l-.3.1h-.3v.3h-.4v.3c0 .2 0 .3-.3.5.2 0 .3.1.3.2v.4h.2c.3 0 .5 0 .6.3h.1l.5.1c.2 0 .3.2.4.4h.5l.3.3h.2c.2 0 .4 0 .5.2.2 0 .2.2.3.3l.2.2.1.4h.2l.1.4v.2l.2.4v.3l-.2.1zm4 1.6a1 1 0 01-.3 0h-.4l-.4-.2a.8.8 0 01-.3-.3.8.8 0 01-.3-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2l-.1-.6v-.3c0-.1-.1-.3 0-.4a.6.6 0 01-.3-.7v-.4l.1-.4a.6.6 0 01-.2-.5v-.3a.8.8 0 010-.5V23l-.1-.4v-.3-.4c0-.3 0-.4.2-.6V21l.1-.5.5-.2.5.2.2.5-.1.6.2.5c0 .1 0 .3-.2.4l.1.4v1.5l.2.4V25.7l.1.2.1.2v.5l.1.3.2.1s.1.1 0 .2h.4l.2.2.6-.2h.3l.3-.2h.6l-.1-.5c0-.2 0-.3.2-.3l-.1-.6c0-.3 0-.6.2-.7a1 1 0 01-.2-.5l.1-.4v-.3-.4l.2-.3c-.2-.1-.2-.4-.2-.7v-.5l-.1-.5c0-.2 0-.4.2-.5l.4-.2c.2 0 .4.1.5.3.2.1.3.4.2.7l.2.2v.4l-.1.5c.2.2.2.4.2.7v1.5c0 .1 0 .3-.2.5l.2.4-.3.5.2.4-.1.7.1.4v.6c0 .2 0 .3-.2.4l-.5.2-.4-.1a.7.7 0 01-.2-.5v-.1a1 1 0 01-.5.1h-.2l-.4.2-.3-.1-.2.2h-.3-.1zm7-1.7l.1.5v.5l-.2.3c0 .2 0 .4-.2.5l-.5.2-.4-.1a.6.6 0 01-.2-.3l-.1-.5.1-.6v-.4-.6-.5-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4v-.4l.1-.6v-.6-.3l-.1-.2v-.3-.4-.4-.3a.6.6 0 01-.2-.4c0-.2.1-.4.3-.5l.5-.2.3.1.3.4.2.5v.2l.2.5c0 .1 0 .3-.2.4l.2.2v.3c0 .2 0 .4-.2.5l.1.4v1.1l-.1.2.2.5v1.9l-.1.7.1.4-.1.5.1.5v.5zm2.2-4.8l-.5-.2a.6.6 0 01-.2-.5c0-.2.1-.3.3-.5l.6-.1h.4v-.6-.4-.4c0-.3 0-.6.2-.8l.3-.4c.1-.2.3-.3.4-.3l.4-.4.7-.2.5-.1h1l.7.1c.3.2.4.4.4.6 0 .1 0 .3-.2.4l-.6.2-.4-.1h-.7l-.2.1h-.3c-.2.3-.4.4-.6.4v.5l-.2.4v.9h.2c.1 0 .3 0 .4.2l.4-.1h.4l.4.2.2.4c0 .2 0 .4-.2.5-.1.2-.3.2-.4.2h-1.2l-.2.1v.2l-.1.5V23.3l.2.4V25l.1.5v.4a.6.6 0 010 .7l.1.6c0 .2 0 .3-.2.4a32.2 32.2 0 00.2 1c0 .3-.2.5-.7.5-.2 0-.4-.2-.5-.5-.2-.3-.3-.6-.3-1 0-.2 0-.4.2-.5l-.2-.5v-.3-.3l.1-.4-.2-.2V25c0-.3 0-.4.2-.5l-.2-.6v-.3l.2-.2a1 1 0 01-.3-.7l.1-.4h-.3l-.4-.1zm8.5 6.5a1 1 0 01-.3 0h-.4l-.4-.2a.8.8 0 01-.3-.3.8.8 0 01-.3-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2l-.1-.6v-.3-.4a.6.6 0 01-.2-.7l-.1-.4.1-.4a.6.6 0 01-.2-.5v-.3a.8.8 0 010-.5V23l-.1-.4v-.3-.4c0-.3 0-.4.2-.6V21l.1-.5.5-.2.5.2.2.5-.1.6.2.5-.1.4v1.9l.2.4V25.7l.2.2v.5l.1.2v.3l.2.1.1.2h.4l.1.2.6-.2h.3l.4-.2h.5v-.5l.1-.3-.1-.6c0-.3 0-.6.2-.7a1 1 0 01-.2-.5l.1-.4v-.3-.4l.2-.3-.2-.7v-.5l-.1-.5c0-.2 0-.4.2-.5l.4-.2.6.3.2.7v.2l.2.4-.2.5c.2.2.3.4.3.7 0 .1 0 .2-.2.3l.2.4-.1.4v.4c0 .1 0 .3-.2.5l.2.4-.2.5.1.4-.1.7.1.4v.6c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5l-.1-.1a1 1 0 01-.5.1h-.1l-.4.2-.4-.1-.2.2h-.4zm6.5-.5l-.1.6-.5.2c-.2 0-.3 0-.5-.2a.6.6 0 01-.2-.4l.1-.5v-.4-.4l-.1-.1v-.3-.4a.6.6 0 01-.2-.4c0-.2.1-.4.3-.5v-.2-.2a1 1 0 01-.2-.6l.1-.5a.8.8 0 01-.2-.6V23v-.4l.1-.4-.2-.4.1-.5a1 1 0 010-.4c0-.3 0-.4.2-.5l.1-.3.4-.2.4.3.2.6v.3h.1l.2-.2h.3l.2-.2h.5l.3-.1s.2 0 .4.3l.5.1.5.1.3.3c.2.2.3.3.3.6 0 .1 0 .3-.2.5l-.5.2-.6-.3h-.2l-.2-.2h-.2-.8c0 .2-.2.3-.5.3V23.1l-.2.3v1.2l.1.1v3.5zm-33 19.9l-.3.2a1 1 0 01-.6 0c0 .2-.2.2-.4.3a1 1 0 01-.4.2h-.2-.3l-.4-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.3-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4v-.5-.4l-.2-.4-.1-.8v-.7-.4-.3l.2-.3v-.1-.2l.2-.2c0-.2 0-.4.2-.5 0-.2.2-.2.3-.3l.1-.4.3-.3.5-.2c.2-.3.5-.4.9-.4h.8l.5.1h.6l.2.2v-.2-.5-.4-.1-.2l-.1-.2V39v-.3-.4a1 1 0 01.1-1c.2-.2.3-.3.5-.3s.4.1.5.3a.6.6 0 01.2.5c.2.2.2.3.2.6v.6l-.1.3a.7.7 0 010 .7l.1.4v1.8l-.1.6.2.5-.1.5-.1.3.2.6-.1.3.1.6-.1.6.1.6v.5l-.2.2v.3l.2.5-.2.4-.5.2-.3-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.7h.5l.2-.2.4-.1h.2V47l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.3a.8.8 0 01-.2-.1h-.3-.3-.6-.2l-.3.3-.3.1-.1.3-.1.3-.3.1-.1.3v.2l-.1.4v1.7l.1.4v.3l.4.5s.2 0 .3.2l.6.3zm5.3-9.8l-.3.3-.2.3c0 .2.1.4.3.5 0 .2 0 .3.2.4.1.2.3.2.5.2h.4c.3-.2.4-.4.4-.7l-.1-.5-.2-.5a.6.6 0 00-.5-.2c-.2 0-.4 0-.5.2zm1 7l.2.4.1.5v1l-.1.4a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.3 0-.4-.2a.6.6 0 01-.2-.5l-.2-.3v-.4c0-.3 0-.5.2-.5l-.2-.7c0-.2 0-.4.2-.6l-.1-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.1-.7V42l-.1-.6.1-.6.1-.4h.4c.5 0 .8.2.8.8l.2.3v.3l-.1.6v.3l.1.4v1.2l-.2.4zm6 4.2l-.6.2-.5-.1h-.5c-.4 0-.7 0-1-.3a.6.6 0 01-.7-.3l-.4-.1-.2-.4a.8.8 0 01-.4-.3 1 1 0 01-.2-.6.5.5 0 01-.2-.2 1 1 0 01-.1-.5V46l-.1-.7c0-.2 0-.4.2-.6l-.2-.3.1-.4.2-.2v-.4l.3-.3v-.1-.3l.3-.2v-.1c0-.3.1-.5.3-.6.1-.2.3-.3.5-.2 0-.2 0-.3.2-.4l.5-.2h.2l.4-.3.6-.2h.3l.5-.1.5.1c.2.1.3.2.3.4.2 0 .3 0 .5.2.2 0 .3.2.4.3l.7.5c.2.3.4.5.4.8v.2c.4 0 .6.5.6 1.4l.1.5c0 .2 0 .4-.2.6a.9.9 0 010 .7l-.2.2-.1.4-.4.5v.2c0 .3-.2.5-.5.6 0 .2-.2.3-.3.4l-.5.2-.6.3h-.2zm-1.5-1.1l.4-.1h.2l.4-.2h.3l.6-.3h.2v-.3l.3-.2v-.3l.3-.3c0-.2 0-.3.2-.5a.7.7 0 010-.6l.2-.3a.5.5 0 01-.1-.3v-.4l-.4-.4V43l-.4-.2a.8.8 0 01-.1-.4l-.5-.1-.2-.4h-.3c-.2 0-.4 0-.6-.2l-.4.3h-.5c0 .2-.1.3-.3.5l-.4.2v.6l-.3.2-.1.5-.3.3v.2l-.1.3v.3l-.1.3c.2.2.4.5.4.8l-.1.5h.2l.1.3c.3 0 .5.2.6.4l.4.1.4.3zm8.8-1.6l-.1.4-.3.2c0 .3-.2.6-.5.7 0 .2 0 .4-.2.6l-.4.5c0 .2-.2.4-.3.5-.2.2-.3.3-.5.3s-.3 0-.4-.2a.6.6 0 01-.2-.5c0-.2 0-.4.3-.7l.1-.5.4-.4.1-.5c.1-.2.2-.2.4-.2v-.4c.1-.2.2-.3.4-.3l.2-.4.2-.3a.6.6 0 01-.3-.6c-.2 0-.3 0-.5-.2a.7.7 0 01-.1-.7c-.1 0-.2 0-.3-.2a.5.5 0 01-.1-.4 2 2 0 01-.4-.2l-.2-.3a1 1 0 01-.5-.6c-.3-.3-.5-.5-.5-.8v-.3c.2-.3.3-.5.6-.5.2 0 .4.1.5.3l.4.5.6.3.3.6v.1c.3.2.5.5.6 1 .2 0 .3.1.5.3l.2.5.2-.2.1-.2.3-.2v-.4l.4-.3v-.2-.4h.3c0-.3 0-.5.2-.6l.4-.2c0-.2 0-.4.2-.5.1-.2.3-.2.5-.2s.3 0 .4.3l.2.4c0 .2 0 .4-.3.5V42.1l-.4.2c0 .2 0 .3-.3.3 0 .4-.2.8-.6 1a1 1 0 01-.6 1v.5l.2.3c.2 0 .2.2.2.4 0 0 .2 0 .3.2l.1.3c.4.2.6.4.6.7v.2s.2 0 .3.2l.1.4.2.1.1.4v.3l.1.3-.1.3-.4.2c-.4 0-.6-.3-.8-.8-.2 0-.3-.2-.4-.4l-.3-.6-.5-.5-.3-.6a.5.5 0 01-.4-.4zm5-8.5c-.2 0-.3.1-.3.3l-.2.3c0 .2 0 .4.2.5 0 .2 0 .3.3.4.1.2.3.2.5.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4.1.5-.1.5v.9a1.7 1.7 0 010 1.2v.2c0 .2 0 .4-.2.5l-.5.2c-.2 0-.3 0-.5-.2a.6.6 0 01-.1-.5l-.2-.3v-.4c0-.3 0-.5.2-.5l-.2-.7.1-.6v-.3a4 4 0 010-1v-.3-.5-.7a1.5 1.5 0 01-.1-.7V42l-.1-.6v-.6l.2-.4h.4c.5 0 .7.2.7.8l.3.3v.3l-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3.5l-.2.2a1 1 0 01-.7 0c0 .2-.1.2-.3.3a1 1 0 01-.4.2h-.5l-.4-.1a.8.8 0 01-.4-.2 1 1 0 01-.5-.1l-.2-.3-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.4-.4l-.1-.5v-.4l-.2-.4V45v-.7-.4-.3l.2-.3v-.1-.2l.2-.2.1-.5c.1-.2.3-.2.4-.3v-.4l.4-.3.5-.2c.2-.3.5-.4.8-.4h.8l.6.1h.5l.3.2v-.2-.5-.4-.1l-.1-.2v-.2-.3-.3-.4a1 1 0 01.1-1c.1-.2.3-.3.5-.3s.3.1.5.3a.6.6 0 01.2.5l.2.6-.1.3v2.5l.1.3v.7l-.1.6.1.5v.5l-.1.3.1.6v.3l.1.6-.1.6.1.6v.5l-.2.2v.3l.1.5-.1.4-.5.2-.4-.1a.7.7 0 01-.2-.5v-.2l-.1-.1zm-2-.7h.6c0-.1 0-.2.2-.2l.4-.1h.2V47l.2-.2.2-.2v-.3l.1-.5-.1-.5.1-.7v-.7-.6l-.2-.7.1-.4h-.3a.8.8 0 01-.3-.1h-.5-.7-.1l-.4.3-.3.1v.3l-.2.3-.2.1c0 .2 0 .3-.2.3v1.1l-.1.9.1.3.1.4v.3c.1.1.3.3.3.5.1 0 .2 0 .3.2.3 0 .5.1.7.3zm11.8-4.7l.3.4.2.7c0 .3-.2.6-.5.7l-.3.3-.5.2a1 1 0 01-.4-.1l-.4.1h-1-.5a1 1 0 01-.4 0h-.5a1 1 0 01-.5 0l-.6.1a1 1 0 01-.4 0l-.1.7c.2.2.2.4.2.6l.2.2s.2.1.2.3c.1 0 .2 0 .3.2l.2.3.3-.1h.2l.1.1h.3l.4.1h.5l.3-.2.4-.1.3-.3h.5c.3 0 .5 0 .6.3v.3c0 .3 0 .5-.3.6l-.2.2-.4.2h-.3c-.1.2-.4.3-.6.3a1 1 0 01-.3 0l-.6.1h-.5-.2l-.4-.2c-.5 0-1-.1-1.1-.5-.2 0-.3-.1-.5-.3-.2-.2-.3-.3-.3-.5a.7.7 0 01-.5-.5v-.3l-.1-.3V46l-.1-.7V45v-.4l.1-.5.2-.4v-.2l.3-.4.3-.2v-.2c0-.4.2-.7.6-.8 0-.2.1-.3.3-.5.2-.2.4-.3.6-.2 0-.2.1-.2.3-.3.2 0 .3-.1.4 0l.5-.4.5-.1H507l.2.2.6.2c.1 0 .2.2.2.5h.6l.5.5c.2.2.3.5.3.8v.2zm-2.3 1l.8-.1h.5l-.2-.2a1 1 0 01-.1-.5v-.2h-.4a2.7 2.7 0 01-.4-.6l-.4-.1-.2-.3-.3.1a1 1 0 01-.3 0l-.2.2h-.4l-.3.6a1 1 0 01-.5.3c0 .1 0 .3-.2.5l-.3.4.6-.2h.5l.2.2.9-.3c.3 0 .5.1.7.3zM483.5 197v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H483.5zm4.3 0v-.7a10.7 10.7 0 001.3-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 114.6 114.6 0 01.1 8l.5.2h.7l.2.7h-3.7zm-1.4 77.2l.4.8H482v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm4.7 0l.4.8h-4.8v-.3-.4l.8-1a44 44 0 012-2.1l.8-1.4c.3-.5.4-1 .4-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.8.2-1 .5c-.4.3-.7.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-.9 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.6 0zM483.5 93v-.7a9.9 9.9 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3a212.1 212.1 0 002.4-1.7h.4a115 115 0 01.1 8l.5.2h.6l.2.7H483.5zm8.1-.8l.4.8h-4.8v-.3-.4l.8-1a43 43 0 012-2.1l.8-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-.9-.4-.4 0-.8.2-1.1.5-.3.3-.6.8-.7 1.5l-.5-.2c0-.7.2-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 11.9 11.9 0 001.6 0 27 27 0 011.6 0zm-9 208.8v-.7a10.5 10.5 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H482.5zm8.4-3.4l.2.5-1 .1.1 1.4.1 1.3c0 .3-.2.4-.4.4-.1 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.5 5.5 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.1 4.8h.7zm-3.9-.2l2.4.1a79 79 0 000-4l-1.3 2.1-1.1 1.8zM482.5 145v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H482.5zm8.5-3.4l.2.5-1 .1.1 1.4.1 1.3c0 .3-.2.4-.4.4-.1 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.5 5.5 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.1 4.8h.7zm-3.9-.2l2.4.1a79 79 0 000-4l-1.3 2.1-1.1 1.8zm-4.6-22.4v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H482.5zm8.4-8.5l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.5 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7 0 1.2.3 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5a3.7 3.7 0 000 1zm-5 210.5v-.7a10.5 10.5 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H482.5zm8.3-8.5l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.5 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7 0 1.2.3 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5a3.7 3.7 0 000 1zm-6-75.5v-.7a10.5 10.5 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H481.5zm9-2.4c0 .9-.1 1.5-.5 2-.4.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.3 1.2-.3.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.3 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.2-.5a2 2 0 00-1.1.6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zm3.2-72.2c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.5-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5 0 .8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm-2.5 60.4l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zM488.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset09Density = 'M538.7 28c0 .2-.2.2-.3.3a1 1 0 01-.6 0c0 .2-.2.2-.3.3a1 1 0 01-.5.2h-.2-.2l-.5-.1a.8.8 0 01-.3-.2 1 1 0 01-.5-.1c-.2 0-.2-.2-.3-.3l-.4-.1a.6.6 0 01-.2-.5.8.8 0 01-.3-.4l-.2-.5.1-.4-.2-.4V25v-.7-.4-.3c0-.1 0-.2.2-.3v-.1-.2l.2-.2.1-.5.3-.3.1-.4.4-.3.4-.2c.2-.3.5-.4.9-.4h.8l.6.1h.5l.2.2v-.2l.1-.5V20v-.1l-.1-.2v-.2-.3l-.1-.3v-.4a1 1 0 01.2-1c0-.2.3-.3.5-.3l.4.3a.6.6 0 01.2.5c.2.2.3.3.3.6l-.1.3v.6a.7.7 0 01-.1.7l.1.4V22l.1.3c0 .3 0 .5-.2.6l.2.5v.5l-.2.3.2.6-.1.3.2.6c0 .2 0 .4-.2.6l.2.6-.1.5-.2.2.1.3v.9l-.5.2-.4-.1a.7.7 0 01-.2-.5l-.1-.2v-.1zm-2-.6H537.3c0-.1 0-.2.2-.2l.3-.1h.2V27l.3-.2.2-.2v-.3-.5-.5-.7-.7-.6l-.1-.7v-.4h-.2a.8.8 0 01-.3-.1h-.3-.9-.2l-.3.3-.3.1-.1.3-.1.3-.2.1c0 .2-.1.3-.2.3v1.1c0 .5 0 .8-.2.9l.2.3v.7l.4.5c.1 0 .2 0 .3.2.3 0 .5.1.7.3zm11.8-4.7l.3.4.2.7c0 .3-.2.6-.5.7-.1.1-.2.3-.4.3l-.4.2-.5-.1-.3.1h-2.5a1 1 0 01-.4 0l-.7.1a1 1 0 01-.4 0v.7l.2.6.1.2.3.3s.2 0 .3.2l.2.3.2-.1h.3l.1.1h.3l.3.1h.6l.2-.2.4-.1.4-.3h.4c.3 0 .5 0 .7.3v.3c0 .3 0 .5-.3.6 0 0-.2 0-.3.2l-.3.2h-.3c-.2.2-.4.3-.7.3a1 1 0 01-.3 0l-.5.1h-.5-.2l-.4-.2c-.6 0-1-.1-1.1-.5l-.6-.3-.3-.5a.7.7 0 01-.4-.5v-.3h-.1v-.3-.2l-.2-.7.1-.5v-.4-.5l.3-.4v-.2l.2-.4.3-.2v-.2c0-.4.2-.7.7-.8 0-.2 0-.3.3-.5.2-.2.4-.3.6-.2 0-.2 0-.2.3-.3.1 0 .3-.1.4 0 0-.2.2-.3.5-.4l.4-.1h.7l.1.2.6.2c.2 0 .3.2.3.5h.5l.6.5.2.8v.2zm-2.4 1l.8-.1h.6l-.3-.2a1 1 0 010-.5v-.2h-.4a2.7 2.7 0 01-.5-.6l-.3-.1-.3-.3-.2.1a1 1 0 01-.4 0c0 .1 0 .2-.2.2h-.3l-.4.6a1 1 0 01-.4.3l-.2.5-.4.4.7-.2h.4l.3.2c.3-.2.5-.3.9-.3l.6.3zm6.8-1.5s0 .2-.2.3l-.3.1c0 .2-.3.4-.6.4v.5l-.4.2-.1.8v.3l-.1.5v3.1c0 .2-.1.3-.3.5l-.5.1-.5-.1a.5.5 0 01-.1-.5v-.3-.6a.7.7 0 01-.1-.4v-.4a.7.7 0 010-.7l.2-.2a.9.9 0 01-.2-.6c0-.2 0-.4.2-.5l-.2-.2V24l.1-.3-.1-.6v-.5-.6-.4a1 1 0 01-.2-.7c0-.3.1-.5.4-.7h.4c.2 0 .4 0 .5.2l.2.6v.3l.1.6v.3c0-.3.2-.4.4-.5 0-.2 0-.4.2-.6 0-.1.2-.3.4-.3.2-.1.3-.2.4-.1.3-.3.6-.5 1-.5l.3.1h.9c.1 0 .2.1.2.3.4 0 .7.1.8.4.2 0 .3.1.4.3.2.1.3.3.3.5l-.1.3c.2.1.3.3.3.6v.2c.2 0 .3.1.3.2l.1.3v.5l.1.5c0 .2 0 .4-.2.5l.2.6c0 .3 0 .4-.2.6l.1.7-.1.4.1.6c0 .2 0 .4-.2.5 0 .2 0 .3-.2.4l-.5.2-.4-.1a.4.4 0 01-.2-.3v-.7c0-.4 0-.7.2-.9l-.2-.4v-.7-.5a1 1 0 010-.5l.1-.7a1 1 0 01-.3-.8v-.1l-.3-.5-.1-.6h-.3a.6.6 0 01-.2-.3h-.2l-.4-.1-.4.3h-.5zm11.2 5v.2c0 .2 0 .4-.3.5l-.1.4c-.2.2-.3.3-.5.3l-.4.3h-1.1l-.7.1a2 2 0 01-.7-.1c-.2 0-.3-.2-.3-.3-.2 0-.5 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.2-.6l-.1-.3.1-.4.4-.1c.2 0 .3 0 .4.2.2 0 .4 0 .5.2.2.2.3.3.3.5h.2l.4.1.2.3h.6l.3.2.4-.1h.4l.2-.2h.4l-.1-.4c0-.2 0-.4.2-.5a.7.7 0 01-.3-.2l-.1-.3h-.2c-.2 0-.4 0-.5-.2a1 1 0 01-.6-.2c-.2 0-.4-.2-.5-.4h-.2l-.6-.1a1 1 0 01-.4-.4l-.5-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 01-.1-.4v-.2a.7.7 0 01.2-.8l-.1-.4.1-.4.3-.2.1-.4.4-.3h.4l.3-.3h.3l.4.1.1-.1h.3a.7.7 0 01.4 0h.7l.3.3h.5c.2.1.2.3.3.4.1 0 .3 0 .5.2.2 0 .2.2.2.3.3.2.4.4.4.7 0 .2 0 .3-.2.4 0 .2-.2.2-.4.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.5a.8.8 0 01-.2-.4l-.3.1a1 1 0 01-.4 0h-.3l-.3.1h-.3l-.1.3h-.4v.3c0 .2 0 .3-.2.5.2 0 .2.1.3.2v.4h.2c.3 0 .5 0 .6.3h.1l.5.1c.2 0 .3.2.4.4h.4l.4.3h.2c.2 0 .4 0 .5.2.2 0 .2.2.2.3.1 0 .2 0 .3.2 0 0 .1.2 0 .4h.3l.1.4v.2l.2.4v.3l-.2.1zm1.6-9.6c-.2 0-.3.1-.4.3v.3l.1.5c0 .2 0 .3.2.4.2.2.4.2.6.2h.4c.3-.2.4-.4.4-.7 0-.1 0-.3-.2-.5 0-.2 0-.4-.2-.5a.6.6 0 00-.4-.2c-.2 0-.4 0-.5.2zm1 7l.2.4v3.3c0 .2 0 .4-.2.5l-.5.2c-.2 0-.4 0-.5-.2a.6.6 0 01-.2-.5V28l-.1-.4.1-.5v-.7-.6-.3a3.9 3.9 0 010-1v-.3-.5-.7l-.1-.4v-.3-.3l-.2-.6c0-.2 0-.4.2-.6v-.4h.5c.5 0 .7.2.7.8l.2.3.1.3-.1.6v.3l.1.4v1.2l-.2.4zm6.3 3l.2-.1h.2c.2 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1c-.2-.1-.2-.2-.2-.3a.9.9 0 01-.5-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4l-.2-.5v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4-.4a1 1 0 010-.8l.2-.2a.7.7 0 01-.2-.4v-.3a1 1 0 01-.3 0h-.4-.3c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.5l.1-.4.5-.2h2v-.5l.1-.3-.1-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.5c.1 0 .2 0 .3.2l.5.1.1.4c0 .1 0 .3-.2.5l-.4.2-.3-.1-.4.1-.4-.1a1 1 0 01-.3 0h-.3l.1.4c0 .1 0 .3-.2.4l.2.5c0 .2 0 .3-.2.5l.2.4-.1.4.1.6V26l.2.4c.2.2.3.3.3.5.2.1.3.3.3.6v.1h.2l.4.1h.4zm6.7-1.5l-.3.3c0 .5-.1.7-.4.8 0 .2 0 .4-.2.6a1 1 0 01-.4.4v.2l-.1.3-.2.3c0 .4-.1.7-.6 1.1 0 .3 0 .5-.2.6a1 1 0 01-.6.3c0 .2 0 .3-.3.4a1 1 0 01-.6.3l-.5.3c-.3.2-.5.2-.6.1-.2 0-.4 0-.6-.2a.7.7 0 01-.2-.5l.1-.4.4-.1h.1c.3-.3.6-.4.7-.4h.2s0-.2.2-.3l.5-.3v-.3l.4-.3v-.1c0-.2 0-.4.2-.6l.4-.4a.6.6 0 01-.4-.5l-.3-.3-.1-.4v-.3a.7.7 0 01-.3-.2l-.1-.5v-.3l-.3-.3-.1-.3c-.2-.1-.2-.3-.2-.5v-.3a1.3 1.3 0 01-.4-1.2.8.8 0 01-.3-.3 1 1 0 010-1c-.3 0-.4-.3-.4-.5 0-.3 0-.5.3-.7h.3l.5.1.3.4.2.4a1.5 1.5 0 010 .7c.4.4.6.7.6 1v.3l.2.3.1.4.2.4v.3c.2 0 .3.1.3.3l.1.4c.2 0 .3.2.3.3v.4c.2 0 .2.2.2.4l.1-.4.2-.2v-.3-.2l.2-.2c0-.2 0-.4.2-.5v-.2-.3l.2-.2-.1-.4v-.4l.3-.3-.1-.6c0-.3 0-.6.2-1v-.3-.3a.8.8 0 01.8-.8c.2 0 .3 0 .4.2.2 0 .2.3.2.5l.1.5c0 .4 0 .7-.3 1l.1.5c0 .2 0 .5-.3.7v.3l.1.3-.1.5c0 .1 0 .4-.4.9l.1.3v.3zm-32.2 167c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V193.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm6.8 3.4c0 .9-.2 1.5-.6 2-.4.3-1 .6-2 .6-1.5 0-2.4-.9-2.4-2.6 0-.6.2-1.1.4-1.6.3-.5.6-.7 1-.8-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5-.1 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.4-.7.4-1.2s-.1-.9-.4-1.2c-.4-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .4 1.3.4.3.7.5 1.2.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.1.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zm4.3 8.3l-.9-.3 3.2-7.7-3.7-.2-.1-.5 2.4-.1h2.3v1l-3.2 7.8zm3.9.1l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.5.7.5.4.7 1 .7 1.7a16.9 16.9 0 01-.1 2.3l-.3 1-.5 1-.7.8-1.1.7c-.4.3-1 .5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM546.5 271c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V271.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm6-2.7l.1.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.4 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm4.5-1.4c0-1.7.3-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.3 1.3v1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7-.3.5-.8.7-1.2.7-1.8 0-2.8-1.4-2.8-4.3zm2.5-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7v.7l-.1.7a8.7 8.7 0 00.3 2c0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-24.4-178c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V89.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zM566 93l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1L566 93zm8.6-2.5c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.5-.9-2.5-2.6 0-.6.2-1.1.4-1.6.3-.5.6-.7 1-.8-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .5 1.3.3.3.7.5 1.1.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.5-.5-1-.6zM548.5 297c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm6.1 2.4l.1.5-.8.1v2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.2 4.8h.8zm-4-.2l2.4.1a83 83 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm4.4 3.2v-.5h.6a11.1 11.1 0 001.4.3c.4 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.7 0 1.3-.1 1.8-.4.4-.2.6-.6.6-1.2 0-.4 0-.7-.3-1-.2-.2-.6-.3-1-.3h-1.1l-.5.1-.2-.5a10.8 10.8 0 001-.3h1c.6 0 1 .1 1.4.5.4.5.5 1 .5 1.8 0 .4 0 .8-.3 1-.2.4-.6.6-1 .6.5.2.8.5 1 1 .3.4.4.9.4 1.5a3 3 0 01-.4 1.7c-.4.4-.8.7-1.5.7-.9 0-1.7-.2-2.4-.5zm-24.3-159.5c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V141.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm6.8 3.4c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm3.3 4.3c0-1.7.2-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .6 0 1 .3.2.2.5.5.6.8l.5 1.1.2 1.3.1 1.3c0 .6 0 1.2-.3 1.9-.1.6-.4 1.2-.8 1.7s-.8.7-1.3.7c-1.8 0-2.7-1.4-2.7-4.3zm2.5-4a1.7 1.7 0 00-1 .5c0 .2 0 .3-.2.5a4.2 4.2 0 00-.3 1.7 75.8 75.8 0 010 2.4l.2 1c.1.4.3.7.5.9.3.2.5.3.9.3s.8-.3 1.1-1c.4-.6.5-1.3.5-2 0-2.8-.6-4.2-1.7-4.2zm-23-22c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V115.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2.8 5.9l-1-.3 3.2-7.7-3.7-.2-.1-.5 2.5-.1h2.3v1L568 119zm6.8-8.6l.2.5c-1.8.8-3 1.9-3.3 3.2.3-.2.7-.3 1-.3a2 2 0 011.7.9c.4.6.6 1.4.6 2.3 0 .7-.2 1.2-.6 1.6-.4.4-.9.6-1.5.6s-1.2-.2-1.6-.6c-.5-.5-.7-1-.7-1.8a25.5 25.5 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.3 6c0 .7 0 1.2.3 1.6.3.3.6.4 1 .4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.1.5-.1.5v.6zm-22.1 206.6c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V323.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm1.8 5.8v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H567.1zm8.5-3.4l.2.5-1 .1.1 1.4.1 1.3c0 .3-.2.4-.4.4-.1 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 5.3 5.3 0 000-.7v-.2a56 56 0 013.2-4.9c.3 0 .6 0 1 .2a173.8 173.8 0 00-.1 4.8h.7zm-3.9-.2l2.4.1a84.2 84.2 0 000-4l-1.3 2.1-1.1 1.8zm-23.2-78.3c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V245.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm6.8 3.4c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm3.4 8.2v-.7a10.7 10.7 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 115.1 115.1 0 01.1 8l.5.2h.7l.2.7H572zM548.5 167c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V167.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm5.5-2.5l.2.5-1.4.1h-1.4a53 53 0 01-.4 3l.6-.2c.7 0 1.3.3 1.9.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3c0-.3.2-.4.3-.4h.1c.6.5 1.1.7 1.6.7s.9-.2 1.2-.6c.3-.4.4-.8.4-1.3 0-.4-.1-.8-.4-1.1-.3-.4-.7-.5-1.3-.5h-.6a8 8 0 00-1-.4l.5-2.2.5-1.8h3.1zm5.3 4.9l.1.5-.8.1a525.6 525.6 0 010 2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a185.5 185.5 0 00-.2 4.8h.8zm-4-.2l2.4.1a83 83 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm-21.6 51.7c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V219.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm2 6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.6.7.4.4.6 1 .6 1.7a17.6 17.6 0 01-.1 2.3c0 .4-.2.8-.3 1l-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm1.8 5.8v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H567.1zm8.1-.8l.4.8h-4.8v-.3-.4l.8-1a44 44 0 012-2.1l.8-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-.9-.4-.4 0-.8.2-1.1.5-.3.3-.6.8-.7 1.5l-.5-.2c0-.7.2-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.6 0zM562.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset10Ph = 'M610.8 23.3l.1.5v.2l.1.3v1.5c0 .2 0 .4-.3.5V27.2l-.3.4c0 .2 0 .4-.3.6-.1.2-.3.3-.5.3l-.3.3-.5.1H607.6a.7.7 0 01-.3-.2h-.2l-.5-.1v.2l-.1.3v.3l-.1.6.1.2.1.4-.1.4v.5c0 .2 0 .4-.2.5 0 .2-.2.2-.4.2l-.5-.1a.9.9 0 01-.2-.5l-.1-.2V31v-.5-.7-.7-.5-.4-.3l-.1-.3v-.3-.3-.3l.2-.3-.2-.7c0-.3 0-.5.2-.6a2 2 0 01-.3-.8c0-.2 0-.3.2-.4v-.3-.3a1 1 0 01-.1-.5c0-.3 0-.5.2-.6-.2-.3-.2-.6-.2-.9l.1-.5v-.2c0-.2 0-.3.2-.4.2-.2.3-.2.5-.2h.4l.2.4.4-.2h.4l.5-.2h.7l.3.1.2.1h.3l.2.3h.3l.1.2h.2l.1.3c.2.2.3.5.4 1l.2.3.1.5v.4zm-2.4 4.2l.3-.3.3-.1c0-.3.1-.5.3-.7V26c0-.3 0-.5.3-.7a4.1 4.1 0 010-1 1 1 0 01-.3-.4l-.1-.6V23l-.2-.4v-.5c-.1 0-.2 0-.3-.2l-.2-.2h-.3l-.2-.2-.3.1a1 1 0 01-.4 0 1 1 0 01-.5.2c-.1 0-.3 0-.4-.2l.2.6-.1.6V24l.1.8-.1.6V27.3h.6l.5.2h.8zm12.1-5.7v.4c.2 0 .3 0 .4.2l.2.4c0 .2 0 .3-.2.5l-.3.2v1.9l-.1.2.1.6v.7l-.1.6v.7c0 .2 0 .4-.2.6l-.4.2h-.3c-.2-.2-.3-.4-.3-.8v-.5l-.1-.7c0-.2 0-.5.2-.7-.2-.2-.2-.4-.2-.7l.1-.5v-.4-.3a2.7 2.7 0 010-1l-.3.1h-.5l-.2-.1-.4.1-.4-.1h-1.7l-.6.1c-.2 0-.4 0-.6-.2l.2.5-.1.5.2.5-.1.4.1.5-.1.5.2.6c0 .2 0 .3-.2.5l.1.6v.4l-.2.4c-.1.2-.3.2-.5.2l-.4-.1a.5.5 0 01-.2-.5v-.2a.8.8 0 01-.2-.6l.1-.2.2-.3-.1-.3-.1-.5v-.4-.2l-.1-.3v-.4a1.2 1.2 0 010-.7V24v-.5l-.1-.7.1-.6-.1-.6v-.4-.5-.3l-.1-.3v-.4l.1-.5v-.2-.2a.6.6 0 01-.1-.4c0-.2 0-.3.2-.4.1-.2.3-.2.5-.2h.3l.2.4c.2.2.3.3.3.5l-.1.3v.5l-.2.2c.2.2.3.3.3.5s0 .3-.2.5l.2.4-.1.4.2.5-.1.2h3.4l.5-.1c.3 0 .6 0 .7.2V22v-.4-.4-.3-.2-.3-.4-.3-.2l.1-.4v-.2-.3-.4l.1-.4.5-.2.3.1.2.4c.2 0 .2.2.2.5V21.4l-.2.4zM606 196.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H607l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5 1.4v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.8-.7.6-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 010 8l.6.2h.6l.2.7H613zm8.4-8.5l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a25.3 25.3 0 01.1-2.3 5.4 5.4 0 01.8-2l.8-.8 1-.7 1.5-.6zm-3.4 6c0 .7.2 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.6-.7-1-.7a1 1 0 00-.6 0l-.3.3-.2.5v1.1zm-11 80.1v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H608l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1 1v-.5h.6a11 11 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.8 0 1.3-.1 1.8-.4.4-.2.7-.6.7-1.2 0-.4-.2-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.5.1-.1-.5a10.4 10.4 0 00.9-.3h1c.6 0 1 .1 1.4.5.4.5.6 1 .6 1.8 0 .4-.2.8-.4 1-.2.4-.5.6-1 .6.5.2.8.5 1 1 .3.4.5.9.5 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.4.4v-.7a10.7 10.7 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.5-.6a6.6 6.6 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.7l.2.7h-3.7zm-7.5-182.8l.4.8H607v-.3-.4l.7-1a45 45 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 11.9 11.9 0 001.6 0 27 27 0 011.7 0zm1-.7c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm5.6-6.8l.2.5-1.3.1h-1.5c0 1-.2 1.9-.4 3l.6-.2c.7 0 1.3.3 1.9.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3c0-.3.2-.4.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.4-.8.4-1.3 0-.4-.1-.8-.4-1.1-.3-.4-.7-.5-1.3-.5h-.6a8 8 0 00-1-.4l.5-2.2.5-1.8h3.1zm1 8.3v-.7a10 10 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3A147.3 147.3 0 00621 84h.4a116.8 116.8 0 01.1 8l.5.2h.7l.1.7H619zm-13 207.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H607l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.6 1.6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1l-.9.3a2 2 0 01-1.7-1c-.4-.5-.7-1.3-.7-2.3 0-.6.2-1.2.7-1.6.4-.4.9-.6 1.5-.6s1.1.3 1.6.7c.4.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.2.8-.3 1 0 .4-.3.7-.5 1l-.7.8-1 .7-1.5.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.1.7l.6-.1.3-.3.1-.4a4 4 0 00.1-1.1zm2.8 5.9l-1-.3 3.2-7.7-3.7-.2v-.5l2.4-.1h2.3v1l-3.2 7.8zM607 144.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H608l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm2.4 1.5l-.9-.3 3.2-7.7-3.7-.2-.1-.5 2.4-.1h2.3v1l-3.2 7.8zm6.9-8.6l.2.5c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.5 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a25.3 25.3 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.4 6c0 .7.2 1.2.4 1.6.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.3-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zM607 118.7v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H608l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm5.4.6l.3.8h-4.7v-.3-.4l.7-1a42.1 42.1 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.8-.4-.4 0-.8.2-1.2.5-.3.3-.5.8-.7 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.7-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.4 28.4 0 011.7 0zm.9.8v-.7a10.7 10.7 0 001.3-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 114.6 114.6 0 01.1 8l.5.2h.7l.2.7h-3.7zM606 326.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H607l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.5 1.4v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.8-.7.6-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 010 8l.6.2h.6l.2.7H613zm4.2-3.9c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3.3.2.6.5.7.8l.5 1.1.2 1.3.1 1.3c0 .6 0 1.2-.3 1.9-.2.6-.4 1.2-.8 1.7s-.8.7-1.3.7c-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.2 1v.7l-.1.7v.7a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .4-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zM605 248.7v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H606l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1.6 1.6l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1l-.9.3a2 2 0 01-1.7-1c-.4-.5-.7-1.3-.7-2.3 0-.6.2-1.2.7-1.6.4-.4.9-.6 1.5-.6s1.1.3 1.6.7c.4.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.2.8-.3 1 0 .4-.3.7-.5 1l-.7.8-1 .7-1.5.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.1.7l.6-.1.3-.3.1-.4a4 4 0 00.1-1.1zm6.8 3.4c0 .9-.2 1.5-.6 2-.4.3-1 .6-2 .6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.4 0-.8-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.8.6.5.4.7 1 .7 1.8 0 .5-.1 1-.3 1.2-.3.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.1-.9-.5-1.2c-.3-.4-.7-.5-1.2-.5a2 2 0 00-1.1.6c-.2.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.5 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.6-.5-1-.6zM606 170.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H607l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1 1v-.5h.6a11 11 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.8 0 1.3-.1 1.8-.4.4-.2.7-.6.7-1.2 0-.4-.2-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.5.1-.1-.5a10.4 10.4 0 00.9-.3h1c.6 0 1 .1 1.4.5.4.5.6 1 .6 1.8 0 .4-.2.8-.4 1-.2.4-.5.6-1 .6.5.2.8.5 1 1 .3.4.5.9.5 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.4.6l-.2-.5c1.9-.8 3-1.8 3.3-3.1-.3.2-.7.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1 .3 1.5.7.5.4.7 1 .7 1.7a16.9 16.9 0 01-.2 2.3l-.2 1-.5 1-.8.8-1 .7-1.5.6zm3.4-6c0-.7-.2-1.2-.4-1.5a1 1 0 00-1-.5c-.3 0-.6.1-1 .4-.2.3-.3.6-.3 1 0 .7.1 1.3.4 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM606 222.6v-.5h.6a11.1 11.1 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.5-.8.5-1.2 0-.6-.3-1.1-.7-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.4c.7 0 1.3-.1 1.7-.4.5-.2.7-.6.7-1.2 0-.4-.1-.7-.4-1-.2-.2-.5-.3-.9-.3H607l-.4.1-.2-.5a10.8 10.8 0 001-.3h.9c.6 0 1.1.1 1.5.5.3.5.5 1 .5 1.8 0 .4-.1.8-.4 1-.2.4-.5.6-1 .6.5.2.9.5 1.1 1 .2.4.4.9.4 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm5.5-1c.2 0 .4 0 .5.2.2.2.2.4.2.6v.5l-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6v-.4l.4-.2zm1 1v-.5h.6a11 11 0 001.4.3c.5 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.8 0 1.3-.1 1.8-.4.4-.2.7-.6.7-1.2 0-.4-.2-.7-.4-1-.2-.2-.5-.3-.9-.3h-1.2l-.5.1-.1-.5a10.4 10.4 0 00.9-.3h1c.6 0 1 .1 1.4.5.4.5.6 1 .6 1.8 0 .4-.2.8-.4 1-.2.4-.5.6-1 .6.5.2.8.5 1 1 .3.4.5.9.5 1.5a3 3 0 01-.5 1.7c-.3.4-.8.7-1.4.7-1 0-1.8-.2-2.5-.5zm9.5-8l.2.4c-1.9.8-3 1.9-3.3 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.2-2.3 5.4 5.4 0 01.7-2l.8-.8 1-.7 1.5-.6zm-3.4 6c0 .6.2 1.1.4 1.5.3.3.6.4 1 .4.3 0 .6-.1 1-.4.2-.2.3-.6.3-1a3 3 0 00-.4-1.7c-.4-.5-.7-.7-1.2-.7a1 1 0 00-.5 0l-.3.3-.2.5a3.7 3.7 0 000 1zM615.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset11Sulphates = 'M652 27.1v.3c0 .2-.1.4-.3.5 0 .1 0 .3-.2.4-.1.2-.3.3-.4.3l-.5.3h-1.1l-.6.1a2 2 0 01-.7-.1c-.2 0-.3-.2-.3-.3-.3 0-.5 0-.8-.2l-.5-.5a1 1 0 01-.4-.3 1 1 0 01-.2-.6l-.1-.3.1-.4.4-.1c.1 0 .3 0 .4.2.2 0 .4 0 .5.2.2.2.2.3.2.5h.3l.4.1.2.3h.5l.4.2.3-.1h.5c0-.1 0-.2.2-.2h.3V27c0-.2 0-.4.2-.5a.7.7 0 01-.3-.2c-.1 0-.2-.2-.1-.3h-.2c-.2 0-.4 0-.5-.2a1 1 0 01-.7-.2c-.2 0-.3-.2-.4-.4h-.3l-.5-.1a1 1 0 01-.4-.4l-.5-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 01-.1-.4v-.2a.7.7 0 01.1-.8V22v-.4l.4-.2.1-.4.4-.3h.4l.3-.3h.3l.4.1v-.1h.3a.7.7 0 01.5 0h.7l.3.3h.5l.3.4c.1 0 .3 0 .5.2.1 0 .2.2.1.3.3.2.5.4.5.7 0 .2 0 .3-.2.4-.1.2-.3.2-.4.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.5a.8.8 0 01-.3-.4l-.2.1a1 1 0 01-.4 0h-.3l-.3.1h-.3l-.1.3h-.4v.3c0 .2 0 .3-.2.5l.3.2v.4h.2c.3 0 .5 0 .6.3l.6.1c.1 0 .3.2.3.4h.5l.4.3h.2c.2 0 .3 0 .5.2l.2.3c.1 0 .2 0 .3.2v.4h.3V26.4c.2 0 .3.2.3.4l-.1.3-.2.1zm4 1.6a1 1 0 01-.4 0h-.4l-.4-.2a.8.8 0 01-.2-.3.8.8 0 01-.4-.3 1 1 0 01-.2-.4.5.5 0 01-.3-.2v-.6-.3l-.1-.4a.6.6 0 01-.2-.7v-.4-.4a.6.6 0 01-.2-.5l.1-.3a.8.8 0 01-.1-.5V23v-.4-.3-.4l.1-.6V21c0-.2 0-.4.2-.5l.5-.2.4.2c.2.1.2.3.2.5v.6l.1.5-.1.4v.9l.1.6v.4l.1.4v.2l.1.5v.2l.1.2v.5l.2.2v.3l.2.1v.2h.4l.2.2.6-.2h.2l.4-.2H657.8l-.1-.5.1-.3v-.6l.1-.7a1 1 0 01-.1-.5V24v-.3-.4l.3-.3c-.2-.1-.3-.4-.3-.7v-.5-.5l.1-.5.5-.2c.2 0 .4.1.5.3l.2.7.1.2.1.4c0 .2 0 .4-.2.5.2.2.3.4.3.7l-.1.3.1.4-.1.4v.4l-.1.5.1.4c0 .1 0 .3-.2.5l.2.4c0 .2 0 .5-.2.7l.2.4-.1.3v.3c0 .2 0 .3-.2.4l-.4.2-.4-.1a.7.7 0 01-.2-.5v-.1a1 1 0 01-.6.1h-.1l-.4.2-.3-.1-.2.2h-.3-.1zm7-1.7v1l-.2.3-.1.5-.5.2-.4-.1a.6.6 0 01-.3-.3V28v-.6-.4-.6-.5l.1-.6a1 1 0 01-.1-.4l.1-.6v-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5v-.4-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3.1-.4v-.4-.3a.6.6 0 01-.2-.4c0-.2 0-.4.2-.5l.6-.2.3.1.2.4c.2 0 .3.3.3.5v.2l.1.5-.1.4.1.2v.3l-.1.5.1.4-.1.4V22l.2.5v.8l-.1.5V26l.1.5v.5zm7.7-3.7l.2.5v.5l.1.6V25.8c0 .2-.1.4-.3.5V27.2l-.3.4-.3.6-.6.3-.3.3-.5.1h-.4-.8a.7.7 0 01-.3-.2h-.2l-.5-.1v.8c0 .3 0 .4-.2.6l.2.2v.4l-.1.4v.5l-.1.5c-.1.2-.3.2-.5.2l-.4-.1a.9.9 0 01-.3-.5v-.2l-.1-.3.1-.5-.1-.7v-.7-.5-.4-.3-.3-.3l-.1-.3.1-.3.1-.3-.1-.7v-.6a2 2 0 01-.1-.8l.1-.4v-.3-.3a1 1 0 010-.5v-.6-.9-.5-.2c0-.2.1-.3.3-.4.1-.2.3-.2.5-.2h.3l.2.4h.1l.3-.2h.4l.6-.2H668.3l.3.1.2.1h.3l.3.3h.2l.1.2h.2l.2.3c.2.2.3.5.3 1l.3.3v.9zm-2.4 4.2l.3-.3.4-.1c0-.3 0-.5.2-.7V26c0-.3 0-.5.3-.7a4.1 4.1 0 010-1 1 1 0 01-.3-.4v-.6-.4l-.3-.4v-.5s-.2 0-.3-.2l-.2-.2h-.2l-.2-.2-.4.1a1 1 0 01-.3 0 1 1 0 01-.6.2c-.1 0-.2 0-.3-.2l.1.6-.1.6.1.7v3.8h.5l.5.2h.8zm5.4.6l.1.4c0 .2 0 .3-.2.4a1 1 0 01-.5.1c-.2 0-.4 0-.6-.2a1 1 0 01-.1-.6l.1-.4-.2-.6c0-.3 0-.5.3-.6a.7.7 0 01-.2-.6l.1-.6V25v-.4a.6.6 0 01-.1-.4l.1-.3v-.2-.3a.8.8 0 01-.2-.5l.1-.5v-.2-.2l-.1-.5.1-.4a1 1 0 010-.5v-.4a1 1 0 01-.1-.4l.1-.5v-.4-.4-.4-.3c0-.2 0-.3.2-.4 0-.2.2-.2.4-.2h.3l.3.4a1.3 1.3 0 010 1l.1.5-.1.6.1.6v.3l.1.4v.8l.3-.4h.4c0-.2.1-.3.3-.4a.7.7 0 01.5 0l.4-.2.3.1h.8l.3.1.4.2c.2 0 .3.2.3.3.2.2.2.4.2.5v.2l.2.2v.5c.1.1.2.2.2.5l-.1.4.1.4V27l-.1.6.1.4-.1.5c0 .2 0 .3-.2.3l-.5.2-.4-.1v-.4c-.2-.1-.2-.3-.2-.6v-.5-.6-.5-.3-.4-.4-.2a.9.9 0 01-.1-.5v-.3l-.1-.4.1-.4c-.2-.2-.3-.3-.3-.5v-.3h-.2a.6.6 0 01-.2-.3.9.9 0 01-.5 0c0 .1-.1.2-.3.2h-.2l-.4.3-.2.1-.2.4-.4.2v1.7l-.1.4V27.8s0 .2-.2.3zm6.3-5.3l-.1-.4c0-.2 0-.4.2-.5l.2-.4.4-.4h.4c0-.2.2-.3.4-.4l.6-.1h.2l.5-.2.3.1.5-.1c.3 0 .5 0 .7.2.3.1.4.3.4.5.2 0 .4.1.4.3.2.1.2.3.2.5.2.2.3.3.3.5l.1.6v.6l.1.5a2.5 2.5 0 010 .9l.2.3v.2a1.7 1.7 0 010 .4c0 .2 0 .3-.2.4v.5l-.1.5v.2c0 .3 0 .4-.2.6l-.3.3-.4.2c-.1 0-.2 0-.3-.2l-.7.2h-.2l-.7.1a3 3 0 01-.6 0h-.7-.3a1 1 0 01-1-.6c-.3-.2-.5-.6-.5-1v-.3l-.2-.4.1-.4v-.4c0-.3 0-.5.4-.8l.4-.5.6-.2c0-.2.2-.3.4-.3l.7-.1.3-.1h1.2c.1-.2.3-.3.5-.3h.2V23a.8.8 0 01-.3-.2 1 1 0 01-.2-.5.6.6 0 01-.3-.3l-.5.1h-.3a1 1 0 01-.4 0l-.5.1c-.1.2-.3.3-.5.3l-.4.5-.5.2c-.2 0-.4-.1-.5-.3zm1 3.6l.1.3v.3l.1.1.2.2h1.1c.2 0 .4 0 .5.2l.4-.2h.5c.1-.3.3-.4.6-.4l.1-.3v-.3l-.1-.3.1-.5a.8.8 0 01-.1-.5v-.4l-.3.1-.2-.1-.4.1h-.3l-.5.1h-.2c-.2.1-.3.2-.4.1 0 .2-.2.3-.3.3l-.4.1-.2.3h-.3v.8zm10.5 1.2h.1l.2-.1h.2c.1 0 .3 0 .4.2l.2.4-.1.4-.4.2a1 1 0 01-.8.2l-.3.1c-.2 0-.4 0-.5-.2l-.4-.1-.3-.3a.9.9 0 01-.4-.2.6.6 0 01-.2-.6.8.8 0 01-.2-.4.6.6 0 01-.3-.3v-.4c-.2 0-.2-.3-.2-.5v-.4a.6.6 0 01-.2-.5c0-.2 0-.3.2-.4a.7.7 0 01-.2-.5v-.3-.4-.4a1 1 0 010-.8l.2-.2a.7.7 0 01-.2-.4v-.3a1 1 0 01-.3 0h-.7c-.2 0-.4 0-.6-.2l-.3.1c-.2 0-.4 0-.5-.2a.8.8 0 01-.1-.5l.1-.4.5-.2H688.4v-.5-.3-.4c0-.3 0-.5.2-.6l.1-.5.4-.1.4.1.2.4-.1.4.1.5v.3l-.1.2v.7h1.4c.2 0 .3 0 .4.2l.4.1c.2.1.2.2.2.4 0 .1 0 .3-.2.5l-.4.2-.3-.1-.5.1-.4-.1a1 1 0 01-.3 0h-.3l.2.4c0 .1 0 .3-.2.4l.1.5-.1.5.2.4c0 .1 0 .3-.2.4l.2.6V26l.2.4.2.5c.2.1.3.3.3.6h.1v.1h.2l.4.1H691.5zm8.3-4.9l.4.4.1.7c0 .3-.1.6-.5.7l-.3.3-.5.2a1 1 0 01-.4-.1l-.4.1h-1.5a1 1 0 01-.4 0h-.5a1 1 0 01-.5 0l-.6.1a1 1 0 01-.4 0l-.1.7c.2.2.3.4.2.6l.2.2s.2.1.2.3c.1 0 .2 0 .3.2l.2.3.3-.1h.2l.2.1h.2l.4.1h.5l.3-.2.4-.1.4-.3h.4c.3 0 .5 0 .6.3v.3c0 .3 0 .5-.3.6l-.2.2-.4.2h-.3c-.1.2-.4.3-.6.3a1 1 0 01-.3 0l-.6.1h-.7l-.4-.2c-.5 0-.9-.1-1-.5l-.6-.3c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.5-.5v-.3l-.1-.3V26l-.1-.7.1-.5v-.4-.5l.2-.4v-.2l.3-.4.3-.2v-.2c0-.4.2-.7.6-.8 0-.2.1-.3.4-.5.2-.2.4-.3.5-.2 0-.2.1-.2.3-.3.2 0 .4-.1.4 0 .1-.2.3-.3.6-.4l.4-.1H697.5l.2.2.6.2.3.5h.5l.5.5c.2.2.3.5.3.8v.2zm-2.3 1l.8-.1h.5l-.2-.2a1 1 0 01-.1-.5v-.2h-.4a2.7 2.7 0 01-.4-.6l-.3-.1-.3-.3-.3.1h-.3l-.2.2h-.4c0 .3-.2.4-.3.6a1 1 0 01-.5.3c0 .1 0 .3-.2.5l-.3.4.7-.2h.4l.3.2c.2-.2.5-.3.8-.3.3 0 .5.1.7.3zm9.5 3.4v.3c0 .2 0 .4-.2.5 0 .1 0 .3-.2.4l-.4.3-.5.3h-1.1l-.7.1a2 2 0 01-.6-.1c-.2 0-.3-.2-.4-.3-.2 0-.4 0-.7-.2l-.5-.5a1 1 0 01-.5-.3 1 1 0 01-.2-.6v-.3-.4l.4-.1c.2 0 .3 0 .4.2.2 0 .4 0 .5.2.2.2.3.3.3.5h.2l.4.1.2.3h.6l.3.2.4-.1h.4c0-.1.1-.2.3-.2h.3l-.1-.4c0-.2 0-.4.2-.5a.7.7 0 01-.3-.2l-.1-.3h-.2c-.2 0-.4 0-.5-.2a1 1 0 01-.6-.2c-.2 0-.4-.2-.5-.4h-.2l-.6-.1a1 1 0 01-.4-.4l-.5-.1c-.2-.2-.3-.3-.3-.5a.7.7 0 01-.3-.3 1 1 0 01-.1-.4v-.2a.7.7 0 01.2-.8V22v-.4l.3-.2c0-.1 0-.3.2-.4l.3-.3h.5l.2-.3h.3l.4.1.1-.1h.3a.7.7 0 01.4 0h.7l.3.3H706l.2.4c.2 0 .3 0 .5.2.2 0 .2.2.2.3.3.2.4.4.4.7 0 .2 0 .3-.2.4 0 .2-.2.2-.4.2h-.4a.4.4 0 01-.2-.4 1 1 0 01-.4-.1.5.5 0 01-.2-.4h-.4a.8.8 0 01-.3-.4l-.3.1a1 1 0 01-.4 0h-.3l-.3.1h-.3v.3h-.4v.3c0 .2 0 .3-.2.5l.2.2v.4h.2c.3 0 .5 0 .6.3h.1l.5.1c.2 0 .3.2.4.4h.5l.3.3h.2c.2 0 .4 0 .5.2.2 0 .3.2.3.3l.2.2.1.4h.2l.1.4v.2l.2.4v.3l-.2.1zm-38.5 166c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V193.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.8-2l.1.6-.8.1v2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.2 4.8h.8zm-4 0h2.4a83 83 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm4.9 3.5v-.7a10.7 10.7 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.3-.3a113.1 113.1 0 002.4-1.7h.4a116.8 116.8 0 010 8l.6.2h.6l.2.7h-3.7zM667.5 271c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V271.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.8-2l.1.6-.8.1v2.7c0 .3-.1.4-.3.4-.2 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a9.7 9.7 0 01-1.7 0 18.7 18.7 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a192.8 192.8 0 00-.2 4.8h.8zm-4 0h2.4a83 83 0 00.2-4c-.4.4-.8 1-1.4 2.1l-1.1 1.8zm9-4.8l.1.5-1.3.1h-1.4a53 53 0 01-.4 3l.6-.2c.7 0 1.3.3 1.8.9.6.5.8 1.1.8 1.8s-.2 1.3-.7 1.8c-.6.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.1-.3.4-.4h.1c.6.5 1 .7 1.5.7s1-.2 1.2-.6c.4-.4.5-.8.5-1.3 0-.4-.1-.8-.4-1.1-.3-.4-.7-.5-1.3-.5h-.6a8 8 0 00-1-.4l.5-2.2.4-1.8h3.2zM667.5 89c0-1.7.2-2.9.6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V89.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.7-6.8v.5l-1.2.1h-1.4l-.5 3 .7-.2c.7 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zm5.2 4.9l.1.5-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4-.1 0-.3 0-.4-.2a.7.7 0 01-.3-.4l.1-2.4a10 10 0 01-1.7 0 18.4 18.4 0 00-1.5 0 6 6 0 000-.7v-.2c1.3-2.2 2.4-3.8 3.2-4.9.2 0 .6 0 1 .2a168 168 0 00-.1 4.8h.7zm-4-.2l2.4.1a82.8 82.8 0 00.2-4c-.3.4-.8 1-1.4 2.1l-1.1 1.8zm-11.5 207.7c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V297.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5 1.5v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H675.6zm8.1-.8l.4.8h-4.8v-.3-.4l.8-1a44 44 0 012-2.1l.8-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-.9-.4-.4 0-.8.2-1.1.5-.3.3-.6.8-.7 1.5l-.5-.2c0-.7.2-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.9.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.6 0zM668.5 141c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V141.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.7-6.8v.5l-1.2.1h-1.4a53 53 0 01-.5 3l.7-.2c.7 0 1.3.3 1.8.9.5.5.8 1.1.8 1.8s-.3 1.3-.8 1.8c-.5.4-1.2.7-2 .7-.7 0-1.4-.3-2.1-.8l.2-.3.3-.4h.2c.5.5 1 .7 1.5.7s.9-.2 1.2-.6c.3-.4.5-.8.5-1.3 0-.4-.2-.8-.5-1.1-.3-.4-.7-.5-1.3-.5h-.5a8 8 0 00-1-.4l.4-2.2.5-1.8h3.2zm1 8.3v-.7a10.7 10.7 0 001.3-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.7-.5a287.6 287.6 0 011.7-1.2h.4a114.6 114.6 0 01.1 8l.5.2h.7l.2.7h-3.7zM668.5 115c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V115.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.6-7l.2.5c-1.8.8-2.9 1.9-3.2 3.2.3-.2.6-.3 1-.3a2 2 0 011.6.9c.5.6.7 1.4.7 2.3 0 .7-.2 1.2-.6 1.6-.4.4-1 .6-1.6.6-.6 0-1.1-.2-1.5-.6-.5-.5-.7-1-.7-1.8a27 27 0 01.1-2.3 5.4 5.4 0 01.8-2l.7-.8 1.1-.7 1.4-.6zm-3.3 6c0 .7.1 1.2.4 1.6.2.3.5.4.9.4s.7-.1 1-.4c.3-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.5 0l-.3.3-.2.5v1.1zm4.6 2.5v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.6 1-.3-.3a113.1 113.1 0 002.4-1.7h.4a116.8 116.8 0 010 8l.6.2h.6l.2.7H681zM668.5 323c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V323.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .4-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.5 1.5v-.7a10.7 10.7 0 001.4-.2 39.8 39.8 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 114.6 114.6 0 01.1 8l.5.2h.6l.2.7H675.6zm4.3.2l-.1-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1 .3 1.5.7.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3l-.2 1-.5 1-.8.8c-.2.3-.6.5-1 .7-.4.3-1 .5-1.5.6zm3.4-6c0-.7-.2-1.2-.4-1.5a1 1 0 00-1-.5c-.3 0-.6.1-.9.4-.3.3-.4.6-.4 1 0 .7.1 1.3.4 1.8.4.4.7.7 1.2.7l.5-.1.3-.3.2-.4a4 4 0 000-1.1zM666.5 245c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V245.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17.6 17.6 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm1.8 1.9c0-1.7.3-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .7 0 1 .3l.7.8.4 1.1.2 1.3.1 1.3c0 .6 0 1.2-.2 1.9-.2.6-.5 1.2-.9 1.7s-.8.7-1.2.7c-1.9 0-2.8-1.4-2.8-4.3zm2.5-4a1.7 1.7 0 00-.9.5l-.2.5a4.2 4.2 0 00-.3 1.7 82.6 82.6 0 010 2.4c0 .3 0 .7.2 1 0 .4.2.7.5.9.2.2.5.3.8.3.5 0 .9-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm-13.8-74c0-1.7.2-3 .6-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.4-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V167.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm6.5-.9c0 .9-.2 1.5-.7 2-.4.3-1 .6-1.9.6-1.6 0-2.4-.9-2.4-2.6 0-.6.1-1.1.4-1.6.2-.5.6-.7 1-.8-.5 0-.8-.2-1-.5a2 2 0 01-.4-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.8-.7.7 0 1.4.2 1.8.6.4.4.7 1 .7 1.8 0 .5-.1 1-.4 1.2-.2.3-.5.5-1 .5.5 0 .8.4 1 .8.3.5.5 1 .5 1.6zm-2.4 1.7c.4 0 .8-.2 1-.5.4-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.7-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.2 1 .5 1.3.3.3.7.5 1.2.5zm0-7.5c-.6 0-1 .2-1.2.5-.3.3-.4.7-.4 1 0 .5.1.8.4 1.1.2.3.6.5 1 .5.5 0 .9-.2 1.2-.5.2-.2.4-.6.4-1 0-.3-.2-.7-.4-1-.3-.3-.6-.5-1-.6zm7.2 7.4l.4.8H680v-.3-.4l.8-1a42.1 42.1 0 012-2.1l.8-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-.9-.4-.4 0-.8.2-1.1.5-.3.3-.6.8-.7 1.5l-.5-.2c0-.7.2-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.6 0zm-17 48.9c0-1.7.3-3 .7-3.6.5-.8 1.1-1.2 2-1.2.4 0 .7 0 1 .3l.7.8.5 1.1.2 1.3v1.3c0 .6 0 1.2-.2 1.9l-.8 1.7c-.4.5-.8.7-1.3.7-1.8 0-2.7-1.4-2.7-4.3zm2.5-4a1.7 1.7 0 00-.8.5l-.3.5a4 4 0 00-.3 1V219.3a8.7 8.7 0 00.2 2c.1.4.3.7.5.9.2.2.5.3.8.3.5 0 1-.3 1.2-1 .3-.6.5-1.3.5-2 0-2.8-.6-4.2-1.8-4.2zm3.2 6.4c.2 0 .4.1.5.3l.3.6c0 .2 0 .3-.2.5l-.3.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm5.4.7l.4.8H674v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.3-.8c-.3-.3-.6-.4-1-.4-.3 0-.7.2-1 .5-.4.3-.6.8-.7 1.5l-.6-.2c0-.7.3-1.3.8-1.8.4-.4 1-.6 1.6-.6.5 0 1 .2 1.4.5.4.4.6.8.6 1.5a4.8 4.8 0 01-1 2.8 15.6 15.6 0 01-2.5 3 12.4 12.4 0 001.5 0 28.4 28.4 0 011.7 0zm1 1l-.2-.5c1.8-.8 2.9-1.8 3.2-3.1-.3.2-.6.3-1 .3a2 2 0 01-1.6-1c-.5-.5-.7-1.3-.7-2.3 0-.6.2-1.2.6-1.6.4-.4 1-.6 1.6-.6.6 0 1.1.3 1.5.7.5.4.7 1 .7 1.7a17.6 17.6 0 01-.1 2.3l-.3 1-.5 1-.7.8-1.1.7c-.4.3-.9.5-1.4.6zm3.3-6c0-.7-.1-1.2-.4-1.5a1 1 0 00-.9-.5c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1 0 .7.1 1.3.5 1.8.3.4.7.7 1.1.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zM676.3 347c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3z';

  var dataset12Alcohol = 'M750.5 197v-.7a10.5 10.5 0 001.4-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.6-.5.9-.7.5-.6a6.5 6.5 0 00.8.1 115.1 115.1 0 01.1 8l.5.2h.6l.2.7H750.5zm4.2-3.9c0-1.7.2-3 .7-3.6.4-.8 1-1.2 2-1.2.3 0 .6 0 1 .3.2.2.5.5.6.8l.5 1.1.2 1.3.1 1.3c0 .6 0 1.2-.3 1.9-.1.6-.4 1.2-.8 1.7s-.8.7-1.3.7c-1.8 0-2.7-1.4-2.7-4.3zm2.5-4a1.7 1.7 0 00-1 .5l-.2.5a4.2 4.2 0 00-.3 1.7 51.1 51.1 0 010 2.4l.2 1c.1.4.3.7.5.9.3.2.5.3.9.3s.8-.3 1.1-1c.4-.6.5-1.3.5-2 0-2.8-.6-4.2-1.7-4.2zm3.1 6.4c.3 0 .4.1.6.3l.2.6-.1.5-.4.1c-.2 0-.4 0-.5-.3a1 1 0 01-.2-.6l.1-.4.3-.2zm1.6 1.5v-.7a10.5 10.5 0 001.3-.2 41.6 41.6 0 000-5v-2l-1.5 1-.4-.3.7-.5.8-.7.6-.6a6.5 6.5 0 00.7.1 115.1 115.1 0 01.1 8l.5.2h.7l.2.7h-3.7zm-6.3 78.2l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm2.4 1.6l-.9-.3 3.2-7.7c-1.9 0-3-.1-3.7-.2l-.2-.5 2.5-.1h2.3v1L762 275zm-6.5-181.9l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm5.8-2v.6l-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a10.1 10.1 0 01-1.6 0 18.5 18.5 0 00-1.5 0 5.4 5.4 0 000-.7v-.2l3.1-4.9c.3 0 .6 0 1 .2a174 174 0 00-.1 4.8h.8zm-4 0h2.4a84 84 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zm-5.9 211.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm5.8-2v.6l-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a9.7 9.7 0 01-1.6 0 18.7 18.7 0 00-1.5 0 5.5 5.5 0 000-.7v-.2l3.1-4.9c.3 0 .6 0 1 .2a173.8 173.8 0 00-.1 4.8h.8zm-4 0h2.4a84.2 84.2 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zm-6.9-152.3l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm6.4-.9c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.5-.9-2.5-2.6 0-.6.2-1.1.4-1.6.3-.5.6-.7 1-.8-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .4 1.3.4.3.8.5 1.2.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.5-.5-1-.6zm-8-17.6l-.3-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.2-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm6.4-.9c0 .9-.2 1.5-.6 2-.4.3-1 .6-1.9.6-1.6 0-2.5-.9-2.5-2.6 0-.6.2-1.1.4-1.6.3-.5.6-.7 1-.8-.4 0-.7-.2-1-.5a2 2 0 01-.3-1.2c0-.7.2-1.3.6-1.7.4-.4 1-.7 1.7-.7.8 0 1.4.2 1.9.6.4.4.6 1 .6 1.8 0 .5 0 1-.3 1.2-.2.3-.6.5-1 .5.4 0 .8.4 1 .8.3.5.4 1 .4 1.6zm-2.4 1.7c.5 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2c-.3-.4-.8-.5-1.3-.5a2 2 0 00-1 .6c-.3.3-.4.7-.4 1 0 .5.1 1 .4 1.3.4.3.8.5 1.2.5zm0-7.5c-.5 0-.9.2-1.2.5-.2.3-.4.7-.4 1 0 .5.2.8.4 1.1.3.3.6.5 1 .5.6 0 1-.2 1.2-.5.3-.2.4-.6.4-1 0-.3-.1-.7-.4-1-.2-.3-.5-.5-1-.6zm-8 216.4l-.3-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.2-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm5.6-7l.2.5c-1.8.8-3 1.9-3.3 3.2l1-.3a2 2 0 011.7.9c.4.6.7 1.4.7 2.3 0 .7-.2 1.2-.7 1.6-.4.4-.9.6-1.5.6s-1.1-.2-1.6-.6c-.4-.5-.7-1-.7-1.8a25.5 25.5 0 01.2-2.3 5.4 5.4 0 01.8-2l.7-.8 1-.7 1.5-.6zm-3.3 6c0 .7.1 1.2.3 1.6.3.3.6.4 1 .4.3 0 .7-.1 1-.4.2-.2.4-.6.4-1a3 3 0 00-.5-1.7c-.3-.5-.7-.7-1.1-.7a1 1 0 00-.6 0c0 .2-.2.2-.3.3l-.1.5-.1.5v.6zm-5.4-75.3l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm5.4.7l.3.8h-4.7v-.3-.4l.7-1a44 44 0 012-2.1l.9-1.4c.2-.5.3-1 .3-1.6a1 1 0 00-.4-.8c-.2-.3-.5-.4-.9-.4s-.7.2-1 .5c-.4.3-.7.8-.8 1.5l-.5-.2c0-.7.3-1.3.7-1.8.5-.4 1-.6 1.6-.6.6 0 1 .2 1.5.5.3.4.5.8.5 1.5a4.8 4.8 0 01-.9 2.8 15.6 15.6 0 01-2.6 3 12.4 12.4 0 001.6 0 28.5 28.5 0 011.7 0zm-9.5-77l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm5.8-2v.6l-.8.1v1.4l.1 1.3c0 .3-.2.4-.4.4l-.4-.2a.7.7 0 01-.2-.4v-2.4a9.7 9.7 0 01-1.6 0 18.7 18.7 0 00-1.5 0 5.5 5.5 0 000-.7v-.2l3.1-4.9c.3 0 .6 0 1 .2a173.8 173.8 0 00-.1 4.8h.8zm-4 0h2.4a84.2 84.2 0 00.1-4c-.3.4-.8 1-1.4 2.1l-1 1.8zm-5.9 55.7l-.2-.5c1.8-.8 3-1.8 3.3-3.1l-1 .3a2 2 0 01-1.7-1c-.4-.5-.6-1.3-.6-2.3 0-.6.2-1.2.6-1.6.4-.4.9-.6 1.5-.6s1.2.3 1.6.7c.5.4.7 1 .7 1.7a17 17 0 01-.2 2.3c0 .4-.1.8-.3 1 0 .4-.2.7-.4 1l-.8.8-1 .7-1.5.6zm3.3-6c0-.7 0-1.2-.3-1.5a1 1 0 00-1-.5c-.3 0-.7.1-1 .4-.2.3-.4.6-.4 1 0 .7.2 1.3.5 1.8.3.4.7.7 1.2.7l.5-.1.3-.3.2-.4a3.9 3.9 0 000-1.1zm.8 4.3c.2 0 .4.1.5.3.2.2.2.4.2.6l-.1.5-.3.1c-.3 0-.4 0-.6-.3a1 1 0 01-.1-.6v-.4l.4-.2zm1 1.1v-.5h.6a11.1 11.1 0 001.4.3c.4 0 .8-.2 1-.5.3-.4.4-.8.4-1.2 0-.6-.2-1.1-.6-1.6-.4-.4-1-.6-1.8-.6h-.3v-.6h.3c.7 0 1.3-.1 1.8-.4.4-.2.6-.6.6-1.2 0-.4 0-.7-.3-1-.2-.2-.5-.3-1-.3h-1.1l-.5.1-.2-.5a10.8 10.8 0 001-.3h1c.6 0 1 .1 1.4.5.4.5.5 1 .5 1.8 0 .4 0 .8-.3 1-.2.4-.6.6-1 .6.5.2.8.5 1 1 .3.4.4.9.4 1.5a3 3 0 01-.4 1.7c-.4.4-.8.7-1.5.7-.9 0-1.7-.2-2.4-.5zm-.4 124.5c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zm0 10c.4 0 .8.2 1 .5.4.4.5.8.5 1.3 0 .3 0 .6-.2.8-.2.2-.4.3-.7.3-.4 0-.8-.2-1-.5-.3-.4-.4-.8-.4-1.3 0-.3 0-.6.2-.8.1-.2.3-.3.6-.3zM732 22.8v-.4l.1-.5.2-.4.4-.4h.4c0-.2.2-.3.4-.4l.6-.1h.2l.5-.2.3.1.6-.1c.2 0 .5 0 .7.2.2.1.3.3.3.5.2 0 .4.1.5.3l.2.5c0 .2.2.3.3.5v1.2l.1.5.1.6v.8a2.8 2.8 0 010 .4l-.1.4v1.2c0 .3-.2.4-.3.6l-.3.3-.4.2c-.1 0-.2 0-.3-.2l-.7.2h-.2l-.7.1h-1.3-.3a1 1 0 01-1-.6c-.3-.2-.5-.6-.5-1v-.3l-.2-.4.1-.4v-.4c0-.3.1-.5.4-.8l.4-.5.6-.2c0-.2.2-.3.4-.3l.7-.1.3-.1h1.2c.1-.2.3-.3.5-.3h.2l.1-.4a.8.8 0 01-.3-.2 1 1 0 01-.3-.5.6.6 0 01-.3-.3l-.5.1h-.3a1 1 0 01-.3 0l-.5.1-.6.3c0 .2-.2.3-.4.5l-.5.2c-.2 0-.3-.1-.5-.3zm1 3.6l.1.3v.3l.1.1.2.2h1.1c.2 0 .4 0 .5.2l.4-.2h.6c0-.3.2-.4.5-.4 0-.1 0-.2.2-.3l-.2-.3V26c0-.2 0-.4.2-.5a.8.8 0 01-.2-.5v-.4l-.2.1-.3-.1-.4.1h-.3l-.4.1h-.3c-.1.1-.3.2-.4.1 0 .2-.2.3-.3.3l-.4.1-.2.3h-.3v.8zm8.2.6l.2.5-.1.5-.2.3-.1.5-.5.2-.4-.1a.6.6 0 01-.3-.3V28v-.6-.4l.1-.6-.1-.5.1-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4-.1-.4c0-.3 0-.5.2-.6l-.1-.6V20v-.2l-.1-.3.1-.4v-.4-.3a.6.6 0 01-.2-.4c0-.2 0-.4.2-.5l.6-.2.3.1.2.4c.2 0 .3.3.3.5v.2l.1.5-.1.4.1.2v.3l-.1.5.1.4v1.1l-.2.2c.2.1.3.3.3.5v.8l-.1.5.1.6-.1.7v.9l.1.5v.5zm6.8 1.6a1 1 0 01-.4.3l-.5.1-.4-.1h-.3c-.2 0-.4 0-.5-.2l-.3.1-.5-.1a.8.8 0 01-.4-.4l-.6-.1a.8.8 0 01-.3-.5c-.3-.2-.6-.6-.7-1.2l-.1-.2a1.1 1.1 0 010-.5c-.2-.3-.3-.7-.3-1.1 0-.4 0-.6.2-.9v-.2-.5l.4-.4v-.2l.1-.5.4-.2c0-.2.1-.3.3-.5l.5-.2c.2-.3.4-.4.6-.4l.4-.3h.5l.3-.1h1.1l.2.1h.2l.2.3c.2 0 .4 0 .5.2l.3.4v.3c.3 0 .4.2.5.4v.4a.6.6 0 01-.5.6c-.2 0-.4 0-.6-.2l-.3-.6a1.1 1.1 0 01-.7-.4h-.5l-.3.1h-.3l-.6.3-.4.4-.4.1v.2l-.1.3-.2.3-.2.1v.5c0 .2 0 .5-.2.9l.2.3v.5l.2.3.1.4c.3 0 .5.2.7.3l.2.5.4-.2.4.1.3.3h.2l.4.1.3-.2.4-.2.3-.2a.9.9 0 01.5 0c.2-.2.3-.3.6-.3.2 0 .4 0 .5.2.2.1.2.3.2.5s0 .4-.3.6a1 1 0 01-.6.2 1 1 0 01-.2 0v.1l-.5.3a1 1 0 01-.4 0zm7.7.2l-.6.2-.5-.1h-.5c-.5 0-.8 0-1-.3h-.1a.6.6 0 01-.6-.3l-.4-.1-.2-.4a.8.8 0 01-.4-.3 1 1 0 01-.2-.6.5.5 0 01-.2-.2 1 1 0 01-.1-.5V26l-.1-.7c0-.2 0-.4.2-.6l-.2-.3v-.4l.3-.2v-.4l.3-.3v-.1-.3l.3-.2v-.1c0-.3 0-.5.2-.6.2-.2.4-.3.5-.2l.2-.4.6-.2h.2l.4-.3.5-.2h.3l.6-.1.5.1.3.4c.1 0 .3 0 .5.2.2 0 .3.2.3.3l.8.5c.2.3.3.5.3.8v.2c.5 0 .7.5.6 1.4l.2.5c0 .2 0 .4-.2.6a.9.9 0 010 .7l-.3.2v.4l-.4.5v.2c0 .3-.2.5-.6.6 0 .2 0 .3-.2.4l-.5.2c-.2.2-.4.3-.7.3h-.1zm-1.5-1.1l.4-.1h.2l.3-.2h.4l.6-.3h.1l.1-.3.3-.2v-.3l.3-.3c0-.2 0-.3.2-.5a.7.7 0 010-.6l.2-.3a.5.5 0 01-.2-.3c0-.1 0-.3.2-.4-.3-.1-.4-.2-.5-.4V23c-.2 0-.3 0-.4-.2a.8.8 0 01-.1-.4l-.5-.1-.2-.4h-.3c-.3 0-.4 0-.6-.2l-.4.3a1 1 0 01-.5 0c0 .2-.1.3-.3.5l-.5.2v.6l-.2.2-.1.5-.4.3v.8s0 .2-.2.3c.3.2.4.5.4.8v.5h.2v.3c.3 0 .5.2.7.4l.4.1.4.3zm7 .4l.1.4c0 .2 0 .3-.2.4a1 1 0 01-.5.1c-.3 0-.4 0-.6-.2a1 1 0 01-.1-.6v-.4l-.1-.6c0-.3 0-.5.2-.6a.7.7 0 01-.2-.6l.2-.6V25v-.4a.6.6 0 01-.1-.4V24v-.2-.3a.8.8 0 01-.1-.5l.1-.5v-.2-.2l-.1-.5.1-.4a1 1 0 01-.1-.5l.1-.4a1 1 0 01-.1-.4l.1-.5-.1-.4v-.4-.4l.1-.3c0-.2 0-.3.2-.4 0-.2.2-.2.4-.2h.3l.3.4a1.3 1.3 0 010 1l.1.5c0 .2 0 .4-.2.6l.2.6v1l.1.2v.3c0-.2.2-.3.3-.4h.4l.2-.4a.7.7 0 01.6 0l.4-.2.3.1h.8l.3.1.4.2.2.3.3.5v.2l.1.2.1.3v.2c.1.1.2.2.2.5l-.1.4.1.4V27l-.1.6v.9c0 .2 0 .3-.2.3l-.5.2-.4-.1v-.4c-.2-.1-.3-.3-.3-.6l.1-.5v-.6-.5-.3-.4-.4-.2a.9.9 0 01-.1-.5v-.3l-.1-.4v-.4l-.2-.5v-.3h-.2a.6.6 0 01-.2-.3.9.9 0 01-.5 0c0 .1-.1.2-.3.2h-.2l-.4.3-.2.1-.2.4-.4.2v.2l-.1.6.1.3V25.2l-.1.4v.2l-.1.4.2.4v.4l-.2.4v.7zm10.6.7l-.6.2-.5-.1h-.5c-.5 0-.8 0-1-.3h-.1a.6.6 0 01-.6-.3l-.4-.1-.2-.4a.8.8 0 01-.4-.3 1 1 0 01-.2-.6.5.5 0 01-.3-.2 1 1 0 010-.5V26l-.1-.7c0-.2 0-.4.2-.6l-.2-.3v-.4l.3-.2v-.4l.3-.3v-.1-.3l.3-.2v-.1c0-.3 0-.5.2-.6.2-.2.4-.3.5-.2l.2-.4.6-.2h.2l.4-.3.5-.2h.3l.6-.1.5.1.3.4c.1 0 .3 0 .5.2.2 0 .3.2.3.3l.8.5c.2.3.3.5.3.8v.2c.5 0 .7.5.6 1.4l.2.5c0 .2 0 .4-.2.6a.9.9 0 010 .7l-.3.2v.4l-.4.5v.2c0 .3-.2.5-.6.6 0 .2 0 .3-.2.4l-.5.2c-.2.2-.4.3-.7.3h-.1zm-1.6-1.1l.5-.1h.2a.9.9 0 01.7-.2l.6-.3h.1l.1-.3.2-.2.1-.3.3-.3.1-.5a.7.7 0 010-.6l.3-.3a.5.5 0 01-.2-.3c0-.1 0-.3.2-.4-.3-.1-.4-.2-.5-.4V23c-.2 0-.3 0-.4-.2a.8.8 0 01-.2-.4l-.4-.1-.2-.4h-.3c-.3 0-.4 0-.6-.2l-.4.3a1 1 0 01-.5 0c0 .2-.1.3-.3.5l-.5.2v.6l-.2.2-.1.5-.4.3v.8s0 .2-.2.3c.3.2.4.5.4.8v.5h.2v.3c.3 0 .5.2.7.4l.4.1.3.3zm7.6-.7c.2.1.2.3.2.5v.5l-.2.3c0 .2 0 .4-.2.5l-.5.2-.4-.1a.6.6 0 01-.2-.3l-.1-.5.1-.6v-.4-.6-.5-.6a1 1 0 010-.4v-.6-.6-.5a.6.6 0 01-.1-.5v-.1a.7.7 0 01-.2-.5l.1-.4v-.4l.1-.6v-.6-.3l-.1-.2v-.3-.4-.4-.3a.6.6 0 01-.2-.4c0-.2.1-.4.3-.5l.5-.2.3.1.3.4.2.5v.2l.2.5c0 .1 0 .3-.2.4l.1.2.1.3c0 .2 0 .4-.2.5l.1.4v1.1l-.1.2.2.5v1.9l-.1.7.1.4-.1.5.1.5v.5z';

  var compiler = createCommonjsModule(function (module, exports) {
  /*
   *  Copyright 2011 Twitter, Inc.
   *  Licensed under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License.
   *  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   */

  (function (Hogan) {
    // Setup regex  assignments
    // remove whitespace according to Mustache spec
    var rIsWhitespace = /\S/,
        rQuot = /\"/g,
        rNewline =  /\n/g,
        rCr = /\r/g,
        rSlash = /\\/g,
        rLineSep = /\u2028/,
        rParagraphSep = /\u2029/;

    Hogan.tags = {
      '#': 1, '^': 2, '<': 3, '$': 4,
      '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
      '{': 10, '&': 11, '_t': 12
    };

    Hogan.scan = function scan(text, delimiters) {
      var len = text.length,
          IN_TEXT = 0,
          IN_TAG_TYPE = 1,
          IN_TAG = 2,
          state = IN_TEXT,
          tagType = null,
          tag = null,
          buf = '',
          tokens = [],
          seenTag = false,
          i = 0,
          lineStart = 0,
          otag = '{{',
          ctag = '}}';

      function addBuf() {
        if (buf.length > 0) {
          tokens.push({tag: '_t', text: new String(buf)});
          buf = '';
        }
      }

      function lineIsWhitespace() {
        var isAllWhitespace = true;
        for (var j = lineStart; j < tokens.length; j++) {
          isAllWhitespace =
            (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
            (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
          if (!isAllWhitespace) {
            return false;
          }
        }

        return isAllWhitespace;
      }

      function filterLine(haveSeenTag, noNewLine) {
        addBuf();

        if (haveSeenTag && lineIsWhitespace()) {
          for (var j = lineStart, next; j < tokens.length; j++) {
            if (tokens[j].text) {
              if ((next = tokens[j+1]) && next.tag == '>') {
                // set indent to token value
                next.indent = tokens[j].text.toString();
              }
              tokens.splice(j, 1);
            }
          }
        } else if (!noNewLine) {
          tokens.push({tag:'\n'});
        }

        seenTag = false;
        lineStart = tokens.length;
      }

      function changeDelimiters(text, index) {
        var close = '=' + ctag,
            closeIndex = text.indexOf(close, index),
            delimiters = trim(
              text.substring(text.indexOf('=', index) + 1, closeIndex)
            ).split(' ');

        otag = delimiters[0];
        ctag = delimiters[delimiters.length - 1];

        return closeIndex + close.length - 1;
      }

      if (delimiters) {
        delimiters = delimiters.split(' ');
        otag = delimiters[0];
        ctag = delimiters[1];
      }

      for (i = 0; i < len; i++) {
        if (state == IN_TEXT) {
          if (tagChange(otag, text, i)) {
            --i;
            addBuf();
            state = IN_TAG_TYPE;
          } else {
            if (text.charAt(i) == '\n') {
              filterLine(seenTag);
            } else {
              buf += text.charAt(i);
            }
          }
        } else if (state == IN_TAG_TYPE) {
          i += otag.length - 1;
          tag = Hogan.tags[text.charAt(i + 1)];
          tagType = tag ? text.charAt(i + 1) : '_v';
          if (tagType == '=') {
            i = changeDelimiters(text, i);
            state = IN_TEXT;
          } else {
            if (tag) {
              i++;
            }
            state = IN_TAG;
          }
          seenTag = i;
        } else {
          if (tagChange(ctag, text, i)) {
            tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                         i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
            buf = '';
            i += ctag.length - 1;
            state = IN_TEXT;
            if (tagType == '{') {
              if (ctag == '}}') {
                i++;
              } else {
                cleanTripleStache(tokens[tokens.length - 1]);
              }
            }
          } else {
            buf += text.charAt(i);
          }
        }
      }

      filterLine(seenTag, true);

      return tokens;
    };

    function cleanTripleStache(token) {
      if (token.n.substr(token.n.length - 1) === '}') {
        token.n = token.n.substring(0, token.n.length - 1);
      }
    }

    function trim(s) {
      if (s.trim) {
        return s.trim();
      }

      return s.replace(/^\s*|\s*$/g, '');
    }

    function tagChange(tag, text, index) {
      if (text.charAt(index) != tag.charAt(0)) {
        return false;
      }

      for (var i = 1, l = tag.length; i < l; i++) {
        if (text.charAt(index + i) != tag.charAt(i)) {
          return false;
        }
      }

      return true;
    }

    // the tags allowed inside super templates
    var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

    function buildTree(tokens, kind, stack, customTags) {
      var instructions = [],
          opener = null,
          tail = null,
          token = null;

      tail = stack[stack.length - 1];

      while (tokens.length > 0) {
        token = tokens.shift();

        if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
          throw new Error('Illegal content in < super tag.');
        }

        if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
          stack.push(token);
          token.nodes = buildTree(tokens, token.tag, stack, customTags);
        } else if (token.tag == '/') {
          if (stack.length === 0) {
            throw new Error('Closing tag without opener: /' + token.n);
          }
          opener = stack.pop();
          if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
            throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
          }
          opener.end = token.i;
          return instructions;
        } else if (token.tag == '\n') {
          token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
        }

        instructions.push(token);
      }

      if (stack.length > 0) {
        throw new Error('missing closing tag: ' + stack.pop().n);
      }

      return instructions;
    }

    function isOpener(token, tags) {
      for (var i = 0, l = tags.length; i < l; i++) {
        if (tags[i].o == token.n) {
          token.tag = '#';
          return true;
        }
      }
    }

    function isCloser(close, open, tags) {
      for (var i = 0, l = tags.length; i < l; i++) {
        if (tags[i].c == close && tags[i].o == open) {
          return true;
        }
      }
    }

    function stringifySubstitutions(obj) {
      var items = [];
      for (var key in obj) {
        items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
      }
      return "{ " + items.join(",") + " }";
    }

    function stringifyPartials(codeObj) {
      var partials = [];
      for (var key in codeObj.partials) {
        partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
      }
      return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
    }

    Hogan.stringify = function(codeObj, text, options) {
      return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
    };

    var serialNo = 0;
    Hogan.generate = function(tree, text, options) {
      serialNo = 0;
      var context = { code: '', subs: {}, partials: {} };
      Hogan.walk(tree, context);

      if (options.asString) {
        return this.stringify(context, text, options);
      }

      return this.makeTemplate(context, text, options);
    };

    Hogan.wrapMain = function(code) {
      return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
    };

    Hogan.template = Hogan.Template;

    Hogan.makeTemplate = function(codeObj, text, options) {
      var template = this.makePartials(codeObj);
      template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
      return new this.template(template, text, this, options);
    };

    Hogan.makePartials = function(codeObj) {
      var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
      for (key in template.partials) {
        template.partials[key] = this.makePartials(template.partials[key]);
      }
      for (key in codeObj.subs) {
        template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
      }
      return template;
    };

    function esc(s) {
      return s.replace(rSlash, '\\\\')
              .replace(rQuot, '\\\"')
              .replace(rNewline, '\\n')
              .replace(rCr, '\\r')
              .replace(rLineSep, '\\u2028')
              .replace(rParagraphSep, '\\u2029');
    }

    function chooseMethod(s) {
      return (~s.indexOf('.')) ? 'd' : 'f';
    }

    function createPartial(node, context) {
      var prefix = "<" + (context.prefix || "");
      var sym = prefix + node.n + serialNo++;
      context.partials[sym] = {name: node.n, partials: {}};
      context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
      return sym;
    }

    Hogan.codegen = {
      '#': function(node, context) {
        context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                        'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                        't.rs(c,p,' + 'function(c,p,t){';
        Hogan.walk(node.nodes, context);
        context.code += '});c.pop();}';
      },

      '^': function(node, context) {
        context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
        Hogan.walk(node.nodes, context);
        context.code += '};';
      },

      '>': createPartial,
      '<': function(node, context) {
        var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
        Hogan.walk(node.nodes, ctx);
        var template = context.partials[createPartial(node, context)];
        template.subs = ctx.subs;
        template.partials = ctx.partials;
      },

      '$': function(node, context) {
        var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
        Hogan.walk(node.nodes, ctx);
        context.subs[node.n] = ctx.code;
        if (!context.inPartial) {
          context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
        }
      },

      '\n': function(node, context) {
        context.code += write('"\\n"' + (node.last ? '' : ' + i'));
      },

      '_v': function(node, context) {
        context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
      },

      '_t': function(node, context) {
        context.code += write('"' + esc(node.text) + '"');
      },

      '{': tripleStache,

      '&': tripleStache
    };

    function tripleStache(node, context) {
      context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    }

    function write(s) {
      return 't.b(' + s + ');';
    }

    Hogan.walk = function(nodelist, context) {
      var func;
      for (var i = 0, l = nodelist.length; i < l; i++) {
        func = Hogan.codegen[nodelist[i].tag];
        func && func(nodelist[i], context);
      }
      return context;
    };

    Hogan.parse = function(tokens, text, options) {
      options = options || {};
      return buildTree(tokens, '', [], options.sectionTags || []);
    };

    Hogan.cache = {};

    Hogan.cacheKey = function(text, options) {
      return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
    };

    Hogan.compile = function(text, options) {
      options = options || {};
      var key = Hogan.cacheKey(text, options);
      var template = this.cache[key];

      if (template) {
        var partials = template.partials;
        for (var name in partials) {
          delete partials[name].instance;
        }
        return template;
      }

      template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
      return this.cache[key] = template;
    };
  })( exports );
  });

  var template = createCommonjsModule(function (module, exports) {

  (function (Hogan) {
    Hogan.Template = function (codeObj, text, compiler, options) {
      codeObj = codeObj || {};
      this.r = codeObj.code || this.r;
      this.c = compiler;
      this.options = options || {};
      this.text = text || '';
      this.partials = codeObj.partials || {};
      this.subs = codeObj.subs || {};
      this.buf = '';
    };

    Hogan.Template.prototype = {
      // render: replaced by generated code.
      r: function (context, partials, indent) { return ''; },

      // variable escaping
      v: hoganEscape,

      // triple stache
      t: coerceToString,

      render: function render(context, partials, indent) {
        return this.ri([context], partials || {}, indent);
      },

      // render internal -- a hook for overrides that catches partials too
      ri: function (context, partials, indent) {
        return this.r(context, partials, indent);
      },

      // ensurePartial
      ep: function(symbol, partials) {
        var partial = this.partials[symbol];

        // check to see that if we've instantiated this partial before
        var template = partials[partial.name];
        if (partial.instance && partial.base == template) {
          return partial.instance;
        }

        if (typeof template == 'string') {
          if (!this.c) {
            throw new Error("No compiler available.");
          }
          template = this.c.compile(template, this.options);
        }

        if (!template) {
          return null;
        }

        // We use this to check whether the partials dictionary has changed
        this.partials[symbol].base = template;

        if (partial.subs) {
          // Make sure we consider parent template now
          if (!partials.stackText) partials.stackText = {};
          for (key in partial.subs) {
            if (!partials.stackText[key]) {
              partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
            }
          }
          template = createSpecializedPartial(template, partial.subs, partial.partials,
            this.stackSubs, this.stackPartials, partials.stackText);
        }
        this.partials[symbol].instance = template;

        return template;
      },

      // tries to find a partial in the current scope and render it
      rp: function(symbol, context, partials, indent) {
        var partial = this.ep(symbol, partials);
        if (!partial) {
          return '';
        }

        return partial.ri(context, partials, indent);
      },

      // render a section
      rs: function(context, partials, section) {
        var tail = context[context.length - 1];

        if (!isArray(tail)) {
          section(context, partials, this);
          return;
        }

        for (var i = 0; i < tail.length; i++) {
          context.push(tail[i]);
          section(context, partials, this);
          context.pop();
        }
      },

      // maybe start a section
      s: function(val, ctx, partials, inverted, start, end, tags) {
        var pass;

        if (isArray(val) && val.length === 0) {
          return false;
        }

        if (typeof val == 'function') {
          val = this.ms(val, ctx, partials, inverted, start, end, tags);
        }

        pass = !!val;

        if (!inverted && pass && ctx) {
          ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
        }

        return pass;
      },

      // find values with dotted names
      d: function(key, ctx, partials, returnFound) {
        var found,
            names = key.split('.'),
            val = this.f(names[0], ctx, partials, returnFound),
            doModelGet = this.options.modelGet,
            cx = null;

        if (key === '.' && isArray(ctx[ctx.length - 2])) {
          val = ctx[ctx.length - 1];
        } else {
          for (var i = 1; i < names.length; i++) {
            found = findInScope(names[i], val, doModelGet);
            if (found !== undefined) {
              cx = val;
              val = found;
            } else {
              val = '';
            }
          }
        }

        if (returnFound && !val) {
          return false;
        }

        if (!returnFound && typeof val == 'function') {
          ctx.push(cx);
          val = this.mv(val, ctx, partials);
          ctx.pop();
        }

        return val;
      },

      // find values with normal names
      f: function(key, ctx, partials, returnFound) {
        var val = false,
            v = null,
            found = false,
            doModelGet = this.options.modelGet;

        for (var i = ctx.length - 1; i >= 0; i--) {
          v = ctx[i];
          val = findInScope(key, v, doModelGet);
          if (val !== undefined) {
            found = true;
            break;
          }
        }

        if (!found) {
          return (returnFound) ? false : "";
        }

        if (!returnFound && typeof val == 'function') {
          val = this.mv(val, ctx, partials);
        }

        return val;
      },

      // higher order templates
      ls: function(func, cx, partials, text, tags) {
        var oldTags = this.options.delimiters;

        this.options.delimiters = tags;
        this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
        this.options.delimiters = oldTags;

        return false;
      },

      // compile text
      ct: function(text, cx, partials) {
        if (this.options.disableLambda) {
          throw new Error('Lambda features disabled.');
        }
        return this.c.compile(text, this.options).render(cx, partials);
      },

      // template result buffering
      b: function(s) { this.buf += s; },

      fl: function() { var r = this.buf; this.buf = ''; return r; },

      // method replace section
      ms: function(func, ctx, partials, inverted, start, end, tags) {
        var textSource,
            cx = ctx[ctx.length - 1],
            result = func.call(cx);

        if (typeof result == 'function') {
          if (inverted) {
            return true;
          } else {
            textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
            return this.ls(result, cx, partials, textSource.substring(start, end), tags);
          }
        }

        return result;
      },

      // method replace variable
      mv: function(func, ctx, partials) {
        var cx = ctx[ctx.length - 1];
        var result = func.call(cx);

        if (typeof result == 'function') {
          return this.ct(coerceToString(result.call(cx)), cx, partials);
        }

        return result;
      },

      sub: function(name, context, partials, indent) {
        var f = this.subs[name];
        if (f) {
          this.activeSub = name;
          f(context, partials, this, indent);
          this.activeSub = false;
        }
      }

    };

    //Find a key in an object
    function findInScope(key, scope, doModelGet) {
      var val;

      if (scope && typeof scope == 'object') {

        if (scope[key] !== undefined) {
          val = scope[key];

        // try lookup with get for backbone or similar model data
        } else if (doModelGet && scope.get && typeof scope.get == 'function') {
          val = scope.get(key);
        }
      }

      return val;
    }

    function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
      function PartialTemplate() {}    PartialTemplate.prototype = instance;
      function Substitutions() {}    Substitutions.prototype = instance.subs;
      var key;
      var partial = new PartialTemplate();
      partial.subs = new Substitutions();
      partial.subsText = {};  //hehe. substext.
      partial.buf = '';

      stackSubs = stackSubs || {};
      partial.stackSubs = stackSubs;
      partial.subsText = stackText;
      for (key in subs) {
        if (!stackSubs[key]) stackSubs[key] = subs[key];
      }
      for (key in stackSubs) {
        partial.subs[key] = stackSubs[key];
      }

      stackPartials = stackPartials || {};
      partial.stackPartials = stackPartials;
      for (key in partials) {
        if (!stackPartials[key]) stackPartials[key] = partials[key];
      }
      for (key in stackPartials) {
        partial.partials[key] = stackPartials[key];
      }

      return partial;
    }

    var rAmp = /&/g,
        rLt = /</g,
        rGt = />/g,
        rApos = /\'/g,
        rQuot = /\"/g,
        hChars = /[&<>\"\']/;

    function coerceToString(val) {
      return String((val === null || val === undefined) ? '' : val);
    }

    function hoganEscape(str) {
      str = coerceToString(str);
      return hChars.test(str) ?
        str
          .replace(rAmp, '&amp;')
          .replace(rLt, '&lt;')
          .replace(rGt, '&gt;')
          .replace(rApos, '&#39;')
          .replace(rQuot, '&quot;') :
        str;
    }

    var isArray = Array.isArray || function(a) {
      return Object.prototype.toString.call(a) === '[object Array]';
    };

  })( exports );
  });

  /*
   *  Copyright 2011 Twitter, Inc.
   *  Licensed under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License.
   *  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   */

  // This file is for use with Node.js. See dist/ for browser files.


  compiler.Template = template.Template;
  compiler.template = compiler.Template;
  var hogan = compiler;

  var part0Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("\n" + i);t.b("<div id=\"pudding-logo\">");t.b("\n" + i);t.b("  <a href=\"https://pudding.cool\" target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("    <img inline src=\"https://pudding.cool/2021/03/wine-model/static/pudding/logo-full.svg\"/>");t.b("\n" + i);t.b("  </a>");t.b("\n" + i);t.b("</div>");t.b("\n" + i);t.b("<div id=\"title-image\">");t.b("\n" + i);t.b("  <img src=\"https://pudding.cool/2021/03/wine-model/static/grape-math-tree.png\" alt='grapevine'>");t.b("\n" + i);t.b("</div>");t.b("\n" + i);t.b("<div id=\"title-text\">");t.b("\n" + i);t.b("  <div id=\"title-header\">");t.b("\n" + i);t.b("    <h2>Wine & Math</h2>");t.b("\n" + i);t.b("    <h2>Wine & Math</h2>");t.b("\n" + i);t.b("    <h2>hidden placeholder element keeping the height</h2>");t.b("\n" + i);t.b("  </div>");t.b("\n" + i);t.b("  <h3 id=\"title-subheader\">A Model Pairing</h3>");t.b("\n" + i);t.b("  <h4><a class=\"subtle\" href=\"https://pudding.cool/author/lars-verspohl\">by Lars Verspohl<a></h4>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div id=\"intro-text\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Mention predictive modeling to the general public and you’re likely to conjure memes of complex mathematical equations swirling. Mention wine, and you get a much different reaction. One can be intimidating, the other inviting. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In this piece, we’re going to try to close that gap. We’ll build a statistical model trying to predict a wine’s quality by its properties. So grab some liquid courage in your favorite aged grape variety and get ready for MATH.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"scroll-arrow\">↓<br/><span class=\"lowlight\">scroll</span></div>");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part1Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"section section-0 empty\">");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<h1>How to describe a wine</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-1\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Before diving into building any predictive model we might want to define what we predict. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In our case, let's note that \"wine quality\" is a highly imprecise term. “Quality” to a sommelier might mean that a wine has legs and benefits from aeration. “Quality” to you might mean it’s under $10, with a twist off top.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    A quality predicting model is unlikely to rank every wine out there on a universally approved scale. Our output &mdash; or quality ranking &mdash; needs to be neatly defined and depends on our inputs &mdash; or the wine parameters we’re using to establish a baseline.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-2\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The inputs need to be in the form of measurable information, things like: <a href=\"https://www.wsetglobal.com/knowledge-centre/blog/2019/june/13/the-definitive-guide-to-wine-bottle-shapes-and-sizes/\">the shape of the wine bottle</a>, ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-3\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    the vintage year, or the grape varietal.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-4\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In our model, we’ll describe the very liquid and decompose it into its physiochemical properties, like sugars, acids, and yes, alcohol.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part2Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>A conceptual model</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-5\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Now we can assume these inputs are related to our output, meaning a certain composition of physiochemical properties are associated with a <span class=\"good\">high quality</span> outcome.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-6\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    while a different configuration of properties associates with a <span class=\"bad\">lower quality</span> wine.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-7\">");t.b("\n" + i);t.b("  <p><span class=\"highlight larger\">Try it for yourself....</span></p>");t.b("\n" + i);t.b("  <div id=\"slider-tool\">");t.b("\n" + i);t.b("    <input type=\"range\" class=\"lolli-slider\" id=\"slider-alcohol\" name=\"alcohol\" min=\"0\" max=\"1\" step=\"0.01\"/>");t.b("\n" + i);t.b("    <label for=\"slider-alcohol\">Alcohol</label>");t.b("\n" + i);t.b("    <input type=\"range\" class=\"lolli-slider\" id=\"slider-acids\" name=\"acids\" min=\"0\" max=\"1\" step=\"0.01\"/>");t.b("\n" + i);t.b("    <label for=\"slider-acids\">Acids</label>");t.b("\n" + i);t.b("    <input type=\"range\" class=\"lolli-slider\" id=\"slider-sugars\" name=\"sugars\" min=\"0\" max=\"1\" step=\"0.01\"/>");t.b("\n" + i);t.b("    <label for=\"slider-sugars\">Sugars</label>");t.b("\n" + i);t.b("  </div>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Moving these model inputs, we might hope to find a combination that yields the highest possible quality, but the only thing that matters for the model is to establish reliable relationships within the data");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-8\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    so it can &mdash; in our case &mdash; <span class=\"highlight\">express wine quality as a function of its properties</span> entirely.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-9\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We would have a <span class=\"highlight\">mathematical model</span> that takes a wine's properties as input");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-10\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    and returns some sort of estimate as to whether this wine is leaning towards being good or not so good. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The model reduces relationships between individual data columns to an equation that looks something like this:");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <div class=\"image-wrap\">");t.b("\n" + i);t.b("    <img src=\"https://pudding.cool/2021/03/wine-model/static/equation@2x.png\" alt=\"Alcohol times Alcohol weight plus Acid times Acid weight plus Sugar times Sugar weight equals Quality\">");t.b("\n" + i);t.b("  </div>");t.b("\n" + i);t.b("    <p>");t.b("\n" + i);t.b("    This is a rather simple envelope’s backside, but in essence it’s an equation that relates some inputs to an output. In our case it relates the configuration of the wine's components to its quality.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We have the inputs weighted by some input-specific factor which tells the model how much impact the respective property has on the output. The greater the weights → the more impact they have. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-11\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    But how does the model get these weights? How does it learn which property drives quality to what degree?");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part3Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>Learning by example</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-12\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("  In order to teach a predictive model to identify a good wine from a less good wine, we have to take our model by the hand and teach it. The model doesn't have our senses &mdash; it can't see, taste, or feel a wine, and we can’t be there for it in the future, to pre-taste each wine.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We all know this process of <a href=\"https://www.analyticsvidhya.com/blog/2020/04/supervised-learning-unsupervised-learning/\" target=\"_blank\" rel=\"noreferrer\">supervised learning</a> from our own childhood.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-13\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Think back to the days when you learned your animal names. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    You were probably just sitting in a proudly self-concocted puddle of peas, mash and apple juice leafing through a picture book of animal drawings, while your parents tried to teach you what a sloth looks like.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-14\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Any of these shapes could have been a sloth,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-15\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    but your parents calmly supervised your learning,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-16\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    by labelling the non-sloths");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-17\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    and celebrating the actual sloths!");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-18\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    And even though not every sloth looks the same,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-19\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    after many examples, you learned the basic features that make up a sloth. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-20\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Now, although you sometimes weren't sure whether that thing you looked at was a sloth indeed &mdash; possibly because the picture book was a bit rubbish &mdash; you learned to give it a good guess at least. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Soooo...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight large\">");t.b("\n" + i);t.b("      what's your guess with this specimen over there <span class=\"arrow\"></span>?");t.b("\n" + i);t.b("    </span>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <div id=\"sloth-wrap\">");t.b("\n" + i);t.b("    <button class=\"sloth-button\" data-answer=\"true\">Totally a sloth!</button>");t.b("\n" + i);t.b("    <button class=\"sloth-button\" data-answer=\"false\">No idea</button>");t.b("\n" + i);t.b("    <button class=\"sloth-button\" data-answer=\"false\">Anything but</button>");t.b("\n" + i);t.b("  </div>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"sloth-answer\" id=\"sloth-reveal\">It is a sloth!</span> ");t.b("\n" + i);t.b("    <span class=\"sloth-answer\" id=\"sloth-reveal-delay\">(possibly)</span>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    What you probably did here is, you scanned the configuration of lines and shapes that made up the animal and gauged how likely it is for this thing to be a sloth.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    That's exactly what a mathematical model does, too: ");t.b("\n" + i);t.b("    <ol>");t.b("\n" + i);t.b("      <li>you give it <span class=\"highlight\">examples</span> (many at best) </li>");t.b("\n" + i);t.b("      <li>you <span class=\"highlight\">label</span> them with what you want your model to learn </li>");t.b("\n" + i);t.b("      <li>and let it detect <span class=\"highlight\">patterns</span>...</li>");t.b("\n" + i);t.b("      <li>that help your concluding  <span class=\"highlight\">classification</span>.</li>");t.b("\n" + i);t.b("    </ol>");t.b("\n" + i);t.b("  </p>");t.b("\n");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-21\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    So &mdash; moving back to our wine example...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-22\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    we're interested in classifying wines into");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-23\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"good\">...high-quality</span");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-24\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    ...and <span class=\"bad\">low-quality</span> wines.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    But whatever we do, a single bottle won’t be enough.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-25\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Just like a single animal drawing won't teach a child what a sloth is, a model needs as many wines as we can get hold of.");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("    Let's get some...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-26\">");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-27\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Each wine in this dataset is labelled as either a <span class=\"good\">high</span> or a <span class=\"bad\">low-quality</span> wine. This is the dataset we train the model with, our <a href=\"https://developers.google.com/machine-learning/crash-course/training-and-test-sets/splitting-data\" target=\"_blank\" rel=\"noreferrer\">training set</a>. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Training sets are all-knowing. They have all the model inputs as well as  the model output variable &mdash; the quality ranking in our case &mdash;  so they can train the model. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    After the model is trained it shouldn’t need these labels and we can test how accurate it predicts each case with another dataset &mdash; a <a href=\"https://developers.google.com/machine-learning/crash-course/training-and-test-sets/splitting-data\" target=\"_blank\" rel=\"noreferrer\">test set</a> &mdash; consisting only of wines with inputs and no outputs.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-28\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    To calculate the model, the algorithm first splits the dataset into <span class=\"good\">high</span> and <span class=\"bad\">low quality</span> wines before identifying how the characteristics of each group correlate with the output variable. For example, higher quality wines might have a higher alcohol level than lower quality wines. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Lastly it would formulate these results in a weighted model equation.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});

  var part4Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>The data we have</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-29\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We've covered the process in broad, conceptual terms. To build an actual model, we need a real, sizeable dataset with labelled data!");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-30\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We’ll use <a href=\"https://archive.ics.uci.edu/ml/datasets/wine+quality\" target=\"_blank\" rel=\"noreferrer\">this dataset</a> of 1,600 wines from Portugal,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-31\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    with each row representing a wine");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-32\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    that received a quality rating, which is based on at least three evaluations from wine experts, ranging from 0 (🥀) to 10 (🏆)");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-33 section-34 section-35 section-36 section-37 section-38 section-39 section-40 section-41 section-42\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    as well as the wine’s specific physiochemical property values.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-43\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    All these wines are red wines from the <a href=\"https://en.wikipedia.org/wiki/Vinho_Verde\" target=\"_blank\" rel=\"noreferrer\">Vinho Verde</a> region in the north west of Portugal. Each wine was analysed, and quality assessed between 2004 and 2007 by the <span class=\"highlight\">Viticulture Commission of the Vinho Verde Region</span>. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The Commission is concerned with guaranteeing the quality and authenticity of regional wines by <a href=\"https://portal.vinhoverde.pt/pt/estatisticas\" target=\"_blank\" rel=\"noreferrer\">certifying</a> the wine's origin and making sure the wine's properties stay within <a href=\"https://portal.vinhoverde.pt/pt/produtos-regras-de-conformidade/GVT\" target=\"_blank\" rel=\"noreferrer\">legislated value ranges</a>. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    As such, <span class=\"highlight\">\"quality\"</span> is indeed defined as a measure of taste but strictly limited to a sample of Vinho Verde wines of a specific period. We should be aware of this context and remember that this data won't generalise to every wine under the sun.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Now that we have the data, we need to get a sense of the base shape and correlations.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});

  var part5Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>The shape of the data</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-44\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Here are 1,600 tiny bottles (disguised as dots) unfolding into a well-behaved grid.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Let's give them some shape...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-45\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Here’s <span class=\"highlight\">Alcohol</span>. Most wines are between 9 and 12% with quite a few bottles around the 9.5% mark. This is low for reds, which tend to be <a href=\"https://winefolly.com/tips/alcohol-content-in-wine/\" target=\"_blank\" rel=\"noreferrer\">between 12 and 15%</a>.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We can look at other characteristics like...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-46\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Density</span>,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-47\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Fixed Acids</span>,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-48\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">pH</span> and more.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-49\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    But one key variable in our data is of course:");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-50\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Quality</span>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Here’s how the Commisssion's wine assessors marked all wines on a scale from 0 to 10. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    no wine got worse than 3 or better than 8 and most wines clustered around the 5 or 6 mark with an average of 5.6.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    These individual distributions are key to getting a base understanding of our data, but ultimately, we want to know how the physiochemical properties relate to each other and specifically how they relate to quality. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In order to make this more visible, let’s split all our wines into two groups: ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-51\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    wines of <span class=\"bad\">lower quality</span> (anything rated below 7) and wines of <span class=\"good\">high quality</span> (wines rated 7 and above).");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Note, how the majority of medium quality wines mingle in the centre. As such, <span class=\"good\">\"high-quality\"</span> for this dataset really does mean good from the assessors perspective, while <span class=\"bad\">\"low-quality\"</span> includes truly low-quality wines as well as average wines resulting in a proportionally larger class.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Models don't particularly like this imbalance and we would typically counter this with <a href=\"https://ieeexplore.ieee.org/document/7475021\" target=\"_blank\" rel=\"noreferrer\">helpful techniques</a>; but we'll keep it simple here.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We can now check how our variables distribute across these two simple categories. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    First, let’s look at <span class=\"highlight\">Volatile Acidity</span>...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-52\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The <span class=\"good\">blue, better wines</span> predominantly sport lower levels and &mdash; reversely &mdash; the <span class=\"bad\">worse wines</span> have the highest levels of volatile acidity, potentially impacting taste in a negative way.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We can look at the same data in a scatter plot,");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-53\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    which maybe more clearly suggests that the lower the volatile acidity → the higher the quality in this very dataset.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-54\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Let's also look at <span class=\"highlight\">Alcohol</span>.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The association is flipped here &mdash; higher quality wines are likely to have more alcohol in this data, as a solid proportion of especially wines around the 12-13% mark was voted good. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"arrow\"></span>Look at that 9.5% bar. Considering this is the most populated section, it’s interesting to see how few wines are deemed <span class=\"good\">high quality</span> in here.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-55\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The scatter plot also shows the general trend. The higher the alcohol → the better the wine");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <sub>");t.b("\n" + i);t.b("    <a href=\"https://pruned-correlations.netlify.app\" target=\"_blank\" rel=\"noreferrer\">Here's a whole separate piece</a> about all correlations in this dataset...");t.b("\n" + i);t.b("  </sub>");t.b("\n" + i);t.b("</div>");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part6Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>The shape of the model</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Now that we know there are some associations between the physiochemical properties (inputs) and the wine quality (output), let’s see if we can build a model that fits a curve best representing the relationship between the two.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    For simplicity’s sake let's say, we want to build a model with a single predictor: <span class=\"highlight\">Alcohol</span>. ");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("    One of the simpler options is to build a so-called <a href=\"https://setosa.io/ev/ordinary-least-squares-regression/\" target=\"_blank\" rel=\"noreferrer\">Ordinary Least Squares Regression</a> model that predicts wine quality solely on Alcohol, which might look something like this:");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-56\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The model in this case very much <span class=\"highlight\">is</span> the line. Reality &mdash; the actual distribution of our wines in the scatter plot &mdash; is of course more complex as we can see. Our model is rather a reduced approximation of reality &mdash; it captures the association's essence &mdash; and it fits into a simple equation:");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p class=\"center\">");t.b("\n" + i);t.b("    <i><span class=\"highlight\">y = m &middot; x + b</span></i>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p class=\"tight-bottom\">");t.b("\n" + i);t.b("    <span class=\"highlight\">y</span> represents the quality output value ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p class=\"tight-top tight-bottom\">");t.b("\n" + i);t.b("    <span class=\"highlight\">x</span> the alcohol input value. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p class=\"tight-top tight-bottom\">");t.b("\n" + i);t.b("    <span class=\"highlight\">b</span> represents the intercept (the point the line crosses the y axis when <span class=\"highlight\">x = 0</span>) and");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p class=\"tight-top tight-bottom\">");t.b("\n" + i);t.b("    <span class=\"highlight\">m</span> the slope of the line or in our case, how much our quality goes up if we add one percent of alcohol.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("    We can now use this equation to predict Quality solely on Alcohol.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-57\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Plugging in an Alcohol value of <span class=\"highlight\">x = 12%</span>, for example, will return a Quality (a <span class=\"highlight\">y</span> value) just above 6. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    That's nice! We can do this for any value, however, we’ll soon hit a problem that might bend reality just a little too much…");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-58\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Because the line theoretically extends indefinitely into any direction, it can lead to rather nonsensical results, like, for example, quality values above 10 or even negative quality ratings.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Instead, we’d like a model equation that doesn’t produce a straight line.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-59\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    To get there, we first make things worse, by simplifying our continuous data to a binary variable: 0 for <span class=\"bad\">low</span>, 1 for <span class=\"good\">high quality</span>. This indeed exacerbates our line problems. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    To win, we need a different model function. One that doesn’t produce a line but something like this...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-60\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    This is a typical curve for a <a href=\"https://en.wikipedia.org/wiki/Logistic_regression\" target=\"_blank\" rel=\"noreferrer\">Logistic Regression</a> model.");t.b("\n" + i);t.b("  </p>");t.b("\n");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We can now express the relationship between alcohol and quality in probabilities from 0 to 100%. For example, if a wine has an alcohol level of 12 it has an 86% probability of being good. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    This helps us express the likelihood of a wine being a certain quality: 20% good is obviously not quite as certain as 100% good.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    It’s like with a badly drawn sloth. We might not be totally sure about it being a sloth, but we might consider it likely.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part7Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>A grown up model</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    These are the basics. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    For our full model we draw a curve not only for one but for eleven predictors, which is pretty impossible to display in a single visual as you can imagine. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-61\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    One caveat of linear models &mdash; like linear and logistic regression &mdash; is that they model correlation: how things move in the same or in opposite directions. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    They won't be able to identify non-linear relationships, like, for example, an Alcohol tipping point before which quality goes up and beyond which quality decreases.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    So, model selection is a big topic for itself and would be very much worth everyone's while in this case. Apart from potentially higher accuracy, other model types provide further tools that can be useful...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-62\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    For example, a model from the <a href=\"https://en.wikipedia.org/wiki/Random_forest\" target=\"_blank\" rel=\"noreferrer\">Random Forest</a> family of machine learning algorithms will enlighten us with a ranking of which variables are most important in our predictions.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In this case, Alcohol appears to have the biggest impact on Quality, followed by Volatile Acidity and the amount of sulphates in the wine. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    You might disagree with this ranking. That's fine &mdash; numbers can only tell us so much. Your experience or intuition can be used to question the model, add or remove variables. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section no-trigger\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    But assuming we're happy with this, you can think of each predictor &mdash; each variable in your data &mdash; as a <span class=\"highlight\">model knob</span> you can adjust to achieve the highest quality wine &mdash; in the model's opinion, that is. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-63\">");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-64\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    In fact, let's do this now...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section section-65\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"arrow\"></span> This wine over there isn't that great yet. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    It's only 5% full &mdash; which means its physiochemical properties indicate only a 5% chance of it being good. This is what you get when taking the average value for each wine property, represented by the vertical line in the distribution chart below.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Drag the handle to add or decrease any of the properties in the wine and see how it affects the modelled wine quality.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Over to you now to produce a winner &mdash; or a washout... Bottoms up!");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n");return t.fl(); },partials: {}, subs: {  }});

  var part8Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1>Quality simulator</h1>");t.b("\n" + i);t.b("<h3>Adjust the handles to make your wine</h3>");return t.fl(); },partials: {}, subs: {  }});

  var part9Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<h1 class=\"tight-top\">What next?</h1>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section tight-bottom\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Hopefully, this exploration helped make machine learning a little more palatable and showed how technology can be used to rate what’s in your glass.");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    We used a simple linear model to predict red wine quality using a dataset full physiochemical properties of Vinho Verde wines. As a next step it might be interesting to swap out any or all of these components:");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Output</span>. Our model looked at what properties defined <span class=\"good\">high quality</span> wines, but what happens if instead of quality we wanted to predict specific taste features or sales figures. What inputs get us there?");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Dataset</span>. We looked at one dataset of red wines from Vinho Verde. What happens when we look at datasets from other wineries with different characteristics?");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    <span class=\"highlight\">Model type</span>. We used a linear model, what happens when we use a non-linear model, like <a href=\"https://en.wikipedia.org/wiki/Support_vector_machine\" target=\"_blank\" rel=\"noreferrer\">Support Vector Machines</a> or <a href=\"https://en.wikipedia.org/wiki/Artificial_neural_network\" target=\"_blank\" rel=\"noreferrer\">Neural Networks</a>? Those models might prove more accurate, but could also be overly complex.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Maybe for another day...");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Santé 🍷");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");t.b("\n");t.b("\n" + i);t.b("<div class=\"section tight-top\" id=\"credits\">");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Written with and refined by → <a href=\"https://pudding.cool/author/jan-diehm/\">Jan Diehm</a> ←");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    The dataset and the original model can be found in the paper: <i>P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. <a href=\"https://scinapse.io/papers/2103459159\" target=\"_blank\" rel=\"noreferrer\">Modeling wine preferences by data mining from physicochemical properties.</a> In Decision Support Systems, Elsevier, 47(4):547-553, 2009</i>. ");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    This paper, however, wasn't the only analytical adventure based on the data. The dataset aquired a life of its own thereafter, being adopted and embraced by the data science and machine learning community, so you can find a lot of analyses out there wrangling and modelling this very dataset.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("  <p>");t.b("\n" + i);t.b("    Much thanks to <a href=\"https://www.linkedin.com/in/shawn-zizzo-109783/\" target=\"_blank\" rel=\"noreferrer\">Shawn Zizzo</a> and <a href=\"https://vinoez.com/\" target=\"_blank\" rel=\"noreferrer\">vinoez</a> for kicking this thing off! Big thanks also to Krista Ehrenclou for the most detailed, valuable and wise feedback about all the wine related aspects in particular as well as <a href=\"https://twitter.com/martgnz\" target=\"_blank\" rel=\"noreferrer\">Martin Gonzales</a> and <a href=\"https://www.behance.net/g-gaborieau-bookatme\" target=\"_blank\" rel=\"noreferrer\">Geoffroy Gaborieau</a> for keeping me honest on the visual and design side.");t.b("\n" + i);t.b("  </p>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});

  var part10Html = new hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div id=\"stories\"></div>");t.b("\n");t.b("\n" + i);t.b("<div class='footer-company'>");t.b("\n" + i);t.b("	<div class='footer-company__about'>");t.b("\n" + i);t.b("		<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/logo-full.svg'>");t.b("\n" + i);t.b("		<p class='footer-company__description'>");t.b("\n" + i);t.b("			<a href='https://pudding.cool' target=\"_blank\" rel=\"noreferrer\">The Pudding</a> ");t.b("\n" + i);t.b("			is a digital publication that explains ideas debated in culture with visual essays.");t.b("\n" + i);t.b("		</p>");t.b("\n" + i);t.b("	</div>");t.b("\n" + i);t.b("	<div class='footer-company__cta'>");t.b("\n" + i);t.b("		<ul class='footer-company__cta-list'>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://facebook.com/pudding.viz/' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/facebook.svg'>");t.b("\n" + i);t.b("					<p>FACEBOOK</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://twitter.com/puddingviz/' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/twitter.svg'>");t.b("\n" + i);t.b("					<p>TWITTER</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://www.instagram.com/the.pudding' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/instagram.svg'>");t.b("\n" + i);t.b("					<p>INSTAGRAM</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://patreon.com/thepudding/' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/patreon.svg'>");t.b("\n" + i);t.b("					<p>PATREON</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://pudding.cool/about' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/info.svg'>");t.b("\n" + i);t.b("					<p>ABOUT</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://pudding.cool/privacy/' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/lock.svg'>");t.b("\n" + i);t.b("					<p>PRIVACY</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='http://eepurl.com/czym6f' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/mail.svg'>");t.b("\n" + i);t.b("					<p>NEWSLETTER</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("			<li>");t.b("\n" + i);t.b("				<a href='https://pudding.cool/feed/index.xml' target=\"_blank\" rel=\"noreferrer\">");t.b("\n" + i);t.b("					<img inline src='https://pudding.cool/2021/03/wine-model/static/pudding/rss.svg'>");t.b("\n" + i);t.b("					<p>RSS</p>");t.b("\n" + i);t.b("				</a>");t.b("\n" + i);t.b("			</li>");t.b("\n" + i);t.b("		</ul>");t.b("\n" + i);t.b("	</div>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});

  gsapWithCSS.registerPlugin(MorphSVGPlugin$1, DrawSVGPlugin, ScrollTrigger, GSDevTools); // Helpers.

  function setModelWeightMap(array) {
    var mapResult = map();
    array.forEach(function (d) {
      return mapResult.set(d.term, d.estimate);
    });
    return mapResult;
  }

  function getModelValues(data) {
    var predictors = data.columns.filter(function (d) {
      return d !== 'id' && d !== 'index' && d !== 'quality' && d !== 'quality_binary';
    });
    var meanMap = map();
    var rangeMap = map();
    predictors.forEach(function (col) {
      meanMap.set(col, mean(data, function (d) {
        return d[col];
      }));
      rangeMap.set(col, extent(data, function (d) {
        return d[col];
      }));
    });
    return {
      meanMap: meanMap,
      rangeMap: rangeMap
    };
  } // Handlers.


  function removeSpinner() {
    // Remove the loading site just after loading.
    // (to give it some time to stretch).
    timeout$1(function () {
      select('#loading img').transition().duration(500).style('opacity', 0);
      select('#loading').transition().duration(1000).style('opacity', 0);
    }, 750);
  } // Build funcs.


  function prepareVisuals(globeData, wineData, varImpData, modelIntercept, modelWeights) {
    var svg = select('#svg-hidden');
    var stageGroup = svg.append('g').attr('id', 'stage-group');
    var rg = st.svg(svg.node()).generator; // Add glass/bottle morph paths.

    var roughBottle = rg.path(bottle, {
      simplification: 0.6
    });
    var roughBottlePath = rg.toPaths(roughBottle);
    stageGroup.append('path').attr('id', 'glass-path').attr('d', glass).style('fill', 'none').style('stroke-width', 1).style('stroke', 'grey');
    stageGroup.append('path').attr('id', 'bottle-path').attr('d', roughBottlePath[0].d).style('fill', 'none').style('stroke-width', 1).style('stroke', 'grey'); // Prep bottle dims.

    state.glassBottle.bottleBox = getBox('#bottle-path'); // Prep text bottle.

    var bottleTexts = splitPath(textBottle);
    state.bottleText.dims = bottleTexts.map(function (p) {
      return getPathData(p);
    });
    state.bottleText.maxLength = max(state.bottleText.dims, function (d) {
      return d.length;
    });
    state.bottleText.dashOffset = lodash_clonedeep(state.bottleText.maxLength);
    state.bottleText.paths = bottleTexts.map(function (p) {
      return new Path2D(p);
    }); // Prep bottle wave.

    state.bottleWave.bottlePath = new Path2D(bottle); // Prep lolly chart.
    // Get the lolly's path data (the paths and the length).

    var lolliTextPaths = [textAlcohol, textAcids, textSugars, textQuality].map(getPathData); // Set the data
    // `value` is the mutable value to change,
    // `values` has all values we want to gsap to.

    state.lolli.data = {
      alcohol: {
        value: 0,
        values: [0, 0.6, 0.05, 0.5, 0],
        radius: 0,
        text: lolliTextPaths[0],
        offset: {
          x: 0,
          y: 0
        }
      },
      acids: {
        value: 0,
        values: [0, 0.3, 0.95, 0.5, 0],
        radius: 0,
        text: lolliTextPaths[1],
        offset: {
          x: 0,
          y: 0
        }
      },
      sugars: {
        value: 0,
        values: [0, 0.7, 0.2, 0.5, 0],
        radius: 0,
        text: lolliTextPaths[2],
        offset: {
          x: 0,
          y: 0
        }
      },
      quality: {
        value: 0,
        values: [0, 0.88, 0.08, 0.68, 0],
        radius: 0,
        text: lolliTextPaths[3],
        offset: {
          x: 0,
          y: 0
        }
      }
    }; // A bit roundabout, but in order to gsapolate the values we need them in
    // objects as below. But to iterate through them in the canvas draw function
    // we need at least the names in an array like here:

    state.lolli.keys = Object.keys(state.lolli.data); // Get the blackbox pathdata.

    state.blackBox.box = getPathData(blackBox);
    state.blackBox.model = getPathData(textModel);
    stageGroup.append('path').attr('id', 'black-box-path').attr('d', blackBox).style('fill', 'none').style('stroke-width', 0).style('stroke', 'none');
    state.blackBox.boxDims = getBox('#black-box-path'); // All animals, their paths and how they should be scaled.
    // prettier-ignore

    state.animals.data = [{
      name: 'animalPig',
      path: animalPig,
      fit: {
        width: 0.5,
        height: 0
      }
    }, {
      name: 'animalCroc',
      path: animalCroc,
      fit: {
        width: 0.5,
        height: 0
      }
    }, {
      name: 'animalGiraffe',
      path: animalGiraffe,
      fit: {
        width: 0,
        height: 0.8
      }
    }, {
      name: 'animalSloth1',
      path: animalSloth1,
      fit: {
        width: 0.5,
        height: 0
      }
    }, {
      name: 'animalWhale',
      path: animalWhale,
      fit: {
        width: 0.5,
        height: 0
      }
    }, {
      name: 'animalBird',
      path: animalBird,
      fit: {
        width: 0.5,
        height: 0
      }
    }, {
      name: 'animalSloth2a',
      path: animalSloth2a,
      fit: {
        width: 0,
        height: 0.7
      }
    }]; // Add the paths to the DOM.

    var animalPaths = stageGroup.append('g').attr('class', 'animals').selectAll('.animal').data(state.animals.data).join('path').attr('class', 'animal').attr('id', function (d) {
      return d.name;
    }).attr('d', function (d) {
      return d.path;
    }); // Get each animal path's BBox.

    animalPaths.each(function (d) {
      state.animals[d.name] = this.getBBox();
    }); // Set the paths and info of all dataset's elements.

    state.dataset.info = [{
      name: 'grid',
      paths: dataset00Grid,
      tween: 'datasetGrid'
    }, {
      name: 'id',
      paths: dataset01Id,
      tween: 'datasetId'
    }, {
      name: 'quality',
      paths: dataset02Quality,
      tween: 'datasetQuality'
    }, {
      name: 'fxAcidity',
      paths: dataset03FAcidity,
      tween: 'datasetFxAcidity'
    }, {
      name: 'vlAcidity',
      paths: dataset04VAcidity,
      tween: 'datasetVlAcidity'
    }, {
      name: 'citric',
      paths: dataset05Citric,
      tween: 'datasetCitric'
    }, {
      name: 'sugar',
      paths: dataset06Sugar,
      tween: 'datasetSugar'
    }, {
      name: 'chlorides',
      paths: dataset07Chlorides,
      tween: 'datasetChlorides'
    }, {
      name: 'sulfur',
      paths: dataset08Sulfur,
      tween: 'datasetSulfur'
    }, {
      name: 'density',
      paths: dataset09Density,
      tween: 'datasetDensity'
    }, {
      name: 'ph',
      paths: dataset10Ph,
      tween: 'datasetPh'
    }, {
      name: 'sulphates',
      paths: dataset11Sulphates,
      tween: 'datasetSulphates'
    }, {
      name: 'alcohol',
      paths: dataset12Alcohol,
      tween: 'datasetAlcohol'
    }]; // Get the path info for each element.

    state.dataset.info.forEach(function (d) {
      return state.dataset[d.name] = getPathData(d.paths);
    }); // Also, the grid and columns share the same base bounding box,
    // so we just need a single bbox, we take from the grid:

    state.dataset.box = getBox(false, dataset00Grid); // Save the world json.

    state.globe.data = globeData; // Save the wine data

    state.stats.data = wineData; // Get a link grid.

    var n = 40;
    var links = [];

    for (var y = 0; y < n; ++y) {
      for (var x = 0; x < n; ++x) {
        if (y > 0) links.push({
          source: (y - 1) * n + x,
          target: y * n + x
        });
        if (x > 0) links.push({
          source: y * n + (x - 1),
          target: y * n + x
        });
      }
    }

    state.stats.links = links; // Variable importance.

    state.varImp.data = varImpData.sort(function (a, b) {
      return b.importance - a.importance;
    }); // Model.

    state.model.intercept = modelIntercept[0].estimate;
    state.model.weights = setModelWeightMap(modelWeights);
    var modelValues = getModelValues(state.stats.data);
    state.model.values = modelValues.meanMap;
    state.model.ranges = modelValues.rangeMap;
    state.model.probability = getProbability(state.model.values, state.model.weights, state.model.intercept); // Model bottle.

    var bottlePath = roughBottlePath.map(function (d) {
      return d.d;
    }).join();
    var bottlePathInfo = getPathData(bottlePath);
    state.modelBottle.paths = bottlePathInfo.paths;
    state.modelBottle.maxLength = bottlePathInfo.length;
  }

  function buildStory(puddingStories) {
    // Intro text.
    var introContainer = select('#container-intro');
    var introHtml = part0Html.render();
    introContainer.html(introHtml); // Main text.

    var container = select('#text-container'); // Set up the article sections.

    var sectionData = [{
      id: 'part-1',
      html: part1Html.render()
    }, {
      id: 'part-2',
      html: part2Html.render()
    }, {
      id: 'part-3',
      html: part3Html.render()
    }, {
      id: 'part-4',
      html: part4Html.render()
    }, {
      id: 'part-5',
      html: part5Html.render()
    }, {
      id: 'part-6',
      html: part6Html.render()
    }, {
      id: 'part-7',
      html: part7Html.render()
    }]; // Add the main text html.

    container.selectAll('.main-section').data(sectionData).join('section').attr('class', function (d) {
      return "main-section ".concat(d.id);
    }).html(function (d) {
      return d.html;
    }); // Set up the sloth button interaction.

    slothReveal(); // Add model base.
    // needs to come at the bitter end to stop at top and become scrollable.

    var modelApp = select('#text-container').append('div').attr('id', 'model-app');
    modelApp.append('div').attr('id', 'model-app-header').html(part8Html.render());
    modelApp.append('div').attr('id', 'model-app-wrap'); // Outro.

    container.append('section').attr('class', 'main-section part-9').html(part9Html.render()); // Footer.

    select('footer').html(part10Html.render());
    var picked = puddingStories.filter(function (d, i) {
      return i < 5 && d.url !== '2021/03/wine-model';
    });
    var stories = select('#stories').selectAll('div').data(picked).join('div').attr('class', 'story').append('a').attr('href', function (d) {
      return "https://pudding.cool/".concat(d.url);
    }).attr('target', '_blank').attr('rel', 'noreferrer');
    stories.append('div').attr('class', 'image').append('img').attr('alt', 'story image').attr('src', function (d) {
      return "https://pudding.cool/common/assets/thumbnails/640/".concat(d.image, ".jpg");
    });
    stories.append('p').html(function (d) {
      return d.hed;
    });
  } // Main func.


  function ready(_ref) {
    var _ref2 = _slicedToArray(_ref, 7),
        wineScape = _ref2[0],
        globeData = _ref2[1],
        wineData = _ref2[2],
        varImpData = _ref2[3],
        modelIntercept = _ref2[4],
        modelWeights = _ref2[5],
        puddingStories = _ref2[6];

    // Make sure all variable names are lower case! This is not checked in the app.
    prepareVisuals(globeData, wineData, varImpData, modelIntercept, modelWeights);
    buildStory(puddingStories);
    update(wineScape); // Debounced resize.

    var debounced = lodash_debounce(function () {
      return update(wineScape);
    }, 500);
    window.addEventListener('resize', debounced);
  }

  function init$1() {
    window.addEventListener('load', removeSpinner);
    var wineScape = image('https://pudding.cool/2021/03/wine-model/static/wine-scape.png');
    var globeData = json('https://pudding.cool/2021/03/wine-model/data/world-simple.json');
    var wineData = csv$1('https://pudding.cool/2021/03/wine-model/data/winedata.csv', autoType);
    var varImpData = csv$1('https://pudding.cool/2021/03/wine-model/data/importance.csv', autoType);
    var modelIntercept = csv$1('https://pudding.cool/2021/03/wine-model/data/model-intercept.csv', autoType);
    var modelWeights = csv$1('https://pudding.cool/2021/03/wine-model/data/model-weights.csv', autoType);
    var date = Date.now();
    var puddingStories = json("https://pudding.cool/assets/data/stories.json?v=".concat(date));
    Promise.all([wineScape, globeData, wineData, varImpData, modelIntercept, modelWeights, puddingStories]).then(ready);
  }

  init$1();

})));
